{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome\n\n\nWelcome to the documentation for MFractor, incredible tools for Visual Studio Mac.\n\n\nMFractor Video Guide\n\n\nCOMING SOON: Get started with MFractor with a quick start video series\n\n\nSupport\n\n\nIf something doesn't work quite right or you'd like a sweet new feature added, be patient and contact me:\n\n\n\n\nVia Twitter: Give me a holla at \n@matthewrdev\n\n\nVia Slack: Drop in to chat anytime in the \n#mfractor Xamarin Slack sub-channel\n.\n\n\nVia Email: Shoot an email to hello@mfractor.com\n\n\n\n\nThank you for installing and using MFractor.\n\n\nMatthew Robbins - Creator of MFractor. \u270c\ufe0f", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome", 
            "text": "Welcome to the documentation for MFractor, incredible tools for Visual Studio Mac.", 
            "title": "Welcome"
        }, 
        {
            "location": "/#mfractor-video-guide", 
            "text": "COMING SOON: Get started with MFractor with a quick start video series", 
            "title": "MFractor Video Guide"
        }, 
        {
            "location": "/#support", 
            "text": "If something doesn't work quite right or you'd like a sweet new feature added, be patient and contact me:   Via Twitter: Give me a holla at  @matthewrdev  Via Slack: Drop in to chat anytime in the  #mfractor Xamarin Slack sub-channel .  Via Email: Shoot an email to hello@mfractor.com   Thank you for installing and using MFractor.  Matthew Robbins - Creator of MFractor. \u270c\ufe0f", 
            "title": "Support"
        }, 
        {
            "location": "/installation-and-setup/", 
            "text": "Installation And Setup\n\n\nInstalling, activating and updating MFractor for Visual Studio Mac\n\n\nInstall Using The Installer Script\n\n\nThe fastest way to install MFractor is using the installation script:\n\n\nDownload the MFractor script\n\n\nThis will download \nMFractor.zip\n; this contains the installation script and instructions on installation.\n\n\nTo install:\n\n\n\n\nClose Visual Studio for Mac.\n\n\nDouble click on \nMFractor.zip\n to extract the archive.\n\n\nOpen the folder \nMFractor\n./\n\n\nRight click on \ninstall-mfractor.command\n and select \nOpen\n.\n\n\nIf prompted, confirm opening by selecting \nOpen\n\n\nWait for MFractor to install into Visual Studio for Mac.\n\n\nAfter installing, Visual Studio for Mac will open and prompt you to activate.\n\n\n\n\nDone!\n\n\n\n\nInstall Using MFractor.Installer Extension\n\n\nWe can also install MFractor into Visual Studio Mac by using the MFractor.Installer helper extension.\n\n\nThis extension lives inside the Extension Manager in Visual Studio Mac, under \nGallery\n -\n \nIDE extensions\n.\n\n\nOpen up Visual Studio Mac and click on the \nVisual Studio\n menu and then \nExtensions...\n\n\n\n\nOnce the Extension Manager opens, click \nGallery\n and under \nIDE extensions\n locate \nMFractor.Installer\n. If this isn't present, hit the \nRefresh\n button to update the Gallery listings.\n\n\n\n\nOnce you've located \nMFractor.Installer\n, left-click on it to select it. In the right-hand detail view, click \nInstall\n. Visual Studio Mac will prompt you for confirmation, click \nInstall\n\n\n\n\nYou will then see a download dialog appear and MFractor will download and install.\n\n\n\n\nInstall MFractor Manually\n\n\nMFractor can be installed directly through the Extension Manager's \nInstall from file\n button.\n\n\nFirstly, download the latest version of MFractor for Visual Studio Mac at \naddins.mfractor.com/MFractor.mpack\n\n\nOpen up Visual Studio Mac and click on the \nVisual Studio\n menu and then \nExtensions...\n\n\n\n\nWithin the Extension Manager, click the \nInstall from file\n button in the bottom left of the Extension Manager.\n\n\nBrowse to \nMFractor.mpack\n and then select \nOpen\n:\n\n\n\n\nActivating MFractor Free\n\n\nMFractor comes in both a free and a paid version. The free version of MFractor\n\n\nTo use MFractor, you need to activate it using your email address; this will enable the free version of MFractor only. To\n\n\nFirst things first, \nclose the Extension Manager\n. There is a known bug that blocks the email entry field from receiving keyboard when the Extension Manager is open\n\n\nTo activate MFractor, enter your email and then click \nActivate\n.\n\n\n\n\nTada! You are now ready to rock.\n\n\nActivating MFractor Premium\n\n\nDownload and locate your license file (which ends with the extension \n.lic\n). When purchasing MFractor Premium, this license file will be provided in an email. In this example, our license file is located on our desktop called \nlicense.lic\n.\n\n\n\n\nOpen Visual Studio for Mac. If you have not activated MFractor with an email address, close the activation window.\n\n\n\n\nIn the main Visual Studio for Mac menu bar, select \nHelp\n, then \nMFractor\n and then finally \nLicense Information\n. This will open the licensing window where you can import or remove an MFractor Premium license.\n\n\nNext, click on the \nImport License\n button, browse to where our license is located (\nlicense.lic\n) and double click it to import the license into MFractor.\n\n\n\n\nVoila, you now have a valid, active MFractor Premium installation.\n\n\nIt is safe to delete the license file from its original location. MFractor stores the license inside itself.\n\n\n\n\nThe licensing window will list:\n\n\n\n\nLicensed To\n - The full name of the person that the MFractor Premium license is issued to.\n\n\nLicense Email:\n - The email that this MFractor Premium license is issued against.\n\n\nLicense Type and Expiry Date\n - The type of license issued (Premium, Trial or Free) and when that license expires.\n\n\n\n\nDeactivating Your Premium License\n\n\nIf you'd like to remove a license from MFractor, you can open the MFractor license information window and click \nRemove License\n.\n\n\nIMPORTANT: This is a destructive operation, you cannot undo removing a license but you can re-import a new license.\n\n\nAfter removing a license, you will be automatically downgraded to a free MFractor license. This allows usage of most features apart from C# code actions, mobile-specific C# code diagnostics, and configuration file support.\n\n\nView the free vs paid feature map here\n.\n\n\nUpdating MFractor\n\n\nWhen MFractor installs into Visual Studio Mac, it'll register itself into Visual Studio Macs extension updater.\n\n\nThis means that Visual Studio Mac will automatically prompt you that an update is available.\n\n\nHowever, you can check for update at any time by opening the \nVisual Studio Mac\n main menu and selecting \nCheck for Updates...\n\n\n\n\nVisual Studio Mac will check the MFractor extension server for updates and prompt you to update if there is a new version!\n\n\nUninstalling MFractor\n\n\nYou can uninstall MFractor through the Extension Manager at any time.\n\n\nSelect the \nVisual Studio Mac\n main menu and then \nAddins\n\n\nUnder \nGallery\n then \nIDE extensions\n select the MFractor extension list item and then click \nUninstall\n\n\nYou will be prompted to uninstall the extension, confirm uninstallation by clicking \nUninstall", 
            "title": "Installation And Setup"
        }, 
        {
            "location": "/installation-and-setup/#installation-and-setup", 
            "text": "Installing, activating and updating MFractor for Visual Studio Mac", 
            "title": "Installation And Setup"
        }, 
        {
            "location": "/installation-and-setup/#install-using-the-installer-script", 
            "text": "The fastest way to install MFractor is using the installation script:  Download the MFractor script  This will download  MFractor.zip ; this contains the installation script and instructions on installation.  To install:   Close Visual Studio for Mac.  Double click on  MFractor.zip  to extract the archive.  Open the folder  MFractor ./  Right click on  install-mfractor.command  and select  Open .  If prompted, confirm opening by selecting  Open  Wait for MFractor to install into Visual Studio for Mac.  After installing, Visual Studio for Mac will open and prompt you to activate.   Done!", 
            "title": "Install Using The Installer Script"
        }, 
        {
            "location": "/installation-and-setup/#install-using-mfractorinstaller-extension", 
            "text": "We can also install MFractor into Visual Studio Mac by using the MFractor.Installer helper extension.  This extension lives inside the Extension Manager in Visual Studio Mac, under  Gallery  -   IDE extensions .  Open up Visual Studio Mac and click on the  Visual Studio  menu and then  Extensions...   Once the Extension Manager opens, click  Gallery  and under  IDE extensions  locate  MFractor.Installer . If this isn't present, hit the  Refresh  button to update the Gallery listings.   Once you've located  MFractor.Installer , left-click on it to select it. In the right-hand detail view, click  Install . Visual Studio Mac will prompt you for confirmation, click  Install   You will then see a download dialog appear and MFractor will download and install.", 
            "title": "Install Using MFractor.Installer Extension"
        }, 
        {
            "location": "/installation-and-setup/#install-mfractor-manually", 
            "text": "MFractor can be installed directly through the Extension Manager's  Install from file  button.  Firstly, download the latest version of MFractor for Visual Studio Mac at  addins.mfractor.com/MFractor.mpack  Open up Visual Studio Mac and click on the  Visual Studio  menu and then  Extensions...   Within the Extension Manager, click the  Install from file  button in the bottom left of the Extension Manager.  Browse to  MFractor.mpack  and then select  Open :", 
            "title": "Install MFractor Manually"
        }, 
        {
            "location": "/installation-and-setup/#activating-mfractor-free", 
            "text": "MFractor comes in both a free and a paid version. The free version of MFractor  To use MFractor, you need to activate it using your email address; this will enable the free version of MFractor only. To  First things first,  close the Extension Manager . There is a known bug that blocks the email entry field from receiving keyboard when the Extension Manager is open  To activate MFractor, enter your email and then click  Activate .   Tada! You are now ready to rock.", 
            "title": "Activating MFractor Free"
        }, 
        {
            "location": "/installation-and-setup/#activating-mfractor-premium", 
            "text": "Download and locate your license file (which ends with the extension  .lic ). When purchasing MFractor Premium, this license file will be provided in an email. In this example, our license file is located on our desktop called  license.lic .   Open Visual Studio for Mac. If you have not activated MFractor with an email address, close the activation window.   In the main Visual Studio for Mac menu bar, select  Help , then  MFractor  and then finally  License Information . This will open the licensing window where you can import or remove an MFractor Premium license.  Next, click on the  Import License  button, browse to where our license is located ( license.lic ) and double click it to import the license into MFractor.   Voila, you now have a valid, active MFractor Premium installation.  It is safe to delete the license file from its original location. MFractor stores the license inside itself.   The licensing window will list:   Licensed To  - The full name of the person that the MFractor Premium license is issued to.  License Email:  - The email that this MFractor Premium license is issued against.  License Type and Expiry Date  - The type of license issued (Premium, Trial or Free) and when that license expires.", 
            "title": "Activating MFractor Premium"
        }, 
        {
            "location": "/installation-and-setup/#deactivating-your-premium-license", 
            "text": "If you'd like to remove a license from MFractor, you can open the MFractor license information window and click  Remove License .  IMPORTANT: This is a destructive operation, you cannot undo removing a license but you can re-import a new license.  After removing a license, you will be automatically downgraded to a free MFractor license. This allows usage of most features apart from C# code actions, mobile-specific C# code diagnostics, and configuration file support.  View the free vs paid feature map here .", 
            "title": "Deactivating Your Premium License"
        }, 
        {
            "location": "/installation-and-setup/#updating-mfractor", 
            "text": "When MFractor installs into Visual Studio Mac, it'll register itself into Visual Studio Macs extension updater.  This means that Visual Studio Mac will automatically prompt you that an update is available.  However, you can check for update at any time by opening the  Visual Studio Mac  main menu and selecting  Check for Updates...   Visual Studio Mac will check the MFractor extension server for updates and prompt you to update if there is a new version!", 
            "title": "Updating MFractor"
        }, 
        {
            "location": "/installation-and-setup/#uninstalling-mfractor", 
            "text": "You can uninstall MFractor through the Extension Manager at any time.  Select the  Visual Studio Mac  main menu and then  Addins  Under  Gallery  then  IDE extensions  select the MFractor extension list item and then click  Uninstall  You will be prompted to uninstall the extension, confirm uninstallation by clicking  Uninstall", 
            "title": "Uninstalling MFractor"
        }, 
        {
            "location": "/mfractor-premium/", 
            "text": "About MFractor Premium\n\n\nEverything you need to know about the free and paid version of MFractor for Visual Studio Mac\n\n\nFree VS Premium\n\n\nMFractor comes in both a free and a paid/premium version.\n\n\nThe free version contains most features that are included in MFractor Premium; as a Xamarin developer you will find the free version will still help out your day-to-day Xamarin.Android and Xamarin.Forms development a heck of a lot!\n\n\nIf you would like C# code refactoring support, mobile-specific code diagnostics or wish to tweak the code that MFractor creates then you will need to pay for a MFractor Premium license.\n\n\nFeature Map\n\n\n\n\n\n\n\n\nFeature\n\n\nIncluded In Free\n\n\nIncluded In Paid\n\n\n\n\n\n\n\n\n\n\nConfiguration Support\n\n\n\n\nXXX\n\n\n\n\n\n\nMFracor Code Annotations\n\n\n\n\nXXX\n\n\n\n\n\n\nXamarin.Forms Features\n\n\n\n\n\n\n\n\n\n\nXaml Analysis\n\n\nXXX\n\n\nXXX\n\n\n\n\n\n\nNavigation Tools\n\n\nXXX\n\n\nXXX\n\n\n\n\n\n\nXaml Refactoring\n\n\nXXX\n\n\nXXX\n\n\n\n\n\n\nXaml To C# Code Generation\n\n\nXXX\n\n\nXXX\n\n\n\n\n\n\nXamarin.Forms C# Code Diagnostics\n\n\n\n\nXXX\n\n\n\n\n\n\nXamarin.Android Features\n\n\nXXX\n\n\nXXX\n\n\n\n\n\n\nAndroid Resource IntelliSense\n\n\nXXX\n\n\nXXX\n\n\n\n\n\n\nAndroid Resource Navigation Suite\n\n\nXXX\n\n\nXXX\n\n\n\n\n\n\nAndroid C# Code Diagnostics\n\n\n\n\nXXX\n\n\n\n\n\n\nC# Features\n\n\n\n\n\n\n\n\n\n\nC# Code Actions\n\n\n\n\nXXX\n\n\n\n\n\n\n\n\nPurchase An MFractor Premium License\n\n\nRRP: $199aud\n\n\nMFractor Premium licenses are currently issued on a by-request basis. Until September 1st 2017, MFractor Premium is on sale at \n$149 AUD\n (25% discount).\n\n\nPremium licenses:\n\n\n\n\nAre issued against a single developer.\n\n\nCan be used on up to 3 separate machines for a single developer.\n\n\nExpired 366 days after being issued.\n\n\nInclude 1 year of maintenance for premium features.\n\n\nInclude priority for feature requests and bug fixes.\n\n\n\n\nTo enquire about purchasing an MFractor Premium license, please email \nmatthew.ch.robbins@gmail.com\n.\n\n\nRenewing A Premium License\n\n\nWhen your license is about to expire, you can purchase a new license by contacting me at \nmatthew.ch.robbins@gmail.com\n. I will issue a new license for 366 + the period until your current license expires.\n\n\nRefund Policy\n\n\nEach purchase of MFractor comes with a 30 day refund period; If you would like a refund, email \nmatthew.ch.robbins@gmail.com\n requesting a refund and the account details to transfer to. I will refund the full amount minus a $30AUD processing fee.\n\n\nTerms Of Use\n\n\n\n\nEach individual developer must have their own MFractor Premium license.\n\n\nAn individual developer can activate MFractor Premium on up-to 3 separate machines.\n\n\nMFractor Premium licenses expire after 366 days.\n\n\nIf an MFractor Premium license is not renewed, MFractor will automatically downgrade to the free license tier.", 
            "title": "About MFractor Premium"
        }, 
        {
            "location": "/mfractor-premium/#about-mfractor-premium", 
            "text": "Everything you need to know about the free and paid version of MFractor for Visual Studio Mac", 
            "title": "About MFractor Premium"
        }, 
        {
            "location": "/mfractor-premium/#free-vs-premium", 
            "text": "MFractor comes in both a free and a paid/premium version.  The free version contains most features that are included in MFractor Premium; as a Xamarin developer you will find the free version will still help out your day-to-day Xamarin.Android and Xamarin.Forms development a heck of a lot!  If you would like C# code refactoring support, mobile-specific code diagnostics or wish to tweak the code that MFractor creates then you will need to pay for a MFractor Premium license.", 
            "title": "Free VS Premium"
        }, 
        {
            "location": "/mfractor-premium/#feature-map", 
            "text": "Feature  Included In Free  Included In Paid      Configuration Support   XXX    MFracor Code Annotations   XXX    Xamarin.Forms Features      Xaml Analysis  XXX  XXX    Navigation Tools  XXX  XXX    Xaml Refactoring  XXX  XXX    Xaml To C# Code Generation  XXX  XXX    Xamarin.Forms C# Code Diagnostics   XXX    Xamarin.Android Features  XXX  XXX    Android Resource IntelliSense  XXX  XXX    Android Resource Navigation Suite  XXX  XXX    Android C# Code Diagnostics   XXX    C# Features      C# Code Actions   XXX", 
            "title": "Feature Map"
        }, 
        {
            "location": "/mfractor-premium/#purchase-an-mfractor-premium-license", 
            "text": "RRP: $199aud  MFractor Premium licenses are currently issued on a by-request basis. Until September 1st 2017, MFractor Premium is on sale at  $149 AUD  (25% discount).  Premium licenses:   Are issued against a single developer.  Can be used on up to 3 separate machines for a single developer.  Expired 366 days after being issued.  Include 1 year of maintenance for premium features.  Include priority for feature requests and bug fixes.   To enquire about purchasing an MFractor Premium license, please email  matthew.ch.robbins@gmail.com .", 
            "title": "Purchase An MFractor Premium License"
        }, 
        {
            "location": "/mfractor-premium/#renewing-a-premium-license", 
            "text": "When your license is about to expire, you can purchase a new license by contacting me at  matthew.ch.robbins@gmail.com . I will issue a new license for 366 + the period until your current license expires.", 
            "title": "Renewing A Premium License"
        }, 
        {
            "location": "/mfractor-premium/#refund-policy", 
            "text": "Each purchase of MFractor comes with a 30 day refund period; If you would like a refund, email  matthew.ch.robbins@gmail.com  requesting a refund and the account details to transfer to. I will refund the full amount minus a $30AUD processing fee.", 
            "title": "Refund Policy"
        }, 
        {
            "location": "/mfractor-premium/#terms-of-use", 
            "text": "Each individual developer must have their own MFractor Premium license.  An individual developer can activate MFractor Premium on up-to 3 separate machines.  MFractor Premium licenses expire after 366 days.  If an MFractor Premium license is not renewed, MFractor will automatically downgrade to the free license tier.", 
            "title": "Terms Of Use"
        }, 
        {
            "location": "/faq/", 
            "text": "Frequently Asked Questions\n\n\nAnswers to some commonly asked questions\n\n\nHow can I get help or support?\n\n\nIf something doesn't work or you'd like a sweet new feature added, be patient and contact me:\n\n\n\n\nVia Twitter: Give me a holla at \n@matthewrdev\n\n\nVia Slack: Drop in to chat anytime in the \n#mfractor Xamarin Slack sub-channel\n.\n\n\nVia Email: Shot an email to \nhello@mfractor.com\n\n\n\n\nWhat version of Visual Studio Mac is MFractor compatible with?\n\n\nThe latest version of MFractor always targets the current stable channel version of Visual Studio Mac.\n\n\nDoes MFractor support Visual Studio Windows?\n\n\nMFractor \ndoes not\n support Visual Studio Windows. This is on our roadmap for the future but we have no concrete timeline. A news announcement will be published when we commence work on MFractor for Visual Studio Windows.\n\n\nHow do I get started using MFractor?\n\n\nMFractor does a lot so it may take a little while to learn its ins and outs. If you'd like to learn how to best use it, you have a few options:\n\n\n\n\nRead the in-depth docs for both Xamarin.Forms and Xamarin.Android (see the menu to the left). Each article covers a feature in-depth and fully explains how to use it.\n\n\nDrop into the \n#mfractor Xamarin Slack sub-channel\n and start chatting to me (Matthew Robbins). I'm happy to answer any questions you have.\n\n\n\n\nHow do I file a bug report?\n\n\nIf you notice a bug while you are using MFractor, please file a bug report by taking the following steps:\n\n\n\n\nPrepare a short 2-3 sentence description of the bug, the steps you took that triggered it and the symptoms of the bug.\n\n\nCopy MFractors version information by opening the \nAbout\n dialog (\nHelp\n -\n \nMFractor\n -\n \nAbout\n) and click \nCopy Build Details Into Clipboard\n.\n\n\nEmail the description and build version to \nhello@mfractor.com\n.\n\n\n\n\nHow do I install or update the Android SDK meta-data bundle?\n\n\nIf you'd like to activate tooltips and go-to declaration support for Android SDK resources (for example: \n@android:string/my_string\n), you can install MFractors Android SDK meta-data.\n\n\nTo install, go to the \nHelp\n main menu, select \nMFractor\n and then \nInstall Android SDK Meta-Data\n:\n\n\n\n\nYou will be prompted to confirm the installation; installing the meta-data will wipe any existing installation!\n\n\n\n\nMFractor will then download and install the latest meta-data bundle:\n\n\n\n\nWhen the installation has completed, just close the installation success message; there is no need to restart Visual Studio Mac.\n\n\nWhat is the .droidres folder?\n\n\nThe \n.droidres\n folder contains the meta-data that's generated when MFractor indexes your Android projects. This meta-data is used to power resource tooltips and resource go-to declaration for Android projets.\n\n\nIt is safe to delete whenever you want however some features for Android development won't work correctly without it.\n\n\nShould I check .droidres into source control?\n\n\nNo, you should not check \n.droidres\n into your source control.\n\n\nIf you are using git, append the following text to the end of your \n.gitignore\n to exclude \n.droidres\n:\n\n\n# MFractor's Android meta-data cache\n*.droidres/", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#frequently-asked-questions", 
            "text": "Answers to some commonly asked questions", 
            "title": "Frequently Asked Questions"
        }, 
        {
            "location": "/faq/#how-can-i-get-help-or-support", 
            "text": "If something doesn't work or you'd like a sweet new feature added, be patient and contact me:   Via Twitter: Give me a holla at  @matthewrdev  Via Slack: Drop in to chat anytime in the  #mfractor Xamarin Slack sub-channel .  Via Email: Shot an email to  hello@mfractor.com", 
            "title": "How can I get help or support?"
        }, 
        {
            "location": "/faq/#what-version-of-visual-studio-mac-is-mfractor-compatible-with", 
            "text": "The latest version of MFractor always targets the current stable channel version of Visual Studio Mac.", 
            "title": "What version of Visual Studio Mac is MFractor compatible with?"
        }, 
        {
            "location": "/faq/#does-mfractor-support-visual-studio-windows", 
            "text": "MFractor  does not  support Visual Studio Windows. This is on our roadmap for the future but we have no concrete timeline. A news announcement will be published when we commence work on MFractor for Visual Studio Windows.", 
            "title": "Does MFractor support Visual Studio Windows?"
        }, 
        {
            "location": "/faq/#how-do-i-get-started-using-mfractor", 
            "text": "MFractor does a lot so it may take a little while to learn its ins and outs. If you'd like to learn how to best use it, you have a few options:   Read the in-depth docs for both Xamarin.Forms and Xamarin.Android (see the menu to the left). Each article covers a feature in-depth and fully explains how to use it.  Drop into the  #mfractor Xamarin Slack sub-channel  and start chatting to me (Matthew Robbins). I'm happy to answer any questions you have.", 
            "title": "How do I get started using MFractor?"
        }, 
        {
            "location": "/faq/#how-do-i-file-a-bug-report", 
            "text": "If you notice a bug while you are using MFractor, please file a bug report by taking the following steps:   Prepare a short 2-3 sentence description of the bug, the steps you took that triggered it and the symptoms of the bug.  Copy MFractors version information by opening the  About  dialog ( Help  -   MFractor  -   About ) and click  Copy Build Details Into Clipboard .  Email the description and build version to  hello@mfractor.com .", 
            "title": "How do I file a bug report?"
        }, 
        {
            "location": "/faq/#how-do-i-install-or-update-the-android-sdk-meta-data-bundle", 
            "text": "If you'd like to activate tooltips and go-to declaration support for Android SDK resources (for example:  @android:string/my_string ), you can install MFractors Android SDK meta-data.  To install, go to the  Help  main menu, select  MFractor  and then  Install Android SDK Meta-Data :   You will be prompted to confirm the installation; installing the meta-data will wipe any existing installation!   MFractor will then download and install the latest meta-data bundle:   When the installation has completed, just close the installation success message; there is no need to restart Visual Studio Mac.", 
            "title": "How do I install or update the Android SDK meta-data bundle?"
        }, 
        {
            "location": "/faq/#what-is-the-droidres-folder", 
            "text": "The  .droidres  folder contains the meta-data that's generated when MFractor indexes your Android projects. This meta-data is used to power resource tooltips and resource go-to declaration for Android projets.  It is safe to delete whenever you want however some features for Android development won't work correctly without it.", 
            "title": "What is the .droidres folder?"
        }, 
        {
            "location": "/faq/#should-i-check-droidres-into-source-control", 
            "text": "No, you should not check  .droidres  into your source control.  If you are using git, append the following text to the end of your  .gitignore  to exclude  .droidres :  # MFractor's Android meta-data cache\n*.droidres/", 
            "title": "Should I check .droidres into source control?"
        }, 
        {
            "location": "/configuration/", 
            "text": "Configuring MFractor\n\n\nPremium Only\n\n\nChanging the behavior of MFractor's code generation and code actions\n\n\nIntroduction\n\n\nThe configuration engine allows customization of MFractor to generate code specific to your project. Initially, the amount of options that are exposed will be limited but over time I will drastically increase the flexibility of MFractors code generation engine.\n\n\nIf you wish to have a piece of code generation customizable, please submit a feature request at \nMFractor Feedback\n.\n\n\nConfiguration Basics\n\n\nConceptually, MFractor has \nConfigurables\n, extensible features that expose properties that can be edited by a configuration file. \nConfigurables\n can be C# code actions, XML analysers, XAML code generators and much more.\n\n\nWhen browsing this website, you may notice that parts of the site are tagged as \nAutogenerated\n. Several parts of this documentation site are autogenerated from the configurable features inside MFractor, grouping them by behaviour and categories.\n\n\nLet's look at the 3 main configurable feature types:\n\n\nC ode Actions\n\n\nCode actions are features exposed through the IDE context menu (accessed via \nRight CLick\n or \nAlt+Return\n) that fix code issues and organise, refactor and generate source code.\n\n\nCode Analysis\n\n\nCode analysis features are linters that inspect for problems in your source code. Typically, code analysers are \nnot\n configurable.\n\n\nCode Generation\n\n\nCode generators create source code (such as C# or XAML); they isolate the creation of a common piece of code into a single, reusable unit.\n\n\nCode generators are only ever directly used by code actions; they are not exposed through the IDE.\n\n\nConfiguration Files\n\n\nMFractor configuration files are XML based and end with the extension \n.mfc.xml\n; a configuration file can be named anything and be placed in any directory if a project as long as it ends in the extension \n.mfc.xml\n.\n\n\nHow does it work? Let's consider the following configuration file:\n\n\nconfig.mfc.xml\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n ?\n\n\nmfractor\n\n        \n!-- Change the behaviour of the Implement View Model code action --\n\n    \nconfigure id=\ncom.mfractor.code_action.forms.implement_view_model\n\n            \nproperty name=\nBaseClass\n value=\nMyNamespace.ViewModels.ViewModelBase\n/\n\n    \n/configure\n\n\n/mfractor\n\n\n\n\n\nLet's examine each of the each element in the above configuration in depth:\n\n\n\n\nWe open a configuration file with the \nmfractor\n tag; this is ceremony to denote to MFractor this is a config file.\n\n\nWe \ntarget\n a configurable by using the \nconfigure\n element:\n\n\nThe \nid\n attribute specifies the unique identifier of the configurable we wish to modify. An id could refer a code action, a code generator or an analysis routine.\n\n\n\n\n\n\nWe \nmodify\n a property using the \nproperty\n element:\n\n\nThe \nname\n attribute specifies the configurable property we wish to edit.\n\n\nThe \nvalue\n attribute specifies the value we wish to set the property to.\n\n\nWe \ngroup\n configurations within the \ncollection name=\"CollectionName\"\n element. These groups are hard coded into the product itself and relate to how the code actions, code generation and code analysis documentation folders are structured in this site.\n\n\n\n\n\n\n\n\nConfiguration Identifiers\n\n\nEvery element inside MFractor that can be configured has it's own unique \nconfiguration identifier\n. This a java-style, package based string that indicates the software, element type and element name inside the name.\n\n\nFor example, the Xamarin.Forms \nImplement View Model\n code action has the configuration identifier \ncom.mfractor.code_actions.forms.implement_view_model\n. A features id is located below the heading inside the documentation:\n\n\n\n\nIf we wanted to change the behaviour of the \nImplement View Model\n code action, we add a \nconfigure\n element into our \n.mfc.xml\n and target the identifier \ncom.mfractor.code_action.forms.implement_view_model\n:\n\n\nconfigure id=\ncom.mfractor.code_action.forms.implement_view_model\n\n\n/configure\n\n\n\n\n\nInside the \nconfigure\n element we can now specify multiple \nproperty\n tags to change properties inside the configurable.\n\n\nConfigurable Properties\n\n\nAfter targeting a configurable, we can use \nConfigurable Properties\n to change the behaviour of that feature.\n\n\nConfigurable properties are settings that can be edited on a configurable through the use of the \nproperty\n tag.\n\n\nWe place a \nproperty\n tag inside a \nconfigure\n tag; we can then target the property name using the \nname\n attribute and apply a new value using the \nvalue\n attribute.\n\n\nFor example, we can change the output folder for new ViewModels by using a \nproperty\n setter on the \nViewModelsFolder\n property:\n\n\nconfigure id=\ncom.mfractor.code_action.forms.implement_view_model\n\n    \nproperty name=\nViewModelsFolder\n value=\nPath/To/ViewModelsFolder\n/\n\n\n/configure\n\n\n\n\n\nCode Generation Dependencies\n\n\nOften multiple code actions need to generate the same source; rather than configuring each code action separately each code action reuses a common \ncode generator\n. A code generator is a configurable that encapsulates the logic needed to generate a specific piece of code.\n\n\nFor example, both the \nImplement View Model\n and \nGenerate Missing Command\n use the \nGenerate ICommand Implementation\n code generator; this allows us to set the ICommand type once and have the behaviour propagate through all code-actions that need to generate an ICommand implementation.\n\n\nThis documentation site lists the code-generaton dependencies", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#configuring-mfractor", 
            "text": "Premium Only  Changing the behavior of MFractor's code generation and code actions", 
            "title": "Configuring MFractor"
        }, 
        {
            "location": "/configuration/#introduction", 
            "text": "The configuration engine allows customization of MFractor to generate code specific to your project. Initially, the amount of options that are exposed will be limited but over time I will drastically increase the flexibility of MFractors code generation engine.  If you wish to have a piece of code generation customizable, please submit a feature request at  MFractor Feedback .", 
            "title": "Introduction"
        }, 
        {
            "location": "/configuration/#configuration-basics", 
            "text": "Conceptually, MFractor has  Configurables , extensible features that expose properties that can be edited by a configuration file.  Configurables  can be C# code actions, XML analysers, XAML code generators and much more.  When browsing this website, you may notice that parts of the site are tagged as  Autogenerated . Several parts of this documentation site are autogenerated from the configurable features inside MFractor, grouping them by behaviour and categories.  Let's look at the 3 main configurable feature types:", 
            "title": "Configuration Basics"
        }, 
        {
            "location": "/configuration/#c-ode-actions", 
            "text": "Code actions are features exposed through the IDE context menu (accessed via  Right CLick  or  Alt+Return ) that fix code issues and organise, refactor and generate source code.", 
            "title": "C ode Actions"
        }, 
        {
            "location": "/configuration/#code-analysis", 
            "text": "Code analysis features are linters that inspect for problems in your source code. Typically, code analysers are  not  configurable.", 
            "title": "Code Analysis"
        }, 
        {
            "location": "/configuration/#code-generation", 
            "text": "Code generators create source code (such as C# or XAML); they isolate the creation of a common piece of code into a single, reusable unit.  Code generators are only ever directly used by code actions; they are not exposed through the IDE.", 
            "title": "Code Generation"
        }, 
        {
            "location": "/configuration/#configuration-files", 
            "text": "MFractor configuration files are XML based and end with the extension  .mfc.xml ; a configuration file can be named anything and be placed in any directory if a project as long as it ends in the extension  .mfc.xml .  How does it work? Let's consider the following configuration file:  config.mfc.xml  ?xml version= 1.0  encoding= UTF-8  ?  mfractor \n         !-- Change the behaviour of the Implement View Model code action -- \n     configure id= com.mfractor.code_action.forms.implement_view_model \n             property name= BaseClass  value= MyNamespace.ViewModels.ViewModelBase / \n     /configure  /mfractor   Let's examine each of the each element in the above configuration in depth:   We open a configuration file with the  mfractor  tag; this is ceremony to denote to MFractor this is a config file.  We  target  a configurable by using the  configure  element:  The  id  attribute specifies the unique identifier of the configurable we wish to modify. An id could refer a code action, a code generator or an analysis routine.    We  modify  a property using the  property  element:  The  name  attribute specifies the configurable property we wish to edit.  The  value  attribute specifies the value we wish to set the property to.  We  group  configurations within the  collection name=\"CollectionName\"  element. These groups are hard coded into the product itself and relate to how the code actions, code generation and code analysis documentation folders are structured in this site.", 
            "title": "Configuration Files"
        }, 
        {
            "location": "/configuration/#configuration-identifiers", 
            "text": "Every element inside MFractor that can be configured has it's own unique  configuration identifier . This a java-style, package based string that indicates the software, element type and element name inside the name.  For example, the Xamarin.Forms  Implement View Model  code action has the configuration identifier  com.mfractor.code_actions.forms.implement_view_model . A features id is located below the heading inside the documentation:   If we wanted to change the behaviour of the  Implement View Model  code action, we add a  configure  element into our  .mfc.xml  and target the identifier  com.mfractor.code_action.forms.implement_view_model :  configure id= com.mfractor.code_action.forms.implement_view_model  /configure   Inside the  configure  element we can now specify multiple  property  tags to change properties inside the configurable.", 
            "title": "Configuration Identifiers"
        }, 
        {
            "location": "/configuration/#configurable-properties", 
            "text": "After targeting a configurable, we can use  Configurable Properties  to change the behaviour of that feature.  Configurable properties are settings that can be edited on a configurable through the use of the  property  tag.  We place a  property  tag inside a  configure  tag; we can then target the property name using the  name  attribute and apply a new value using the  value  attribute.  For example, we can change the output folder for new ViewModels by using a  property  setter on the  ViewModelsFolder  property:  configure id= com.mfractor.code_action.forms.implement_view_model \n     property name= ViewModelsFolder  value= Path/To/ViewModelsFolder /  /configure", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/#code-generation-dependencies", 
            "text": "Often multiple code actions need to generate the same source; rather than configuring each code action separately each code action reuses a common  code generator . A code generator is a configurable that encapsulates the logic needed to generate a specific piece of code.  For example, both the  Implement View Model  and  Generate Missing Command  use the  Generate ICommand Implementation  code generator; this allows us to set the ICommand type once and have the behaviour propagate through all code-actions that need to generate an ICommand implementation.  This documentation site lists the code-generaton dependencies", 
            "title": "Code Generation Dependencies"
        }, 
        {
            "location": "/code-actions/", 
            "text": "Code Actions\n\n\nHow to use MFractors code fixes, actions and refactorings\n\n\nThe Essentials\n\n\nMFractor includes a suite of code actions to organise, refactor and generate source code.\n\n\nTo use MFractors code actions:\n\n\n\n\nPress \nAlt + Return\n within a C#, XAML or Android Resource document.\n\n\nRight click and select \nQuick Fix\n in a C# document.\n\n\n\n\n\n\nC# Code Actions\n\n\nMFractors C# code action suite integrates directly into Visual Studio Macs existing code action suite; you can simply press \nAlt+Return\n to view available code actions and then \nReturn\n to apply a code action.\n\n\nYou can view the full list of MFractors C# code actions here\n\n\nXAML Code Actions\n\n\nXAML code actions can be actioned when the current open is a Xamarin.Forms XAML document.\n\n\nIn addition to being accessible through the quick fix menu, XAML code actions can be action  \n\n\nThe XAML code actions come in 4 types:\n\n\n\n\nFix\n: Fixes code issues. This menu is only available when actioned over a code issue (yellow or red squiggle).\n\n\nOrganise\n: Organises XAML code. For example, sorting attributes or formatting a document.\n\n\nRefactor\n: Refactors XAML code: For example, renaming XAML namespaces or extracting property values into a view model.\n\n\nGenerate\n: Generates C# or XAML code. For example, implementing view models or creating resource dictionaries.\n\n\n\n\nAndroid Resource Code Actions\n\n\nAndroid code actions can be actioned when the current open is an Android resource; for example a menu, values or xml configuration file.\n\n\nDisclaimer: Support for Android resource code actions is currently very limited. This feature-set will be added to over time.", 
            "title": "Code Actions"
        }, 
        {
            "location": "/code-actions/#code-actions", 
            "text": "How to use MFractors code fixes, actions and refactorings", 
            "title": "Code Actions"
        }, 
        {
            "location": "/code-actions/#the-essentials", 
            "text": "MFractor includes a suite of code actions to organise, refactor and generate source code.  To use MFractors code actions:   Press  Alt + Return  within a C#, XAML or Android Resource document.  Right click and select  Quick Fix  in a C# document.", 
            "title": "The Essentials"
        }, 
        {
            "location": "/code-actions/#c-code-actions", 
            "text": "MFractors C# code action suite integrates directly into Visual Studio Macs existing code action suite; you can simply press  Alt+Return  to view available code actions and then  Return  to apply a code action.  You can view the full list of MFractors C# code actions here", 
            "title": "C# Code Actions"
        }, 
        {
            "location": "/code-actions/#xaml-code-actions", 
            "text": "XAML code actions can be actioned when the current open is a Xamarin.Forms XAML document.  In addition to being accessible through the quick fix menu, XAML code actions can be action    The XAML code actions come in 4 types:   Fix : Fixes code issues. This menu is only available when actioned over a code issue (yellow or red squiggle).  Organise : Organises XAML code. For example, sorting attributes or formatting a document.  Refactor : Refactors XAML code: For example, renaming XAML namespaces or extracting property values into a view model.  Generate : Generates C# or XAML code. For example, implementing view models or creating resource dictionaries.", 
            "title": "XAML Code Actions"
        }, 
        {
            "location": "/code-actions/#android-resource-code-actions", 
            "text": "Android code actions can be actioned when the current open is an Android resource; for example a menu, values or xml configuration file.  Disclaimer: Support for Android resource code actions is currently very limited. This feature-set will be added to over time.", 
            "title": "Android Resource Code Actions"
        }, 
        {
            "location": "/annotations/", 
            "text": "Using MFractor.Annotations\n\n\nPremium Only\n\n\nUsing the MFractor.Annotations library to power mobile-specific C# code diagnostics\n\n\nIntroduction\n\n\nThe MFractor.Annotations library is a Nuget package that powers a suite of mobile-specific code diagnostics. When this library is installed and used in a .NET project, developers can annotate their code with MFractor attributes to activate features like\n\n\nWhile the Nuget library can be installed into any project, MFractor's mobile-specific code diagnostics are only available in MFractor Premium.\n\n\nInstalling MFractor.Annotations NuGet\n\n\nTargeting A Layout In Xamarin.Android", 
            "title": "Using MFractor.Annotations"
        }, 
        {
            "location": "/annotations/#using-mfractorannotations", 
            "text": "Premium Only  Using the MFractor.Annotations library to power mobile-specific C# code diagnostics", 
            "title": "Using MFractor.Annotations"
        }, 
        {
            "location": "/annotations/#introduction", 
            "text": "The MFractor.Annotations library is a Nuget package that powers a suite of mobile-specific code diagnostics. When this library is installed and used in a .NET project, developers can annotate their code with MFractor attributes to activate features like  While the Nuget library can be installed into any project, MFractor's mobile-specific code diagnostics are only available in MFractor Premium.", 
            "title": "Introduction"
        }, 
        {
            "location": "/annotations/#installing-mfractorannotations-nuget", 
            "text": "", 
            "title": "Installing MFractor.Annotations NuGet"
        }, 
        {
            "location": "/annotations/#targeting-a-layout-in-xamarinandroid", 
            "text": "", 
            "title": "Targeting A Layout In Xamarin.Android"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/", 
            "text": "Configuring A Binding Context\n\n\nPower the refactoring engine and xaml analyser by targeting a binding context\n\n\nIntroduction\n\n\nIn Mvvm architected applications, views use a \nBinding Context\n to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through \ndata binding\n; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts \nThe Mvvm Pattern\n article.\n\n\nWhen working with Xaml, we can specify a binding context to activate binding expression analysis and a variety of BindingContext specific refactorings.\n\n\nWe can specify a binding context \nexplicitly\n via in inline Xaml expression or \nimplicitly\n through the use of common MVVM naming conventions.\n\n\nImplicit Binding Context Resolution\n\n\nMFractor will attempt to infer the relationship between your view models and xaml views via \nimplicit binding context resolution\n. This is done by looking for classes and Xaml views that share a common naming convention.\n\n\nLet's consider the following files:\n\n\n\n\nLoginPage.xaml\n - The xaml view.\n\n\nLoginPage.xaml.cs\n - The code behind for the xaml view.\n\n\nLoginViewModel\n - The a C# class that is the view model for the LoginPage view.\n\n\n\n\n\n\nBecause these pages share the prefix \nLogin\n and each has a distinct file extension or suffix, MFractor assumes the following relationships:\n\n\n\n\nThe \n.xaml\n extension denotes that \nLoginPage.xaml\n is a xaml view.\n\n\nThe \n.xaml.cs\n extension and the \nLoginPage\n component denotes that \nLoginPage.xaml.cs\n is the code behind implementation \nLoginPage\n view.\n\n\nThe \nViewModel\n suffix implies that \nLoginViewModel\n is a view model. When \nViewModel\n is removed from \nLoginViewModel\n and \nPage\n is removed from \nLoginPage\n, the \nLogin\n component implies that the \nLoginViewModel\n is related to the \nLoginPage\n xaml view and it's code behind file.\n\n\n\n\nMFractor uses these common naming conventions of Page.xaml, Page.xaml.cs and ViewModel to decide that \nLoginViewModel\n will probably be the BindingContext for \nLoginPage\n. The \nPage\n \n-\n \nViewModel\n naming convention is used by several popular MVVM frameworks such as Prism and FreshMVVM.\n\n\nThe following suffixes are supported for Xaml views:\n\n\n\n\nPage\n: EG LoginPage.xaml \n-\n LoginViewModel\n\n\nView\n: EG LoginView.xaml \n-\n LoginViewModel\n\n\n\n\nExplicit Binding Context Resolution\n\n\nIn Xamarin.Forms, all views have the property \nBindingContext\n; this specifies the object that a view should data-bind with. When coding with Xaml, we can use the \nx:Static\n markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context:\n\n\n \nEntry BindingContext=\n{x:Static local:MyStaticClass.MyStaticProperty}\n/\n\n\n\n\n\nThis is known as the \nView Model Locator Pattern\n. We implement a static class named \nViewModelLocator\n and use a static, readonly property to return an instance of the object we want our Xaml view to data-bind with. Historically the \nView Model Locator Pattern\n has been used to provide design time data to the Xamarin.Forms Xaml previewer. For a deeper insight into this pattern, read James Montemagnos excellent \nView Model Locator\n article.\n\n\nFor example, given a Xaml page named \nLoginPage\n, we can explicitly provide an instance of \nLoginViewModel\n as the binding context like so:\n\n\nViewModelLocator.cs\n\n\npublic namespace MyApp\n{\n  public static class ViewModelLocator\n  {\n      public static readonly LoginViewModel LoginViewModel = new LoginViewModel();\n  }\n}\n\n\n\n\nLoginPage.xaml\n\n\nContentPage\n  xmlns:local=\nclr-namespace:MyApp;assembly=MyApp\n\n  BindingContext=\n{x:Static local:ViewModelLocator.LoginViewModel}\n/\n\n\n\n\n\nWhen MFractor begins analysis on LoginPage.xaml it will check if any \nBindingContext\n properties have been assigned to. As the root \nContentPage\n assigns a binding context, it will inspect the value component of the \nBindingContext\n attribute, check if it is a Xaml expression and then evaluate it for the return type.\n\n\nFor the \n{x:Static local:ViewModelLocator.LoginViewModel}\n expression, MFractor will resolve the \nViewModelLocator\n class in the \nlocal\n namespace and then grab the C# type of the \nLoginViewModel\n property. This informs MFractor that the page will be bound to a \nLoginViewModel\n instance and therefore to analyse all \nBinding\n expressions against the \nLoginViewModel\n type.\n\n\nExplicit binding context resolution will also work when referencing another element using \nx:Reference\n expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so:\n\n\n  \nSwitch x:Name=\nmySwitch\n /\n\n  \nLabel BindingContext=\n{x:Reference mySwitch}\n IsVisible=\n{Binding IsToggled}\n/\n\n\n\n\n\nWhen MFractor analyses the \n{Binding IsToggled}\n expression, it will evaluate the \n{x:Reference mySwitch}\n expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch).\n\n\nExplicit binding context resolution will \nalways\n override implicit binding context resolution. If your xaml views are named using the conventions listed above but your page or a view explicitly assigns the \nBindingContext\n property then MFractor will use the \nBindingContext\n return type instead of the implicit Mvvm relationship.\n\n\nData Template Binding Context Resolution\n\n\nData templates are used to provide a nested Xaml view to a view that displays many occurances of that view. For example, a ListView uses a \nDataTemplate\n to specify the view appearance of each instance provided through the \nItemsSource\n property.\n\n\nMFractor will attempt to infer the BindingContext for a data templates view by resolving the \nItemsSource\n property on the wrapping view.\n\n\nConsider the following code:\n\n\n  \nListView ItemsSource=\n{Binding Contacts}\n\n      \nListView.ItemTemplate\n\n        \nDataTemplate\n\n          \nTextCell Text=\n{Binding DisplayName}\n /\n\n        \n/DataTemplate\n\n      \n/ListView.ItemTemplate\n\n  \n/ListView\n\n\n\n\n\nThe inner \nDataTemplate\n has a \nTextCell\n where the \nText\n property is provided by the binding expression \n{Binding DisplayName}\n. To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the \nItemsSource\n property and evaluate the expression.\n\n\nWhen the return type is an \nIEnumerable\n or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.\n\n\nSummary\n\n\nIn summary, we've learnt that MFractor will use the binding context to power the Xaml analyser and navigation improvements.\n\n\n\n\nBinding expressions require a binding context to be analysed.\n\n\nWe can explicitly specify a binding context by assigning the \nBindingContext\n property of any Xaml element.\n\n\nWhen we name our code files using the Page.xaml, Page.xaml.cs and ViewModel convention, MFractor will assume an implicit MVVM relationship.\n\n\nData templates use the return type of the wrapping views \nItemSource\n property.", 
            "title": "Configuring A Binding Context"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#configuring-a-binding-context", 
            "text": "Power the refactoring engine and xaml analyser by targeting a binding context", 
            "title": "Configuring A Binding Context"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#introduction", 
            "text": "In Mvvm architected applications, views use a  Binding Context  to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through  data binding ; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts  The Mvvm Pattern  article.  When working with Xaml, we can specify a binding context to activate binding expression analysis and a variety of BindingContext specific refactorings.  We can specify a binding context  explicitly  via in inline Xaml expression or  implicitly  through the use of common MVVM naming conventions.", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#implicit-binding-context-resolution", 
            "text": "MFractor will attempt to infer the relationship between your view models and xaml views via  implicit binding context resolution . This is done by looking for classes and Xaml views that share a common naming convention.  Let's consider the following files:   LoginPage.xaml  - The xaml view.  LoginPage.xaml.cs  - The code behind for the xaml view.  LoginViewModel  - The a C# class that is the view model for the LoginPage view.    Because these pages share the prefix  Login  and each has a distinct file extension or suffix, MFractor assumes the following relationships:   The  .xaml  extension denotes that  LoginPage.xaml  is a xaml view.  The  .xaml.cs  extension and the  LoginPage  component denotes that  LoginPage.xaml.cs  is the code behind implementation  LoginPage  view.  The  ViewModel  suffix implies that  LoginViewModel  is a view model. When  ViewModel  is removed from  LoginViewModel  and  Page  is removed from  LoginPage , the  Login  component implies that the  LoginViewModel  is related to the  LoginPage  xaml view and it's code behind file.   MFractor uses these common naming conventions of Page.xaml, Page.xaml.cs and ViewModel to decide that  LoginViewModel  will probably be the BindingContext for  LoginPage . The  Page   -   ViewModel  naming convention is used by several popular MVVM frameworks such as Prism and FreshMVVM.  The following suffixes are supported for Xaml views:   Page : EG LoginPage.xaml  -  LoginViewModel  View : EG LoginView.xaml  -  LoginViewModel", 
            "title": "Implicit Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#explicit-binding-context-resolution", 
            "text": "In Xamarin.Forms, all views have the property  BindingContext ; this specifies the object that a view should data-bind with. When coding with Xaml, we can use the  x:Static  markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context:    Entry BindingContext= {x:Static local:MyStaticClass.MyStaticProperty} /   This is known as the  View Model Locator Pattern . We implement a static class named  ViewModelLocator  and use a static, readonly property to return an instance of the object we want our Xaml view to data-bind with. Historically the  View Model Locator Pattern  has been used to provide design time data to the Xamarin.Forms Xaml previewer. For a deeper insight into this pattern, read James Montemagnos excellent  View Model Locator  article.  For example, given a Xaml page named  LoginPage , we can explicitly provide an instance of  LoginViewModel  as the binding context like so:  ViewModelLocator.cs  public namespace MyApp\n{\n  public static class ViewModelLocator\n  {\n      public static readonly LoginViewModel LoginViewModel = new LoginViewModel();\n  }\n}  LoginPage.xaml  ContentPage\n  xmlns:local= clr-namespace:MyApp;assembly=MyApp \n  BindingContext= {x:Static local:ViewModelLocator.LoginViewModel} /   When MFractor begins analysis on LoginPage.xaml it will check if any  BindingContext  properties have been assigned to. As the root  ContentPage  assigns a binding context, it will inspect the value component of the  BindingContext  attribute, check if it is a Xaml expression and then evaluate it for the return type.  For the  {x:Static local:ViewModelLocator.LoginViewModel}  expression, MFractor will resolve the  ViewModelLocator  class in the  local  namespace and then grab the C# type of the  LoginViewModel  property. This informs MFractor that the page will be bound to a  LoginViewModel  instance and therefore to analyse all  Binding  expressions against the  LoginViewModel  type.  Explicit binding context resolution will also work when referencing another element using  x:Reference  expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so:     Switch x:Name= mySwitch  / \n   Label BindingContext= {x:Reference mySwitch}  IsVisible= {Binding IsToggled} /   When MFractor analyses the  {Binding IsToggled}  expression, it will evaluate the  {x:Reference mySwitch}  expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch).  Explicit binding context resolution will  always  override implicit binding context resolution. If your xaml views are named using the conventions listed above but your page or a view explicitly assigns the  BindingContext  property then MFractor will use the  BindingContext  return type instead of the implicit Mvvm relationship.", 
            "title": "Explicit Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#data-template-binding-context-resolution", 
            "text": "Data templates are used to provide a nested Xaml view to a view that displays many occurances of that view. For example, a ListView uses a  DataTemplate  to specify the view appearance of each instance provided through the  ItemsSource  property.  MFractor will attempt to infer the BindingContext for a data templates view by resolving the  ItemsSource  property on the wrapping view.  Consider the following code:     ListView ItemsSource= {Binding Contacts} \n       ListView.ItemTemplate \n         DataTemplate \n           TextCell Text= {Binding DisplayName}  / \n         /DataTemplate \n       /ListView.ItemTemplate \n   /ListView   The inner  DataTemplate  has a  TextCell  where the  Text  property is provided by the binding expression  {Binding DisplayName} . To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the  ItemsSource  property and evaluate the expression.  When the return type is an  IEnumerable  or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.", 
            "title": "Data Template Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#summary", 
            "text": "In summary, we've learnt that MFractor will use the binding context to power the Xaml analyser and navigation improvements.   Binding expressions require a binding context to be analysed.  We can explicitly specify a binding context by assigning the  BindingContext  property of any Xaml element.  When we name our code files using the Page.xaml, Page.xaml.cs and ViewModel convention, MFractor will assume an implicit MVVM relationship.  Data templates use the return type of the wrapping views  ItemSource  property.", 
            "title": "Summary"
        }, 
        {
            "location": "/xamarin-forms/navigation/", 
            "text": "Navigation\n\n\nMove efficiently through a Xamarin.Forms project with rich Xaml code navigation\n\n\nMvvm Navigation\n\n\nWhen MFractor can \nimplicitly resolve the View - Code Behind Class - ViewModel relationship\n, the Mvvm navigation shortcut suite is activated.\n\n\nWe can access these shortcuts by right clicking in a \n.xaml\n, \n.xaml.cs\n or \nViewModel.cs\n code file:\n\n\n\n\nGo To View Model: Jumps you to the view model related to a view or code behind class.\n\n\nShortcut: \nAlt + Left Shift + 1\n\n\n\n\n\n\nGo To Code-Behind Class: Jumps you to the code behind class related to a view or view model.\n\n\nShortcut: \nAlt + Left Shift + 2\n\n\n\n\n\n\nGo To Xaml View: Jumps you to the xaml view related to a view model or code behind class.\n\n\nShortcut: \nAlt + Left Shift + 3\n\n\n\n\n\n\n\n\nFor example:\n\n\n\n\nXaml Go-To Symbol\n\n\nJust like C#, we can jump to the declaration of a symbol when in our Xaml.\n\n\nTo perform this, click onto a Xaml element (such as a node, attribute or expression) and press \nCommand + D\n.\n\n\nWe can also right click on any Xaml element and select the \nGo-To Xaml Symbol\n shortcut:\n\n\n\n\nXaml Tooltips\n\n\nWhen in a .xaml file, we can hover over any Xaml element to view a .NET style tooltip:\n\n\n\n\nWe can also hover over markup extension expressions to view the evaluation result:\n\n\n\n\nMFractor also supports the following additional types of tooltips.\n\n\nBinding Context Tooltips\n\n\nIf you hover over a \nBinding\n markup extension expression that can be evaluated, MFractor will render the full .NET type of the binding context into the tooltip:\n\n\n\n\nThis is useful for understanding the behaviour of your View at runtime.\n\n\nValue Conversion Tooltips\n\n\nWhen you have annotated implementations of \nIValueConverter\n with the value conversion attribute, MFractor supports rendering of input, output and parameter type into the tooltip window.\n\n\nWhen you hover over a Xaml element or markup extension expression that evaluates to a \nIValueConverter\n, MFractor will render out the input and output types when available:\n\n\n\n\nColor Tooltips\n\n\nWhen MFractor encounters a Xaml attribute that uses the \nXamarin.Forms.Color\n or \nSystem.Drawing.Color\n type, it will attempt to evaluate the color hex or color literal.\n\n\nIf successfully evaluated, it will render the color value into the resulting tooltip:\n\n\n\n\nImage Tooltips\n\n\nMFractor supports inline image tooltips; these tooltips will display a preview of the image that you are referencing from within your Xaml:\n\n\nImage tooltips are activated when you hover over the value of a Xaml attribute whose type is \nXamarin.Forms.ImageSource\n; when MFractor encounters a value that looks like an image reference to a bundled resource (IE: \nlogo.png\n), it attempts to locate that image within any iOS or Android projects that reference the assembly.\n\n\nMFractor searches the \nResources\n folder within linked iOS projects and the \nResources/drawable*\n and \nResources/mipmap*\n folders on Android.\n\n\nWhen MFractor finds an image that matches that image name, it will render it into the image into the tooltip window:", 
            "title": "Navigation Tools"
        }, 
        {
            "location": "/xamarin-forms/navigation/#navigation", 
            "text": "Move efficiently through a Xamarin.Forms project with rich Xaml code navigation", 
            "title": "Navigation"
        }, 
        {
            "location": "/xamarin-forms/navigation/#mvvm-navigation", 
            "text": "When MFractor can  implicitly resolve the View - Code Behind Class - ViewModel relationship , the Mvvm navigation shortcut suite is activated.  We can access these shortcuts by right clicking in a  .xaml ,  .xaml.cs  or  ViewModel.cs  code file:   Go To View Model: Jumps you to the view model related to a view or code behind class.  Shortcut:  Alt + Left Shift + 1    Go To Code-Behind Class: Jumps you to the code behind class related to a view or view model.  Shortcut:  Alt + Left Shift + 2    Go To Xaml View: Jumps you to the xaml view related to a view model or code behind class.  Shortcut:  Alt + Left Shift + 3     For example:", 
            "title": "Mvvm Navigation"
        }, 
        {
            "location": "/xamarin-forms/navigation/#xaml-go-to-symbol", 
            "text": "Just like C#, we can jump to the declaration of a symbol when in our Xaml.  To perform this, click onto a Xaml element (such as a node, attribute or expression) and press  Command + D .  We can also right click on any Xaml element and select the  Go-To Xaml Symbol  shortcut:", 
            "title": "Xaml Go-To Symbol"
        }, 
        {
            "location": "/xamarin-forms/navigation/#xaml-tooltips", 
            "text": "When in a .xaml file, we can hover over any Xaml element to view a .NET style tooltip:   We can also hover over markup extension expressions to view the evaluation result:   MFractor also supports the following additional types of tooltips.", 
            "title": "Xaml Tooltips"
        }, 
        {
            "location": "/xamarin-forms/navigation/#binding-context-tooltips", 
            "text": "If you hover over a  Binding  markup extension expression that can be evaluated, MFractor will render the full .NET type of the binding context into the tooltip:   This is useful for understanding the behaviour of your View at runtime.", 
            "title": "Binding Context Tooltips"
        }, 
        {
            "location": "/xamarin-forms/navigation/#value-conversion-tooltips", 
            "text": "When you have annotated implementations of  IValueConverter  with the value conversion attribute, MFractor supports rendering of input, output and parameter type into the tooltip window.  When you hover over a Xaml element or markup extension expression that evaluates to a  IValueConverter , MFractor will render out the input and output types when available:", 
            "title": "Value Conversion Tooltips"
        }, 
        {
            "location": "/xamarin-forms/navigation/#color-tooltips", 
            "text": "When MFractor encounters a Xaml attribute that uses the  Xamarin.Forms.Color  or  System.Drawing.Color  type, it will attempt to evaluate the color hex or color literal.  If successfully evaluated, it will render the color value into the resulting tooltip:", 
            "title": "Color Tooltips"
        }, 
        {
            "location": "/xamarin-forms/navigation/#image-tooltips", 
            "text": "MFractor supports inline image tooltips; these tooltips will display a preview of the image that you are referencing from within your Xaml:  Image tooltips are activated when you hover over the value of a Xaml attribute whose type is  Xamarin.Forms.ImageSource ; when MFractor encounters a value that looks like an image reference to a bundled resource (IE:  logo.png ), it attempts to locate that image within any iOS or Android projects that reference the assembly.  MFractor searches the  Resources  folder within linked iOS projects and the  Resources/drawable*  and  Resources/mipmap*  folders on Android.  When MFractor finds an image that matches that image name, it will render it into the image into the tooltip window:", 
            "title": "Image Tooltips"
        }, 
        {
            "location": "/xamarin-forms/analysis/", 
            "text": "WORK IN PROGRESS\n\n\nXaml Analysis\n\n\nUse the Xaml analyser to spend less time debugging and see Xaml errors in-editor\n\n\nIntroduction\n\n\nIt's common that xaml issues in Xamarin.Forms applications are undetected until runtime or worse, when sent out to a client. MFractor solves this by detecting Xaml issues \nimmediately\n and then marking them inside the xaml editor with a concise error message.\n\n\nBye bye Xaml bugs! \ud83d\udc4b\n\n\nUnder The Hood\n\n\nLet's take a look at what happens \"under the hood\" in MFractor when you open a Xaml document:\n\n\n\n\nWhen you open a Xaml file that's part of a .NET project, Visual Studio Mac notifies MFractor that a new Xaml document was opened for editing. MFractor will  inject the Xaml analyser into the Xaml editor and consume the Xaml document.\n\n\nOnce MFractor has a copy of the Xaml DOM, it \nsymbolicates\n the xaml document. In this step all Xaml nodes are resolved to their corresponding .NET class, all attributes are resolved to properties, fields or methods and all markup extension expressions are parsed.\n\n\nIt may take a little while for MFractor to parse and symbolicate the Xaml DOM the first time a solution opens. While it's consuming the Xaml document, you might see a tooltip informing you that MFractor is not quite ready to analyse the document:\n\n\n\n\nWhen the Xaml document has been parsed and symbolicated, MFractor will analyse the document for a range of code issues. Any issues that are found are marked as either\n\n\nA full list of available Xaml analysers can be found at \nXamarin.Forms Xaml Analysers\n.\n\n\nWhenever you edit a Xaml code file, MFractor will cancel any running analysis, re-parse and symbolicate the document and then re-run the xaml analyser against your xaml.\n\n\nCode Fixes\n\n\nWhen MFractor detects a code issue, it is usually able to suggest a fix as well. When MFractor can fix an issue, it will display within the code issue tooltip that fixes are available:\n\n\n\n\nYou can action this fix by right clicking on the text area marked by the coloured squiggle, navigating to \nFix\n and then choosing your code fix. Alternatively, click on the affected text area and press \nAlt + Return\n to open the quick fix menu.\n\n\n\n\nMarkup Extension Expression Analysis\n\n\nWhen MFractor encounters a markup extension, an attribute value that have \n{ ... }\n as it's content, it will consume, evaluate and analyse the expression.\n\n\nMFractor supports analysis of the following markup extensions:\n\n\n\n\nx:Reference\n\n\nx:Static\n\n\nBinding\n\n\nStaticResource\n -\n Limited support\n\n\n\n\nBinding Expression Analysis\n\n\nMFractor supports analysis of binding markup extensions; this is a powerful feature that can prevent runtime bugs by checking that properties exist on a binding context, that return and input types match and match more.\n\n\nFor binding expressions to be analysed, MFractor must be able to resolve a binding context for the XAML document. For applications that use the \nPage\n \n-\n \nViewModel\n naming convention, binding contexts will automatically resolve when the XAML document is opened.\n\n\nTo learn how to configure a binding context for a XAML document, refer to the \nConfiguring A Binding Context\n documentation.", 
            "title": "Analysis"
        }, 
        {
            "location": "/xamarin-forms/analysis/#xaml-analysis", 
            "text": "Use the Xaml analyser to spend less time debugging and see Xaml errors in-editor", 
            "title": "Xaml Analysis"
        }, 
        {
            "location": "/xamarin-forms/analysis/#introduction", 
            "text": "It's common that xaml issues in Xamarin.Forms applications are undetected until runtime or worse, when sent out to a client. MFractor solves this by detecting Xaml issues  immediately  and then marking them inside the xaml editor with a concise error message.  Bye bye Xaml bugs! \ud83d\udc4b", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms/analysis/#under-the-hood", 
            "text": "Let's take a look at what happens \"under the hood\" in MFractor when you open a Xaml document:   When you open a Xaml file that's part of a .NET project, Visual Studio Mac notifies MFractor that a new Xaml document was opened for editing. MFractor will  inject the Xaml analyser into the Xaml editor and consume the Xaml document.  Once MFractor has a copy of the Xaml DOM, it  symbolicates  the xaml document. In this step all Xaml nodes are resolved to their corresponding .NET class, all attributes are resolved to properties, fields or methods and all markup extension expressions are parsed.  It may take a little while for MFractor to parse and symbolicate the Xaml DOM the first time a solution opens. While it's consuming the Xaml document, you might see a tooltip informing you that MFractor is not quite ready to analyse the document:   When the Xaml document has been parsed and symbolicated, MFractor will analyse the document for a range of code issues. Any issues that are found are marked as either  A full list of available Xaml analysers can be found at  Xamarin.Forms Xaml Analysers .  Whenever you edit a Xaml code file, MFractor will cancel any running analysis, re-parse and symbolicate the document and then re-run the xaml analyser against your xaml.", 
            "title": "Under The Hood"
        }, 
        {
            "location": "/xamarin-forms/analysis/#code-fixes", 
            "text": "When MFractor detects a code issue, it is usually able to suggest a fix as well. When MFractor can fix an issue, it will display within the code issue tooltip that fixes are available:   You can action this fix by right clicking on the text area marked by the coloured squiggle, navigating to  Fix  and then choosing your code fix. Alternatively, click on the affected text area and press  Alt + Return  to open the quick fix menu.", 
            "title": "Code Fixes"
        }, 
        {
            "location": "/xamarin-forms/analysis/#markup-extension-expression-analysis", 
            "text": "When MFractor encounters a markup extension, an attribute value that have  { ... }  as it's content, it will consume, evaluate and analyse the expression.  MFractor supports analysis of the following markup extensions:   x:Reference  x:Static  Binding  StaticResource  -  Limited support", 
            "title": "Markup Extension Expression Analysis"
        }, 
        {
            "location": "/xamarin-forms/analysis/#binding-expression-analysis", 
            "text": "MFractor supports analysis of binding markup extensions; this is a powerful feature that can prevent runtime bugs by checking that properties exist on a binding context, that return and input types match and match more.  For binding expressions to be analysed, MFractor must be able to resolve a binding context for the XAML document. For applications that use the  Page   -   ViewModel  naming convention, binding contexts will automatically resolve when the XAML document is opened.  To learn how to configure a binding context for a XAML document, refer to the  Configuring A Binding Context  documentation.", 
            "title": "Binding Expression Analysis"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/", 
            "text": "Implementing View Models\n\n\nGenerate properties and view models from Xaml to C# using code fixes and the Implement View Model refactoring\n\n\nIntroduction\n\n\nIn Xamarin.Forms apps, we design our applications using the Model - View - ViewModel design pattern; relying on binding mechanisms to mirror data back and forth between the view and view model.\n\n\nWe accomplish this data-transfer behaviour through the \nBinding Markup Extension\n. This is a Xamarin.Forms API that implements the \nIMarkupExtension interface\n; it reflects changes from the binding context to the view and vice-versa.\n\n\nWe use the binding markup extension syntax in our Xaml views:\n\n\nLoginPage.xaml.cs\n\n\nEntry Text=\n{Binding Username}\n/\n\n\n\n\n\nLoginViewModel.cs\n\n\npublic class LoginViewModel\n{\n  public string Username { get; set; }\n}\n\n\n\n\nIn the above example, \n{Binding Username}\n points to a public property on the \nLogingPage\ns binding context, the \nLoginViewModel\n. When the user enters text, changes are automatically applied into the \nUsername\n property.\n\n\nBut what if we introduced a new \nEntry\n bound to \nPassword\n, a property that doesn't exist on the \nLoginViewModel\n:\n\n\nLoginPage.xaml.cs\n\n\nEntry Text=\n{Binding Username}\n/\n\n\nEntry Text=\n{Binding Password}\n/\n\n\n\n\n\nProvided we have configured the views binding context correctly, the \nXaml analyser\n recognises this is a runtime bug and marks it:\n\n\n\n\nMFractor encourages a \nXaml first\n workflow; you write out bindings in Xaml and then generate the implementation on the view model.\n\n\nThis is a big change to existing workflows. Previously, we coded these properties by hand and wire them up manually in the Xaml; an approach both time-consuming and error prone. You have to remember property names, property types, control types and then you need to write this all out by hand!\n\n\nUsing binding generation we can \nliterally\n eliminate minutes of work and hundreds of keystrokes in a few clicks.\n\n\nMFractor provides the following shortcuts to implement our bound properties:\n\n\n\n\nFix Missing Binding\n: A code issue fix that generates a single binding property onto the view model.\n\n\nImplement View Model\n: A refactoring action that collects \nall\n missing bindings and generates them in bulk on the view model.\n\n\n\n\nLet's examine these two methods of implementing missing properties using MFractor.\n\n\nIssue Fixing on Missing Bindings\n\n\nWhen MFractor detects that a property in a binding expression doesn't exist on the binding context, it adds a code issue at the missing bindings location.\n\n\nTo action the code isxue fix, we right click on the issue (underlined in yellow), navigate to \nFix\n and then select \nGenerate a property...\n.\n\n\n\n\nWe have two options available when generating a property:\n\n\nGenerate a property named XXX in XXX\n creates a new public property with a public \nget\n and \nset\n accessor:\n\n\npublic string Password { get; set; }\n\n\n\n\nGenerate a property named XXX in XXX with backing fields\n creates a new public property with a public \nget\n and \nset\n accessor that sets or gets a backing field:\n\n\nprivate string _password;\npublic string Password\n{\n  get\n  {\n    return _password;\n  }\n  set\n  {\n    _password = value;\n  }\n}\n\n\n\n\nThe default getter / setter fix is most useful when:\n\n\n\n\nWe want a plain old property with no backing logic.\n\n\nWe are using Fody's \nImplementPropertyChanged\n attribute on our ViewModel to automatically add INotifyPropertyChanged behaviour.\n\n\n\n\nThe backing field fix is most useful when:\n\n\n\n\nWe want backing logic that occurs when our property changes.\n\n\nWe occasionally want to manipulate the properties backing field without changes propagating to the UI.\n\n\n\n\nThe Implement ViewModel Refactoring\n\n\nAnother way to generate properties for a view model is to use the \nImplement View Model\n refactoring. This shortcut collects \nall\n missing binding expressions (excluding bindings inside DataTemplates) and generates them in bulk onto the binding context.\n\n\nWe can access this short cut by right clicking anywhere in a Xaml file, navigating to \nGenerate\n and then selecting the \nImplement View Model\n action:\n\n\n\n\nYou'll notice that there are 2 actions:\n\n\n\n\nImplement View Model\n gathers all missing bindings in the xaml document and implements them all as public properties with a public \nget\n and \nset\n accessor.\n\n\nImplement View Model (Use Backing Fields)\n gathers all missing bindings in the xaml document and implements them all as public properties with a public \nget\n and \nset\n accessor that sets or gets a backing field.\n\n\n\n\nThere are often cases when a binding context isn't specified \nexplicitly \n and can't be inferred \nimplicitly\n. A common example of this is that you have just started to build a Xaml view and haven't yet got around to building the corresponding view model.\n\n\nThe \nImplement View Model\n action can also generate a view model class for the Xaml view if one is not already defined. Using Mvvm naming conventions, MFractor generates a view model class for your xaml view under the \nMyDefaultNamespace.ViewModels\n namespace.\n\n\nFor example:\n\n\nLoginPage.xaml.cs\n\n\nEntry Text=\n{Binding Username}\n/\n\n\nEntry Text=\n{Binding Password}\n/\n\n\n\n\n\nWhen creating the view model class, MFractor removes the \nPage\n or \nView\n suffix from the view name and then attaches \nViewModel\n to the end of the resulting name.\n\n\n\n\n\n\n\n\nRemove the \nPage\n or \nView\n suffix: LoginPage -\n Login\n\n\n\n\n\n\n\n\n\n\nAttach the \nViewModel\n suffix: Login -\n LoginViewModel\n\n\n\n\n\n\n\n\n\n\nGenerate a new class named \nLoginViewModel\n under the namespace \nMyDefaultNamespace.ViewModels\n.\n\n\n\n\n\n\n\n\nThis would result in the following view model class file:\n\n\nLoginViewModel.cs\n\n\npublic namespace MyDefaultNamespace.ViewModels\n{\n  public class LoginViewModel\n  {\n    public string Username { get; set; }\n    public string Password { get; set; }\n  }\n}\n\n\n\n\nIf you project references Fody's \nImplementPropertyChanged\n extension, the default getter / setter implementation will also annotate the result with the \n[ImplementPropertyChanged.PropertyChanged]\n attribute:\n\n\nLoginViewModel.cs\n\n\n[ImplementPropertyChanged.PropertyChanged]\npublic class LoginViewModel\n{\n}\n\n\n\n\nGenerating Commands Implementations\n\n\nWhen MFractor encounters a property that expects the \nSystem.Windows.Input.ICommand\n interface, it will generate a property returning a empty command implementation.\n\n\nFor example, we bind our login button to a \nLoginCommand\n property on our view model:\n\n\nButton Command=\n{Binding LoginCommand}\n/\n\n\n\n\n\nWhen MFractor generates the property for \nLoginCommand\n, it creates an empty command implementation:\n\n\npublic System.Windows.Input.ICommand LoginCommand\n{\n    get\n    {\n        return new Xamarin.Forms.Command(() =\n\n        {\n            throw new NotImplementedException();\n        }\n\n        );\n    }\n}\n\n\n\n\nBinding Generation And Value Converters\n\n\nWhen a binding expression uses a \nConverter\n, MFractor will attempt to resolve the input type of the referenced value converter and use that as the property type. We must have a value conversion attribute on the \nIValueConverter\n for MFractor to resolve the input type. Please read the \nValue Conversion Type-Safety\n tutorial to learn more.\n\n\nFor example, we add a login button that is only enabled when the user has their password entered:\n\n\nResourceDictionary\n\n    \nlocal:StringToBoolConverter x:Key=\nstringToBoolConverter\n /\n\n\n/ResourceDictionary\n\n\n\nButton IsEnabled=\n{Binding Password, Converter={StaticResource stringToBoolConverter}}\n/\n\n\n\n\n\nProvided that \nstringToBoolConverter\n is annotated to accept string inputs and return a boolean output, MFractor can still generate \nPassword\n as a string even though \nIsEnabled\n is a boolean property.\n\n\nIf there is no value conversion information on the value converter, MFractor will default to \nSysten.Object\n as the type for our property:\n\n\npublic System.Object Password\n{\n  get; set;\n}\n\n\n\n\nLimitations\n\n\nThere are a some limitations in the \nImplement View Model\n refactoring:\n\n\n\n\nWhen a Xaml view has an item that uses a \nDataTemplate\n to declare an inline view, MFractor \nwill not\n gather the bindings inside the data template. A refactoring action to generate bindings for data templates will be coming in a future MFractor release.\n\n\n\n\nSummary\n\n\nBy building our apps using the \nXaml first\n mindset, we can leverage MFractor's binding generation to implement our view models quickly.\n\n\nIn this tutorial we learnt:\n\n\n\n\nWe can generate entire view models using the \nImplement View Model\n refactoring action.\n\n\nWe can generate single properties using code issue fixing.\n\n\nWe need a binding context to activate binding expression analysis and issue fixing.\n\n\nWhen a binding uses a value converter, MFractor use the correct type when the converter has a value conversion attribute.", 
            "title": "Implementing View Models"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/#implementing-view-models", 
            "text": "Generate properties and view models from Xaml to C# using code fixes and the Implement View Model refactoring", 
            "title": "Implementing View Models"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/#introduction", 
            "text": "In Xamarin.Forms apps, we design our applications using the Model - View - ViewModel design pattern; relying on binding mechanisms to mirror data back and forth between the view and view model.  We accomplish this data-transfer behaviour through the  Binding Markup Extension . This is a Xamarin.Forms API that implements the  IMarkupExtension interface ; it reflects changes from the binding context to the view and vice-versa.  We use the binding markup extension syntax in our Xaml views:  LoginPage.xaml.cs  Entry Text= {Binding Username} /   LoginViewModel.cs  public class LoginViewModel\n{\n  public string Username { get; set; }\n}  In the above example,  {Binding Username}  points to a public property on the  LogingPage s binding context, the  LoginViewModel . When the user enters text, changes are automatically applied into the  Username  property.  But what if we introduced a new  Entry  bound to  Password , a property that doesn't exist on the  LoginViewModel :  LoginPage.xaml.cs  Entry Text= {Binding Username} /  Entry Text= {Binding Password} /   Provided we have configured the views binding context correctly, the  Xaml analyser  recognises this is a runtime bug and marks it:   MFractor encourages a  Xaml first  workflow; you write out bindings in Xaml and then generate the implementation on the view model.  This is a big change to existing workflows. Previously, we coded these properties by hand and wire them up manually in the Xaml; an approach both time-consuming and error prone. You have to remember property names, property types, control types and then you need to write this all out by hand!  Using binding generation we can  literally  eliminate minutes of work and hundreds of keystrokes in a few clicks.  MFractor provides the following shortcuts to implement our bound properties:   Fix Missing Binding : A code issue fix that generates a single binding property onto the view model.  Implement View Model : A refactoring action that collects  all  missing bindings and generates them in bulk on the view model.   Let's examine these two methods of implementing missing properties using MFractor.", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/#issue-fixing-on-missing-bindings", 
            "text": "When MFractor detects that a property in a binding expression doesn't exist on the binding context, it adds a code issue at the missing bindings location.  To action the code isxue fix, we right click on the issue (underlined in yellow), navigate to  Fix  and then select  Generate a property... .   We have two options available when generating a property:  Generate a property named XXX in XXX  creates a new public property with a public  get  and  set  accessor:  public string Password { get; set; }  Generate a property named XXX in XXX with backing fields  creates a new public property with a public  get  and  set  accessor that sets or gets a backing field:  private string _password;\npublic string Password\n{\n  get\n  {\n    return _password;\n  }\n  set\n  {\n    _password = value;\n  }\n}  The default getter / setter fix is most useful when:   We want a plain old property with no backing logic.  We are using Fody's  ImplementPropertyChanged  attribute on our ViewModel to automatically add INotifyPropertyChanged behaviour.   The backing field fix is most useful when:   We want backing logic that occurs when our property changes.  We occasionally want to manipulate the properties backing field without changes propagating to the UI.", 
            "title": "Issue Fixing on Missing Bindings"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/#the-implement-viewmodel-refactoring", 
            "text": "Another way to generate properties for a view model is to use the  Implement View Model  refactoring. This shortcut collects  all  missing binding expressions (excluding bindings inside DataTemplates) and generates them in bulk onto the binding context.  We can access this short cut by right clicking anywhere in a Xaml file, navigating to  Generate  and then selecting the  Implement View Model  action:   You'll notice that there are 2 actions:   Implement View Model  gathers all missing bindings in the xaml document and implements them all as public properties with a public  get  and  set  accessor.  Implement View Model (Use Backing Fields)  gathers all missing bindings in the xaml document and implements them all as public properties with a public  get  and  set  accessor that sets or gets a backing field.   There are often cases when a binding context isn't specified  explicitly   and can't be inferred  implicitly . A common example of this is that you have just started to build a Xaml view and haven't yet got around to building the corresponding view model.  The  Implement View Model  action can also generate a view model class for the Xaml view if one is not already defined. Using Mvvm naming conventions, MFractor generates a view model class for your xaml view under the  MyDefaultNamespace.ViewModels  namespace.  For example:  LoginPage.xaml.cs  Entry Text= {Binding Username} /  Entry Text= {Binding Password} /   When creating the view model class, MFractor removes the  Page  or  View  suffix from the view name and then attaches  ViewModel  to the end of the resulting name.     Remove the  Page  or  View  suffix: LoginPage -  Login      Attach the  ViewModel  suffix: Login -  LoginViewModel      Generate a new class named  LoginViewModel  under the namespace  MyDefaultNamespace.ViewModels .     This would result in the following view model class file:  LoginViewModel.cs  public namespace MyDefaultNamespace.ViewModels\n{\n  public class LoginViewModel\n  {\n    public string Username { get; set; }\n    public string Password { get; set; }\n  }\n}  If you project references Fody's  ImplementPropertyChanged  extension, the default getter / setter implementation will also annotate the result with the  [ImplementPropertyChanged.PropertyChanged]  attribute:  LoginViewModel.cs  [ImplementPropertyChanged.PropertyChanged]\npublic class LoginViewModel\n{\n}", 
            "title": "The Implement ViewModel Refactoring"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/#generating-commands-implementations", 
            "text": "When MFractor encounters a property that expects the  System.Windows.Input.ICommand  interface, it will generate a property returning a empty command implementation.  For example, we bind our login button to a  LoginCommand  property on our view model:  Button Command= {Binding LoginCommand} /   When MFractor generates the property for  LoginCommand , it creates an empty command implementation:  public System.Windows.Input.ICommand LoginCommand\n{\n    get\n    {\n        return new Xamarin.Forms.Command(() = \n        {\n            throw new NotImplementedException();\n        }\n\n        );\n    }\n}", 
            "title": "Generating Commands Implementations"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/#binding-generation-and-value-converters", 
            "text": "When a binding expression uses a  Converter , MFractor will attempt to resolve the input type of the referenced value converter and use that as the property type. We must have a value conversion attribute on the  IValueConverter  for MFractor to resolve the input type. Please read the  Value Conversion Type-Safety  tutorial to learn more.  For example, we add a login button that is only enabled when the user has their password entered:  ResourceDictionary \n     local:StringToBoolConverter x:Key= stringToBoolConverter  /  /ResourceDictionary  Button IsEnabled= {Binding Password, Converter={StaticResource stringToBoolConverter}} /   Provided that  stringToBoolConverter  is annotated to accept string inputs and return a boolean output, MFractor can still generate  Password  as a string even though  IsEnabled  is a boolean property.  If there is no value conversion information on the value converter, MFractor will default to  Systen.Object  as the type for our property:  public System.Object Password\n{\n  get; set;\n}", 
            "title": "Binding Generation And Value Converters"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/#limitations", 
            "text": "There are a some limitations in the  Implement View Model  refactoring:   When a Xaml view has an item that uses a  DataTemplate  to declare an inline view, MFractor  will not  gather the bindings inside the data template. A refactoring action to generate bindings for data templates will be coming in a future MFractor release.", 
            "title": "Limitations"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/#summary", 
            "text": "By building our apps using the  Xaml first  mindset, we can leverage MFractor's binding generation to implement our view models quickly.  In this tutorial we learnt:   We can generate entire view models using the  Implement View Model  refactoring action.  We can generate single properties using code issue fixing.  We need a binding context to activate binding expression analysis and issue fixing.  When a binding uses a value converter, MFractor use the correct type when the converter has a value conversion attribute.", 
            "title": "Summary"
        }, 
        {
            "location": "/xamarin-forms/value-converter-type-safety/", 
            "text": "Value Converter Type Safety\n\n\nProvide Xaml type-safety by annotating IValueConverter's with the ValueConversion attribute\n\n\nIntroduction\n\n\nIn Xamarin.Forms developers data bind properties in a control to properties on a binding context using the \nBinding\n markup extension.\n\n\nTypically, the type on the control's property matches the type on the binding context property. But what if we had a screen with an email entry that needs to change color when the user enters a valid email?\n\n\nEnter the \nIValueConverter interface\n; value converters transform one data type to another.\n\n\nWe can expose a boolean \nIsEmailValid\n on our binding context, bind the \nTextColor\n field of the entry to the \nIsEmailValid\n property and use an \nIValueConverter\n that converts a \nTrue\n value to black and a \nFalse\n value to red.\n\n\nOur converter would look like this:\n\n\npublic class BoolToTextColorConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        return (bool)value ? Color.Black : Color.Red;\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        throw new NotImplementedException();\n    }\n}\n\n\n\n\nAnd when used in our xaml:\n\n\nLoginPage.xaml\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nContentPage\n        xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n        xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n        x:Class=\nMyApp.LoginPage\n\n        xmlns:converters=\nclr-namespace:MyApp.Converters;assembly=MyApp\n\n    \nContentPage.Resources\n\n        \nResourceDictionary\n\n            \nconverters:BoolToTextColorConverter x:Key=\nboolToTextColorConverter\n /\n\n        \n/ResourceDictionary\n\n    \n/ContentPage.Resources\n\n    \nEntry TextColor=\n{Binding IsEmailValid, Converter={StaticResource boolToTextColorConverter}}\n/\n\n\n/ContentPage\n\n\n\n\n\nNow when the user enters an invalid email, the value converter will translate the \nIsEmailValid\n boolean property in a \nXamarin.Forms.Color\n!\n\n\nBut what if we accidentally provided a \nstring\n to the \nBoolToTextColorConverter\n:\n\n\nEntry TextColor=\n{Binding Email, Converter={StaticResource boolToTextColorConverter}}\n/\n\n\n\n\n\nThis creates a runtime bug we won't discover until we build, deploy and navigate to the \nLoginPage\n; we'll see a type cast exception without a clear indication of the problem.\n\n\nWe can completely avoid this problem by declaring a value converters intent with an \nValueConversionAttribute\n to hint to MFractor's Xaml analyser it's expected behaviour.\n\n\nThe ValueConversion Attribute\n\n\nIn WPF, Microsoft provides the \nValueConversionAttribute\n that developers can use to describe the input, output and parameter type that an \nIValueConverter\n expects. This class level annotation declares the intent of a value converter to tools and to other developers using a converter.\n\n\nUnfortunately this attribute is in the \nPresentationFramework\n assembly, which we can't reference in a Xamarin.Forms PCL or shared project.\n\n\nAs the \nValueConversionAttribute\n is simple in implementation, we can easily make our own:\n\n\n[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]\npublic class ValueConversionAttribute : Attribute\n{\n  public ValueConversionAttribute(Type input, Type output)\n  {\n  }\n\n  public Type ParameterType { get; set; }\n}\n\n\n\n\nLet's examine this attribute in detail:\n\n\n\n\nThe constructor \nValueConversionAttribute(Type input, Type output)\n declares the expected input and output types for a converter.\n\n\nType input\n is the expected \ninput\n type for the value converter. This is the argument \nobject value\n for the \nConvert\n method and the return type for the \nConvertBack\n method.\n\n\nType output\n is the expected \noutput\n type for the value converter. This is the return type for the \nConvert\n method and the argument \nobject value\n for the \nConvertBack\n method.\n\n\nThe property \nType ParameterType\n is the expected \nparamter\n type for the value converter. This is the argument \nobject parameter\n for the \nConvert\n and \nConvertBack\n methods.\n\n\n\n\nTo use the \nValueConversionAttribute\n in our source code, we annotate a value converter at the class level and use the \ntypeof\n operator to provide input, output and parameter types:\n\n\n[ValueConversion(typeof(bool), typeof(Xamarin.Forms.Color))]\npublic class BoolToTextColorConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        return (bool)value ? Color.Black : Color.Red;\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        throw new NotImplementedException();\n    }\n}\n\n\n\n\nThe \nBoolToTextColorConverter\n now declares it's intent when converting values to both tooling and other developers; it \nmust\n have a \nbool\n as an input and it \nmust\n return into a \nXamarin.Forms.Color\n type.\n\n\nTo include the \nValueConversionAttribute\n we can simply copy-paste the code into our code base. Alternatively, add a third party library like \nFormsCommunityToolkit.Converters\n that has the \nValueConversionAttribute\n defined.\n\n\nConverter Type-Safety in Xaml\n\n\nWhen an \nIValueConverter\n is annotated with the \nValueConversion\n attribute, we declare to MFractor that our value converter wishes to enforce \ntype safety\n.\n\n\nThis has a few benefits:\n\n\n\n\nMFractor can now verify the types passed into and returned by a \nConverter\n expression are correct in the given context.\n\n\nWhen MFractor is generating a property from a binding expression, it can now extract the type information for a converter and generate that property with the correct type information.\n\n\n\n\nLet's consider our previous example of a provided a string as the input to the \nBoolToTextColorConverter\n:\n\n\nEntry TextColor=\n{Binding Email, Converter={StaticResource boolToTextColorConverter}}\n/\n\n\n\n\n\nWhen analysing the \nBinding\n expression, MFractor will inspect for \nConverter\n expressions and then evaluate the inner converter for it's expected input and output type.\n\n\nAs we have provided a \nstring\n but \nBoolToTextColorConverter\n expects a \nbool\n, MFractor will mark this as an error within the Xaml editor:\n\n\n\n\nVoila! We now have type-safety in our Xaml when using value converters! \u2728\u2728\n\n\nAnnotated value converters also allow the refactoring engine to correctly generate properties.\n\n\nFor example, if the our binding context is missing the \nEmail\n property, MFractor will extract the input type from the value converter and use that to generate the binding property:\n\n\n\n\nInstead of using the type of the \nTextColor\n property, MFractor could see that \nBoolToTextColorConverter\n expected a \nbool\n value and then generated the \nEmail\n property with a \nbool\n.\n\n\nSummary\n\n\nIn this tutorial we learnt:\n\n\n\n\nWe can annotate implementations of \nIValueConverter\n with a \nValueConversionAttribute\n to declare it's value conversion intent.\n\n\nAnnotated value converters enable MFractor's Xaml analyser to provide type-safety in the Xaml editor.\n\n\nAnnotated value converters enable MFractor's refactoring engine to generate properties with the correct type information.", 
            "title": "Value Converter Type Safety"
        }, 
        {
            "location": "/xamarin-forms/value-converter-type-safety/#value-converter-type-safety", 
            "text": "Provide Xaml type-safety by annotating IValueConverter's with the ValueConversion attribute", 
            "title": "Value Converter Type Safety"
        }, 
        {
            "location": "/xamarin-forms/value-converter-type-safety/#introduction", 
            "text": "In Xamarin.Forms developers data bind properties in a control to properties on a binding context using the  Binding  markup extension.  Typically, the type on the control's property matches the type on the binding context property. But what if we had a screen with an email entry that needs to change color when the user enters a valid email?  Enter the  IValueConverter interface ; value converters transform one data type to another.  We can expose a boolean  IsEmailValid  on our binding context, bind the  TextColor  field of the entry to the  IsEmailValid  property and use an  IValueConverter  that converts a  True  value to black and a  False  value to red.  Our converter would look like this:  public class BoolToTextColorConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        return (bool)value ? Color.Black : Color.Red;\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        throw new NotImplementedException();\n    }\n}  And when used in our xaml:  LoginPage.xaml  ?xml version= 1.0  encoding= UTF-8 ?  ContentPage\n        xmlns= http://xamarin.com/schemas/2014/forms \n        xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n        x:Class= MyApp.LoginPage \n        xmlns:converters= clr-namespace:MyApp.Converters;assembly=MyApp \n     ContentPage.Resources \n         ResourceDictionary \n             converters:BoolToTextColorConverter x:Key= boolToTextColorConverter  / \n         /ResourceDictionary \n     /ContentPage.Resources \n     Entry TextColor= {Binding IsEmailValid, Converter={StaticResource boolToTextColorConverter}} /  /ContentPage   Now when the user enters an invalid email, the value converter will translate the  IsEmailValid  boolean property in a  Xamarin.Forms.Color !  But what if we accidentally provided a  string  to the  BoolToTextColorConverter :  Entry TextColor= {Binding Email, Converter={StaticResource boolToTextColorConverter}} /   This creates a runtime bug we won't discover until we build, deploy and navigate to the  LoginPage ; we'll see a type cast exception without a clear indication of the problem.  We can completely avoid this problem by declaring a value converters intent with an  ValueConversionAttribute  to hint to MFractor's Xaml analyser it's expected behaviour.", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms/value-converter-type-safety/#the-valueconversion-attribute", 
            "text": "In WPF, Microsoft provides the  ValueConversionAttribute  that developers can use to describe the input, output and parameter type that an  IValueConverter  expects. This class level annotation declares the intent of a value converter to tools and to other developers using a converter.  Unfortunately this attribute is in the  PresentationFramework  assembly, which we can't reference in a Xamarin.Forms PCL or shared project.  As the  ValueConversionAttribute  is simple in implementation, we can easily make our own:  [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]\npublic class ValueConversionAttribute : Attribute\n{\n  public ValueConversionAttribute(Type input, Type output)\n  {\n  }\n\n  public Type ParameterType { get; set; }\n}  Let's examine this attribute in detail:   The constructor  ValueConversionAttribute(Type input, Type output)  declares the expected input and output types for a converter.  Type input  is the expected  input  type for the value converter. This is the argument  object value  for the  Convert  method and the return type for the  ConvertBack  method.  Type output  is the expected  output  type for the value converter. This is the return type for the  Convert  method and the argument  object value  for the  ConvertBack  method.  The property  Type ParameterType  is the expected  paramter  type for the value converter. This is the argument  object parameter  for the  Convert  and  ConvertBack  methods.   To use the  ValueConversionAttribute  in our source code, we annotate a value converter at the class level and use the  typeof  operator to provide input, output and parameter types:  [ValueConversion(typeof(bool), typeof(Xamarin.Forms.Color))]\npublic class BoolToTextColorConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        return (bool)value ? Color.Black : Color.Red;\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        throw new NotImplementedException();\n    }\n}  The  BoolToTextColorConverter  now declares it's intent when converting values to both tooling and other developers; it  must  have a  bool  as an input and it  must  return into a  Xamarin.Forms.Color  type.  To include the  ValueConversionAttribute  we can simply copy-paste the code into our code base. Alternatively, add a third party library like  FormsCommunityToolkit.Converters  that has the  ValueConversionAttribute  defined.", 
            "title": "The ValueConversion Attribute"
        }, 
        {
            "location": "/xamarin-forms/value-converter-type-safety/#converter-type-safety-in-xaml", 
            "text": "When an  IValueConverter  is annotated with the  ValueConversion  attribute, we declare to MFractor that our value converter wishes to enforce  type safety .  This has a few benefits:   MFractor can now verify the types passed into and returned by a  Converter  expression are correct in the given context.  When MFractor is generating a property from a binding expression, it can now extract the type information for a converter and generate that property with the correct type information.   Let's consider our previous example of a provided a string as the input to the  BoolToTextColorConverter :  Entry TextColor= {Binding Email, Converter={StaticResource boolToTextColorConverter}} /   When analysing the  Binding  expression, MFractor will inspect for  Converter  expressions and then evaluate the inner converter for it's expected input and output type.  As we have provided a  string  but  BoolToTextColorConverter  expects a  bool , MFractor will mark this as an error within the Xaml editor:   Voila! We now have type-safety in our Xaml when using value converters! \u2728\u2728  Annotated value converters also allow the refactoring engine to correctly generate properties.  For example, if the our binding context is missing the  Email  property, MFractor will extract the input type from the value converter and use that to generate the binding property:   Instead of using the type of the  TextColor  property, MFractor could see that  BoolToTextColorConverter  expected a  bool  value and then generated the  Email  property with a  bool .", 
            "title": "Converter Type-Safety in Xaml"
        }, 
        {
            "location": "/xamarin-forms/value-converter-type-safety/#summary", 
            "text": "In this tutorial we learnt:   We can annotate implementations of  IValueConverter  with a  ValueConversionAttribute  to declare it's value conversion intent.  Annotated value converters enable MFractor's Xaml analyser to provide type-safety in the Xaml editor.  Annotated value converters enable MFractor's refactoring engine to generate properties with the correct type information.", 
            "title": "Summary"
        }, 
        {
            "location": "/xamarin-android/navigation-tools/", 
            "text": "Resource Expressions And Code Navigation\n\n\nLearn the C# and xml expressions that activate tooltips and go-to declaration in MFractor for Android\n\n\nOverview\n\n\nIf you\u2019re a Xamarin.Android developer building apps using the native APIs then chances are you spend a lot of time navigating resource code.\n\n\nThis becomes tedious when you are constantly doing manual searches for your target, browsing through the find results and then clicking the search result to jump to it. What\u2019s more, using go-to declaration on a C# resource symbol takes you to its integer id! It\u2019s tremendously frustrating and a massive time-waster.\n\n\nAnd this problem gets worse the bigger your project is; large Android applications can have dozens to hundreds of xml resources that need to be scanned each time a search takes place.\n\n\nMFractor addresses these navigation issues by overriding the default \u201cgo to declaration\u201d keyboard shortcuts when you are in the context of a resource expression.\n\n\nThese expressions come in 2 flavours:\n\n\n\n\nC#: Code expressions within C# that access the generated Resources class contained in the Resources.Designer.cs file. For instance; Resource.Layout.myLayout.\n\n\nXML: Code expressions within Android xml resources that point to another resource. For instance; @layout/myLayout.\n\n\n\n\nWhen MFractor detects the cursor is within one of these expressions, resource tooltips and go-to-declaration become active. This enables fast and efficient code navigation.\n\n\nThat is much faster than manual searching! Now lets go over each of these expression types.\n\n\nC# Resource Expressions\n\n\nFor C#, resource expressions are always resolved against the Resource.Designer.cs file that is generated alongside a project. This section assumes a basic familiarity of the Resource.Designer.cs file; if this is a new concept I suggested reading the \nAndroid Resource Basics\n page in Xamarins documentation.\n\n\nThe components of a supported resource expression are formatted like so:\n\n\n[Project Namespace].[Resource].[ResourceType].[ResourceName]\n\n\n\n\nWhere:\n\n\n\n\n[Project Namespace] is the project namespace that the Resources designer class resides. This component is either:\n\n\nImplicit: The encapsulating namespace is the same as the resource designers namespace or a using statement provides the resource designer class.\n\n\nExplicit: The expression explicitly uses the namespace that owns the resource class.\n\n\nResource is the constant Resource class that wraps the declarations of the ResourceType sub-classes.\n\n\nResourceType is the nested resource type class.\n\n\nResourceName is the name of the resource being referenced. MFractor will only trigger its behaviour when your caret or mouse cursor is over this component of the c# resource expression.\n\n\n\n\nAn example of a valid expression would be:\n\n\nResources.String.my_string;\n\n\n\n\nWhen your cursor is over the my_string component of this expression, MFractor will attempt to resolve a string resource named my_string.\n\n\nXml Resource Expressions\n\n\nXml resource expressions come in 3 different categories:\n\n\n\n\nReference expressions point directly to a resource. They begin with the \u2018@\u2019 character.\n\n\nDeclarative expressions declare a new resource. These are only used with ids. They begin with a \u2018@+\u2019 character sequence.\n\n\nTheme expression point to a component of the currently scoped theme. They begin with a \u2018?\u2019 character.\n\n\n\n\nReference and declarative expression are structured with the following syntax:\n\n\n@[+][PackageName:]resourceType/resourceName\n\n\n\n\nWhere:\n\n\n\n\n\n\n@[+] is the resource reference symbol.\n\n\n\n\n\n\nPackageName is an optional component that points to the package the resource is within.\n\n\n\n\nresourceType is the resource type.\n\n\nresourceName is the name of the resource.\n\n\n\n\nAn example of this would be:\n\n\n@string/my_string\n\n\n\n\nWhen your cursor is any component of this expression, MFractor will attempt to resolve a pre-existing string resource named my_string.\n\n\nLastly, theme resource expressions point to a component of the current theme. These are structured with the following syntax:\n\n\n?[PackageName:][ResourceType/]themeItemName\n\n\n\n\nWhere:\n\n\n\n\nPackageName is the optional package name the theme component resides within.\n\n\nResourceType is the optional resource type of the theme component. This is typically inferred.\n\n\nthemeItemName the name of the theme item.\n\n\n\n\nGo To Resource Declaration\n\n\nFind All Resource Usages\n\n\nResource Tooltips\n\n\nImage Tooltips", 
            "title": "Navigation Tools"
        }, 
        {
            "location": "/xamarin-android/navigation-tools/#resource-expressions-and-code-navigation", 
            "text": "Learn the C# and xml expressions that activate tooltips and go-to declaration in MFractor for Android", 
            "title": "Resource Expressions And Code Navigation"
        }, 
        {
            "location": "/xamarin-android/navigation-tools/#overview", 
            "text": "If you\u2019re a Xamarin.Android developer building apps using the native APIs then chances are you spend a lot of time navigating resource code.  This becomes tedious when you are constantly doing manual searches for your target, browsing through the find results and then clicking the search result to jump to it. What\u2019s more, using go-to declaration on a C# resource symbol takes you to its integer id! It\u2019s tremendously frustrating and a massive time-waster.  And this problem gets worse the bigger your project is; large Android applications can have dozens to hundreds of xml resources that need to be scanned each time a search takes place.  MFractor addresses these navigation issues by overriding the default \u201cgo to declaration\u201d keyboard shortcuts when you are in the context of a resource expression.  These expressions come in 2 flavours:   C#: Code expressions within C# that access the generated Resources class contained in the Resources.Designer.cs file. For instance; Resource.Layout.myLayout.  XML: Code expressions within Android xml resources that point to another resource. For instance; @layout/myLayout.   When MFractor detects the cursor is within one of these expressions, resource tooltips and go-to-declaration become active. This enables fast and efficient code navigation.  That is much faster than manual searching! Now lets go over each of these expression types.", 
            "title": "Overview"
        }, 
        {
            "location": "/xamarin-android/navigation-tools/#c-resource-expressions", 
            "text": "For C#, resource expressions are always resolved against the Resource.Designer.cs file that is generated alongside a project. This section assumes a basic familiarity of the Resource.Designer.cs file; if this is a new concept I suggested reading the  Android Resource Basics  page in Xamarins documentation.  The components of a supported resource expression are formatted like so:  [Project Namespace].[Resource].[ResourceType].[ResourceName]  Where:   [Project Namespace] is the project namespace that the Resources designer class resides. This component is either:  Implicit: The encapsulating namespace is the same as the resource designers namespace or a using statement provides the resource designer class.  Explicit: The expression explicitly uses the namespace that owns the resource class.  Resource is the constant Resource class that wraps the declarations of the ResourceType sub-classes.  ResourceType is the nested resource type class.  ResourceName is the name of the resource being referenced. MFractor will only trigger its behaviour when your caret or mouse cursor is over this component of the c# resource expression.   An example of a valid expression would be:  Resources.String.my_string;  When your cursor is over the my_string component of this expression, MFractor will attempt to resolve a string resource named my_string.", 
            "title": "C# Resource Expressions"
        }, 
        {
            "location": "/xamarin-android/navigation-tools/#xml-resource-expressions", 
            "text": "Xml resource expressions come in 3 different categories:   Reference expressions point directly to a resource. They begin with the \u2018@\u2019 character.  Declarative expressions declare a new resource. These are only used with ids. They begin with a \u2018@+\u2019 character sequence.  Theme expression point to a component of the currently scoped theme. They begin with a \u2018?\u2019 character.   Reference and declarative expression are structured with the following syntax:  @[+][PackageName:]resourceType/resourceName  Where:    @[+] is the resource reference symbol.    PackageName is an optional component that points to the package the resource is within.   resourceType is the resource type.  resourceName is the name of the resource.   An example of this would be:  @string/my_string  When your cursor is any component of this expression, MFractor will attempt to resolve a pre-existing string resource named my_string.  Lastly, theme resource expressions point to a component of the current theme. These are structured with the following syntax:  ?[PackageName:][ResourceType/]themeItemName  Where:   PackageName is the optional package name the theme component resides within.  ResourceType is the optional resource type of the theme component. This is typically inferred.  themeItemName the name of the theme item.", 
            "title": "Xml Resource Expressions"
        }, 
        {
            "location": "/xamarin-android/navigation-tools/#go-to-resource-declaration", 
            "text": "", 
            "title": "Go To Resource Declaration"
        }, 
        {
            "location": "/xamarin-android/navigation-tools/#find-all-resource-usages", 
            "text": "", 
            "title": "Find All Resource Usages"
        }, 
        {
            "location": "/xamarin-android/navigation-tools/#resource-tooltips", 
            "text": "", 
            "title": "Resource Tooltips"
        }, 
        {
            "location": "/xamarin-android/navigation-tools/#image-tooltips", 
            "text": "", 
            "title": "Image Tooltips"
        }, 
        {
            "location": "/xamarin-android/resource-intellisense/", 
            "text": "WORK IN PROGRESS\n\n\nResource IntelliSense\n\n\nBuilding Android resource files such as values, menus, drawables or layouts using resource code completion\n\n\nIntroduction\n\n\nSupported Resources\n\n\nThis is a list of the supported Android resource types that MFractor for Visual Studio Mac supports:", 
            "title": "Resource IntelliSense"
        }, 
        {
            "location": "/xamarin-android/resource-intellisense/#resource-intellisense", 
            "text": "Building Android resource files such as values, menus, drawables or layouts using resource code completion", 
            "title": "Resource IntelliSense"
        }, 
        {
            "location": "/xamarin-android/resource-intellisense/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-android/resource-intellisense/#supported-resources", 
            "text": "This is a list of the supported Android resource types that MFractor for Visual Studio Mac supports:", 
            "title": "Supported Resources"
        }, 
        {
            "location": "/code-actions/csharp/", 
            "text": "C# Code Actions\n\n\nAutogenerated by MFractor v3.0.4\n\n\nAssign Constructor Argument To Member\n\n\nPremium Only\n\n\nConfiguration Id: com.mfractor.code_actions.csharp.assign_constructor_argument_to_member\n\n\nWhen a constructor argument matches a member that isn't assigned by the constructor, this code action will generate an expression that assigns the argument to the member.\n\n\n\n\nUses:\n\n\n\n\nGenerate Assignment Expression\n\n\n\n\nCreate Immutable Constructor\n\n\nPremium Only\n\n\nConfiguration Id: com.mfractor.code_actions.csharp.create_immutable_constuctor\n\n\nThis code action creates a constructor that assigns all of a classes readonly fields from constructor arguments\n\n\nThe \nCreate Immutable Constructor\n code action is useful when building readonly class implementations.\n\n\nWhen triggered, the code action collects all readonly fields in a class and builds a constructor that has a parameter that assigns to each readonly field.\n\n\nBefore\n\n\npublic class MyImmutableClass\n{\n    public readonly string MyString;\n    public readonly int MyInt;\n}\n\n\n\n\nAfter\n\n\npublic class MyImmutableClass\n{\n    public readonly string MyString;\n    public readonly int MyInt;\n\n    public MyImmutableClass(string myString, myInt)\n    {\n        MyString = myString;\n        MyInt = myInt;\n    }\n}\n\n\n\n\nUses:\n\n\n\n\nGenerate Assignment Expression\n\n\nCreate Constructor\n\n\n\n\nImplement Base Class Constructors\n\n\nPremium Only\n\n\nConfiguration Id: com.mfractor.code_actions.csharp.implement_base_class_constructors\n\n\nWhen a C# class inherits from a base type that does only has parameterised constructors, this code action will generate each of the base classes parametered constructors.\n\n\nFor example, say a developer wanted to inherit \nMyCustomView\n from \nAndroid.Views.View\n to create a custom view in Xamarin.Android; the \nView\n class does not have any paramterless contructors.\n\n\n\npublic class MyCustomView : Android.Views.View // Generates a compiler error as View has no parameterless constructors. \n{\n}\n\n\n\n\n\nUsing the \nImplement Base Class Constructors\n code action against the \nMyCustomView\n class would generate the following code.\n\n\n\npublic class MyClass : View\n{\n    public MyClass(System.IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer) : base(javaReference, transfer)\n    {\n    }\n\n    public MyClass(Android.Content.Context context) : base(context)\n    {\n    }\n\n    public MyClass(Android.Content.Context context, Android.Util.IAttributeSet attrs) : base(context, attrs)\n    {\n    }\n\n    public MyClass(Android.Content.Context context, Android.Util.IAttributeSet attrs, int defStyleAttr) : base(context, attrs, defStyleAttr)\n    {\n    }\n\n    public MyClass(Android.Content.Context context, Android.Util.IAttributeSet attrs, int defStyleAttr, int defStyleRes) : base(context, attrs, defStyleAttr, defStyleRes)\n    {\n    }\n}\n\n\n\n\n\nExample\n\n\n\n\nUses:\n\n\n\n\nCreate Base Constructor\n\n\n\n\nAnnotate With Attribute Usage\n\n\nPremium Only\n\n\nConfiguration Id: com.mfractor.code_actions.csharp.annotate_with_attribute_usage\n\n\nAdds an \nAttributeUsage\n annotation to a class that derives directly or indirectly from \nSystem.Attribute\n.\n\n\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultAttributeUsage\n\n\nSystem.AttributeTargets\n\n\nClass\n\n\nWhen creating the attribute usage annotation, what is the default target this attribute should be used on?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nCreate AttributeUsage Annotation\n\n\n\n\nMake Class Inherit From System.Attribute\n\n\nPremium Only\n\n\nConfiguration Id: com.mfractor.code_actions.csharp.make_class_inherit_from_attribute\n\n\nWhen a class declaration ends with \nAttribute\n (EG: \nMyCoolAttribute\n) and does not derive from any class, this code action will make the class inherit from \nSystem.Attribute\n.", 
            "title": "C# Code Actions"
        }, 
        {
            "location": "/code-actions/csharp/#c-code-actions", 
            "text": "Autogenerated by MFractor v3.0.4", 
            "title": "C# Code Actions"
        }, 
        {
            "location": "/code-actions/csharp/#assign-constructor-argument-to-member", 
            "text": "Premium Only  Configuration Id: com.mfractor.code_actions.csharp.assign_constructor_argument_to_member  When a constructor argument matches a member that isn't assigned by the constructor, this code action will generate an expression that assigns the argument to the member.", 
            "title": "Assign Constructor Argument To Member"
        }, 
        {
            "location": "/code-actions/csharp/#uses", 
            "text": "Generate Assignment Expression", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/csharp/#create-immutable-constructor", 
            "text": "Premium Only  Configuration Id: com.mfractor.code_actions.csharp.create_immutable_constuctor  This code action creates a constructor that assigns all of a classes readonly fields from constructor arguments  The  Create Immutable Constructor  code action is useful when building readonly class implementations.  When triggered, the code action collects all readonly fields in a class and builds a constructor that has a parameter that assigns to each readonly field.  Before  public class MyImmutableClass\n{\n    public readonly string MyString;\n    public readonly int MyInt;\n}  After  public class MyImmutableClass\n{\n    public readonly string MyString;\n    public readonly int MyInt;\n\n    public MyImmutableClass(string myString, myInt)\n    {\n        MyString = myString;\n        MyInt = myInt;\n    }\n}", 
            "title": "Create Immutable Constructor"
        }, 
        {
            "location": "/code-actions/csharp/#uses_1", 
            "text": "Generate Assignment Expression  Create Constructor", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/csharp/#implement-base-class-constructors", 
            "text": "Premium Only  Configuration Id: com.mfractor.code_actions.csharp.implement_base_class_constructors  When a C# class inherits from a base type that does only has parameterised constructors, this code action will generate each of the base classes parametered constructors.  For example, say a developer wanted to inherit  MyCustomView  from  Android.Views.View  to create a custom view in Xamarin.Android; the  View  class does not have any paramterless contructors.  \npublic class MyCustomView : Android.Views.View // Generates a compiler error as View has no parameterless constructors. \n{\n}  Using the  Implement Base Class Constructors  code action against the  MyCustomView  class would generate the following code.  \npublic class MyClass : View\n{\n    public MyClass(System.IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer) : base(javaReference, transfer)\n    {\n    }\n\n    public MyClass(Android.Content.Context context) : base(context)\n    {\n    }\n\n    public MyClass(Android.Content.Context context, Android.Util.IAttributeSet attrs) : base(context, attrs)\n    {\n    }\n\n    public MyClass(Android.Content.Context context, Android.Util.IAttributeSet attrs, int defStyleAttr) : base(context, attrs, defStyleAttr)\n    {\n    }\n\n    public MyClass(Android.Content.Context context, Android.Util.IAttributeSet attrs, int defStyleAttr, int defStyleRes) : base(context, attrs, defStyleAttr, defStyleRes)\n    {\n    }\n}  Example", 
            "title": "Implement Base Class Constructors"
        }, 
        {
            "location": "/code-actions/csharp/#uses_2", 
            "text": "Create Base Constructor", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/csharp/#annotate-with-attribute-usage", 
            "text": "Premium Only  Configuration Id: com.mfractor.code_actions.csharp.annotate_with_attribute_usage  Adds an  AttributeUsage  annotation to a class that derives directly or indirectly from  System.Attribute .", 
            "title": "Annotate With Attribute Usage"
        }, 
        {
            "location": "/code-actions/csharp/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      DefaultAttributeUsage  System.AttributeTargets  Class  When creating the attribute usage annotation, what is the default target this attribute should be used on?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-actions/csharp/#uses_3", 
            "text": "Create AttributeUsage Annotation", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/csharp/#make-class-inherit-from-systemattribute", 
            "text": "Premium Only  Configuration Id: com.mfractor.code_actions.csharp.make_class_inherit_from_attribute  When a class declaration ends with  Attribute  (EG:  MyCoolAttribute ) and does not derive from any class, this code action will make the class inherit from  System.Attribute .", 
            "title": "Make Class Inherit From System.Attribute"
        }, 
        {
            "location": "/code-actions/android-resources/fix/", 
            "text": "Android Xml Resource Code Fixes\n\n\nAutogenerated by MFractor v3.0.4\n\n\nFix Declarative References\n\n\nConfiguration Id: com.mfractor.android.analysis.declarative_reference.fix\n\n\nReplaces misused declarative resource references with an id reference.\n\n\nApply Required Value\n\n\nConfiguration Id: com.mfractor.android.analysis.exact_value.fix\n\n\nReplaces an attributes value with the required value for xml element. For example, 'xmlns:android' must always be 'http://schemas.android.com/apk/res/android'.\n\n\nFix Mispelt Resource Usages\n\n\nConfiguration Id: com.mfractor.android.analysis.mispelt_resource_usage.fix\n\n\nReplaces unresolvable resource usages with an auto-suggested value based on the resources available in the project or its references.\n\n\nAdd Required Attributes\n\n\nConfiguration Id: com.mfractor.android.analysis.missing_attributes.fix\n\n\nAdds any missing required attributes and their default values to an xml node.\n\n\nFix 9-patch drawable references\n\n\nConfiguration Id: com.mfractor.android.analysis.drawable_nine_patch_reference.fix\n\n\nReplaces a nine patch drawable reference that includes the '.9' suffix with a reference that excludes the '.9' suffix.\n\n\nFix Flags\n\n\nConfiguration Id: com.mfractor.android.analysis.valid_flags.fix\n\n\nReplaces a mispelt flag with an auto-corrected suggestion or suggests from a list of valid keywords.\n\n\nFix Keywords\n\n\nConfiguration Id: com.mfractor.android.analysis.valid_keyword.fix\n\n\nReplaces a mispelt keyword with an auto-corrected suggestion or suggests from a list of valid keywords.\n\n\nFix Value Format\n\n\nConfiguration Id: com.mfractor.android.analysis.value_format.fix\n\n\nFixes typeos for inline values such as dimensions, color or floats.", 
            "title": "Issue Fixing"
        }, 
        {
            "location": "/code-actions/android-resources/fix/#android-xml-resource-code-fixes", 
            "text": "Autogenerated by MFractor v3.0.4", 
            "title": "Android Xml Resource Code Fixes"
        }, 
        {
            "location": "/code-actions/android-resources/fix/#fix-declarative-references", 
            "text": "Configuration Id: com.mfractor.android.analysis.declarative_reference.fix  Replaces misused declarative resource references with an id reference.", 
            "title": "Fix Declarative References"
        }, 
        {
            "location": "/code-actions/android-resources/fix/#apply-required-value", 
            "text": "Configuration Id: com.mfractor.android.analysis.exact_value.fix  Replaces an attributes value with the required value for xml element. For example, 'xmlns:android' must always be 'http://schemas.android.com/apk/res/android'.", 
            "title": "Apply Required Value"
        }, 
        {
            "location": "/code-actions/android-resources/fix/#fix-mispelt-resource-usages", 
            "text": "Configuration Id: com.mfractor.android.analysis.mispelt_resource_usage.fix  Replaces unresolvable resource usages with an auto-suggested value based on the resources available in the project or its references.", 
            "title": "Fix Mispelt Resource Usages"
        }, 
        {
            "location": "/code-actions/android-resources/fix/#add-required-attributes", 
            "text": "Configuration Id: com.mfractor.android.analysis.missing_attributes.fix  Adds any missing required attributes and their default values to an xml node.", 
            "title": "Add Required Attributes"
        }, 
        {
            "location": "/code-actions/android-resources/fix/#fix-9-patch-drawable-references", 
            "text": "Configuration Id: com.mfractor.android.analysis.drawable_nine_patch_reference.fix  Replaces a nine patch drawable reference that includes the '.9' suffix with a reference that excludes the '.9' suffix.", 
            "title": "Fix 9-patch drawable references"
        }, 
        {
            "location": "/code-actions/android-resources/fix/#fix-flags", 
            "text": "Configuration Id: com.mfractor.android.analysis.valid_flags.fix  Replaces a mispelt flag with an auto-corrected suggestion or suggests from a list of valid keywords.", 
            "title": "Fix Flags"
        }, 
        {
            "location": "/code-actions/android-resources/fix/#fix-keywords", 
            "text": "Configuration Id: com.mfractor.android.analysis.valid_keyword.fix  Replaces a mispelt keyword with an auto-corrected suggestion or suggests from a list of valid keywords.", 
            "title": "Fix Keywords"
        }, 
        {
            "location": "/code-actions/android-resources/fix/#fix-value-format", 
            "text": "Configuration Id: com.mfractor.android.analysis.value_format.fix  Fixes typeos for inline values such as dimensions, color or floats.", 
            "title": "Fix Value Format"
        }, 
        {
            "location": "/code-actions/xaml/fix/", 
            "text": "Xaml Code Fixes\n\n\nAutogenerated by MFractor v3.0.4\n\n\nGenerate property onto parent type\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_property\n\n\nThis fix generates a property with a getter and setter onto the parent type.\n\n\nUses:\n\n\n\n\nGenerate Instance Property\n\n\n\n\nGenerate bindable property on type\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_bindable_property\n\n\nThis fix generates a bindable property onto the targetted class.\n\n\nUses:\n\n\n\n\nGenerate Bindable Property\n\n\n\n\nReplace attribute with closely named member\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.autocorrect_member\n\n\nLooks for members on a C# class that are named closely to an unresolved xml attribute and then suggest near matches.\n\n\nReplace with correct attached property name\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.no_attached_property\n\n\nReplaces an incorrect attached property with an auto-corrected value.\n\n\nAuto-Correct Event Handler Name\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.autocorrect_event_handler\n\n\nAuto-corrects a missing event handler name with a closely named callback from the code behind class.\n\n\nUses:\n\n\n\n\nGenerate Event Handler Method Callback\n\n\n\n\nGenerate Event Handler\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_event_handler\n\n\nWhen an event handler Xaml attribute references a method that does not exist on the code behind class, the \nGenerate Missing Event Handler\n code fix will generate a method on the code behind class.\n\n\nConsider the following code:\n\n\nView: LoginPage.xaml\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nContentPage xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n    xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n    x:Class=\nHelloMFractor.LoginPage\n\n    \nButton Clicked=\nOnButtonClicked\n/\n\n\n/ContentPage\n\n\n\n\n\nCode Behind: LoginPage.xaml.cs\n\n\npublic partial class LoginPage : ContentPage\n{\n    public LoginPage()\n    {\n        InitializeComponent();\n    }\n}\n\n\n\n\nThe referenced method \nOnButtonClicked\n does not exist in the views code behind class, \nLoginPage\n. The corresponding \nanalyser\n will detect this issue and annotate it in your source code.\n\n\nFrom here, we can action the code fix to generate a method stub in \nLoginPage.xaml.cs\n:\n\n\n\n\nUses:\n\n\n\n\nGenerate Event Handler Method Callback\n\n\n\n\nReplace Field Or Method Reference With Property\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.binding_expression_does_not_return_property\n\n\nReplaces a field or method symbol within a binding expression with a suggested property name.\n\n\nGenerate Binding Expression Property Implement\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_binding_property\n\n\nUses:\n\n\n\n\nGenerate Instance Property\n\n\n\n\nAutocorrect Class Or Property\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.autocorrect_csharp_symbol\n\n\nWhen a c# symbol reference expression does not resolve, this fix applies an auto-corrected suggestion from the class/property.\n\n\nImport namespace and assembly\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.resolve_csharp_symbol\n\n\nWhen the namespace inside c# symbol reference expression can be resolved to a .NET symbol in the project or its references this fix generates an 'xmlns' import statement in the root xaml element.\n\n\nGenerate class and static member\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_class_and_member\n\n\nWhen a c# symbol reference expression does not resolve, this fix generates a stub class declaration with a default, readonly static member.\n\n\nGenerate class\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_csharp_class\n\n\nWhen a c# symbol reference expression does not resolve, this fix generates an implementation for the missing class.\n\n\nGenerate property\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_csharp_member\n\n\nGenerate a static or constant variable onto the targetted class\n\n\nCreate x:TypeArguments attribute.\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.create_type_arguments_attribute\n\n\nGenerates an x:TypeArguments attribute, resolving the potential argument types if possible.\n\n\nGenerate Missing Value Converter\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_missing_class_as_value_converter\n\n\nWhen a Xaml node cannot be resolved and it ends with '[cC]onverter', this fix will create a new implemenation of IValueConverter.\n\n\nUses:\n\n\n\n\nGenerate IValueConverter Implementation\n\n\n\n\nGenerate Missing View\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_missing_class_as_view\n\n\nWhen a Xaml node cannot be resolved, this fix will create a new implemenation of that class deriving from 'Xamarin.Forms.View'.\n\n\nGenerate Missing Class\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_missing_class\n\n\nWhen a Xaml node cannot be resolved, this fix will create a new implementation of that class.\n\n\nGenerate Resource Dictionary Key\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.missing_resource_key\n\n\nWhen a Xaml node that is declared within a ResourceDictionary is missing the \nx:Key\n attribute, this fix will automatically create a new \nx:Key\n attribute for the node.\n\n\nReplace unknown property value with autocorrection\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.unknown_static_property_value\n\n\nWhen a xaml element property attempts to reference a static field (for instance LayoutOptions.Center), this fix finds the nearest named member and replaces the incorrect value with an auto-correction.\n\n\nReplace node with auto-corrected match\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.autocorrect_unresolved_reference\n\n\nThis fix action replaces a mispelt xaml node that can be resolved in an assembly with its correct .NET symbol name.\n\n\nImport Namespace And Assembly\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.import_reference\n\n\nWhen an xaml node can be resolved to a .NET symbol in the project or its references this fix generates an 'xmlns' import statement in the root xaml element.\n\n\nRemove unused xmlns declaration\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.xml_namespace_is_unused\n\n\nRemoves the unused xmlns declaration.\n\n\nRename Duplicate Namespace References\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.multiple_namespace_assembly_references\n\n\nReplaces all occurances of a namespace with .\n\n\nUses:\n\n\n\n\nRename Xaml Namespace Generator\n\n\n\n\nReplace xml namespace with auto-correction\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.xml_namespace_does_not_exist\n\n\nReplaces an xml namespace prefix with the auto-corrected xml namespace.\n\n\nReplace x:Name with closely named member\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.xreference_does_not_exist\n\n\nReplaces an invalid x:Name reference with a similiarly named x:Name declared in the current document.\n\n\nGenerate Missing Binding Command Stub\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_binding_command_stub\n\n\nWhen the symbol referenced inside a binding expression is unresolved, this fix can either apply an auto-correcet or generate a property on elements the BindingContext\n\n\nUses:\n\n\n\n\nGenerate ICommand Implementation\n\n\n\n\nAutocorrect Nearly Named Property Binding\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.autcorrect_property_binding\n\n\nEncapsulate With Resource Dictionary\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.encapsulate_with_resource_dictionary\n\n\nWhen declaring the resources for a page/view, it is common to accidentally put resources directly inside a \nMyPage.Resources\n rather than wrapping the elements with a \nResourceDictionary\n declaration.\n\n\nExample:\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nContentPage xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n    xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n    x:Class=\nHelloMFractor.HelloMFractorPage\n\n    \nContentPage.Resources\n\n        \nx:String\nHello World!\n/x:String\n\n    \n/ContentPage.Resources\n\n\n/ContentPage\n\n\n\n\n\nIn the above example, the declaration \nx:String\nHello World!\n/x:String\n is declared directly inside the property setter, which will cause a type-mismatch exception at runtime.\n\n\nWhen actioned, the \nEncapsulate with resource dictionary\n fix will wrap elements inside a resources property setter node with a resource dictionary. This would correct the above sample to:\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nContentPage xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n    xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n    x:Class=\nHelloMFractor.HelloMFractorPage\n\n    \nContentPage.Resources\n\n    \nResourceDictionary\n\n          \nx:String\nHello World!\n/x:String\n\n    \n/ResourceDictionary\n\n    \n/ContentPage.Resources\n\n\n/ContentPage\n\n\n\n\n\nImport Value Converter For Binding\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.import_resolving_value_converter\n\n\nInspects for IValueConverter implementations within the project and it's references that match the value conversion flow for this binding type mismatch. IValueConverter implementations must be annotated with the \nValueConversionAttribute\n to be detected by this fix.\n\n\nCreate Value Converter That Resolves Type Flow\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.create_resolving_value_converter\n\n\nUsing the input and output type for a value conversion path, this code fix will create a new value converter implementation for the input and output type.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultConverterNamespace\n\n\nSystem.String\n\n\n\"converters\"\n\n\nThe namespace name of the xmlns import statement for the newly created value converter\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate IValueConverter Implementation", 
            "title": "Issue Fixing"
        }, 
        {
            "location": "/code-actions/xaml/fix/#xaml-code-fixes", 
            "text": "Autogenerated by MFractor v3.0.4", 
            "title": "Xaml Code Fixes"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-property-onto-parent-type", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.generate_property  This fix generates a property with a getter and setter onto the parent type.", 
            "title": "Generate property onto parent type"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses", 
            "text": "Generate Instance Property", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-bindable-property-on-type", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.generate_bindable_property  This fix generates a bindable property onto the targetted class.", 
            "title": "Generate bindable property on type"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_1", 
            "text": "Generate Bindable Property", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#replace-attribute-with-closely-named-member", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.autocorrect_member  Looks for members on a C# class that are named closely to an unresolved xml attribute and then suggest near matches.", 
            "title": "Replace attribute with closely named member"
        }, 
        {
            "location": "/code-actions/xaml/fix/#replace-with-correct-attached-property-name", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.no_attached_property  Replaces an incorrect attached property with an auto-corrected value.", 
            "title": "Replace with correct attached property name"
        }, 
        {
            "location": "/code-actions/xaml/fix/#auto-correct-event-handler-name", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.autocorrect_event_handler  Auto-corrects a missing event handler name with a closely named callback from the code behind class.", 
            "title": "Auto-Correct Event Handler Name"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_2", 
            "text": "Generate Event Handler Method Callback", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-event-handler", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.generate_event_handler  When an event handler Xaml attribute references a method that does not exist on the code behind class, the  Generate Missing Event Handler  code fix will generate a method on the code behind class.  Consider the following code:  View: LoginPage.xaml  ?xml version= 1.0  encoding= utf-8 ?  ContentPage xmlns= http://xamarin.com/schemas/2014/forms \n    xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n    x:Class= HelloMFractor.LoginPage \n     Button Clicked= OnButtonClicked /  /ContentPage   Code Behind: LoginPage.xaml.cs  public partial class LoginPage : ContentPage\n{\n    public LoginPage()\n    {\n        InitializeComponent();\n    }\n}  The referenced method  OnButtonClicked  does not exist in the views code behind class,  LoginPage . The corresponding  analyser  will detect this issue and annotate it in your source code.  From here, we can action the code fix to generate a method stub in  LoginPage.xaml.cs :", 
            "title": "Generate Event Handler"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_3", 
            "text": "Generate Event Handler Method Callback", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#replace-field-or-method-reference-with-property", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.binding_expression_does_not_return_property  Replaces a field or method symbol within a binding expression with a suggested property name.", 
            "title": "Replace Field Or Method Reference With Property"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-binding-expression-property-implement", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.generate_binding_property", 
            "title": "Generate Binding Expression Property Implement"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_4", 
            "text": "Generate Instance Property", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#autocorrect-class-or-property", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.autocorrect_csharp_symbol  When a c# symbol reference expression does not resolve, this fix applies an auto-corrected suggestion from the class/property.", 
            "title": "Autocorrect Class Or Property"
        }, 
        {
            "location": "/code-actions/xaml/fix/#import-namespace-and-assembly", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.resolve_csharp_symbol  When the namespace inside c# symbol reference expression can be resolved to a .NET symbol in the project or its references this fix generates an 'xmlns' import statement in the root xaml element.", 
            "title": "Import namespace and assembly"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-class-and-static-member", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.generate_class_and_member  When a c# symbol reference expression does not resolve, this fix generates a stub class declaration with a default, readonly static member.", 
            "title": "Generate class and static member"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-class", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.generate_csharp_class  When a c# symbol reference expression does not resolve, this fix generates an implementation for the missing class.", 
            "title": "Generate class"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-property", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.generate_csharp_member  Generate a static or constant variable onto the targetted class", 
            "title": "Generate property"
        }, 
        {
            "location": "/code-actions/xaml/fix/#create-xtypearguments-attribute", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.create_type_arguments_attribute  Generates an x:TypeArguments attribute, resolving the potential argument types if possible.", 
            "title": "Create x:TypeArguments attribute."
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-missing-value-converter", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.generate_missing_class_as_value_converter  When a Xaml node cannot be resolved and it ends with '[cC]onverter', this fix will create a new implemenation of IValueConverter.", 
            "title": "Generate Missing Value Converter"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_5", 
            "text": "Generate IValueConverter Implementation", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-missing-view", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.generate_missing_class_as_view  When a Xaml node cannot be resolved, this fix will create a new implemenation of that class deriving from 'Xamarin.Forms.View'.", 
            "title": "Generate Missing View"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-missing-class", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.generate_missing_class  When a Xaml node cannot be resolved, this fix will create a new implementation of that class.", 
            "title": "Generate Missing Class"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-resource-dictionary-key", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.missing_resource_key  When a Xaml node that is declared within a ResourceDictionary is missing the  x:Key  attribute, this fix will automatically create a new  x:Key  attribute for the node.", 
            "title": "Generate Resource Dictionary Key"
        }, 
        {
            "location": "/code-actions/xaml/fix/#replace-unknown-property-value-with-autocorrection", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.unknown_static_property_value  When a xaml element property attempts to reference a static field (for instance LayoutOptions.Center), this fix finds the nearest named member and replaces the incorrect value with an auto-correction.", 
            "title": "Replace unknown property value with autocorrection"
        }, 
        {
            "location": "/code-actions/xaml/fix/#replace-node-with-auto-corrected-match", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.autocorrect_unresolved_reference  This fix action replaces a mispelt xaml node that can be resolved in an assembly with its correct .NET symbol name.", 
            "title": "Replace node with auto-corrected match"
        }, 
        {
            "location": "/code-actions/xaml/fix/#import-namespace-and-assembly_1", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.import_reference  When an xaml node can be resolved to a .NET symbol in the project or its references this fix generates an 'xmlns' import statement in the root xaml element.", 
            "title": "Import Namespace And Assembly"
        }, 
        {
            "location": "/code-actions/xaml/fix/#remove-unused-xmlns-declaration", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.xml_namespace_is_unused  Removes the unused xmlns declaration.", 
            "title": "Remove unused xmlns declaration"
        }, 
        {
            "location": "/code-actions/xaml/fix/#rename-duplicate-namespace-references", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.multiple_namespace_assembly_references  Replaces all occurances of a namespace with .", 
            "title": "Rename Duplicate Namespace References"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_6", 
            "text": "Rename Xaml Namespace Generator", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#replace-xml-namespace-with-auto-correction", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.xml_namespace_does_not_exist  Replaces an xml namespace prefix with the auto-corrected xml namespace.", 
            "title": "Replace xml namespace with auto-correction"
        }, 
        {
            "location": "/code-actions/xaml/fix/#replace-xname-with-closely-named-member", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.xreference_does_not_exist  Replaces an invalid x:Name reference with a similiarly named x:Name declared in the current document.", 
            "title": "Replace x:Name with closely named member"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-missing-binding-command-stub", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.generate_binding_command_stub  When the symbol referenced inside a binding expression is unresolved, this fix can either apply an auto-correcet or generate a property on elements the BindingContext", 
            "title": "Generate Missing Binding Command Stub"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_7", 
            "text": "Generate ICommand Implementation", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#autocorrect-nearly-named-property-binding", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.autcorrect_property_binding", 
            "title": "Autocorrect Nearly Named Property Binding"
        }, 
        {
            "location": "/code-actions/xaml/fix/#encapsulate-with-resource-dictionary", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.encapsulate_with_resource_dictionary  When declaring the resources for a page/view, it is common to accidentally put resources directly inside a  MyPage.Resources  rather than wrapping the elements with a  ResourceDictionary  declaration.  Example:  ?xml version= 1.0  encoding= utf-8 ?  ContentPage xmlns= http://xamarin.com/schemas/2014/forms \n    xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n    x:Class= HelloMFractor.HelloMFractorPage \n     ContentPage.Resources \n         x:String Hello World! /x:String \n     /ContentPage.Resources  /ContentPage   In the above example, the declaration  x:String Hello World! /x:String  is declared directly inside the property setter, which will cause a type-mismatch exception at runtime.  When actioned, the  Encapsulate with resource dictionary  fix will wrap elements inside a resources property setter node with a resource dictionary. This would correct the above sample to:  ?xml version= 1.0  encoding= utf-8 ?  ContentPage xmlns= http://xamarin.com/schemas/2014/forms \n    xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n    x:Class= HelloMFractor.HelloMFractorPage \n     ContentPage.Resources \n     ResourceDictionary \n           x:String Hello World! /x:String \n     /ResourceDictionary \n     /ContentPage.Resources  /ContentPage", 
            "title": "Encapsulate With Resource Dictionary"
        }, 
        {
            "location": "/code-actions/xaml/fix/#import-value-converter-for-binding", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.import_resolving_value_converter  Inspects for IValueConverter implementations within the project and it's references that match the value conversion flow for this binding type mismatch. IValueConverter implementations must be annotated with the  ValueConversionAttribute  to be detected by this fix.", 
            "title": "Import Value Converter For Binding"
        }, 
        {
            "location": "/code-actions/xaml/fix/#create-value-converter-that-resolves-type-flow", 
            "text": "Configuration Id: com.mfractor.code_fixes.xaml.create_resolving_value_converter  Using the input and output type for a value conversion path, this code fix will create a new value converter implementation for the input and output type.", 
            "title": "Create Value Converter That Resolves Type Flow"
        }, 
        {
            "location": "/code-actions/xaml/fix/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      DefaultConverterNamespace  System.String  \"converters\"  The namespace name of the xmlns import statement for the newly created value converter", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_8", 
            "text": "Generate IValueConverter Implementation", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/generate/", 
            "text": "Xamarin.Forms Xaml Code Generation Tools\n\n\nAutogenerated by MFractor v3.0.4\n\n\nImplement Missing Members\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.implement_missing_members\n\n\nWhen a control uses undefined members/properties in a Xaml view, this refactoring collects all missing properties, attempts to resolve their types and then generates them onto the control/class.\n\n\nThe following \nmust\n be satisfied for this refactoring to trigger:\n\n\n\n\nOne or more undefined members/properties must be in use.\n\n\nThe referenced class must exist.\n\n\nThe referenced class must be writeable; aka it must be in the users source code.\n\n\nWhen the referenced class derives from \nXamarin.Forms.BindableObject\n, this refactoring will allow the generation of bindable properties.\n\n\n\n\nLet's examine the following code:\n\n\nMyCustomSlider.cs\n\n\n\npublic class MyCustomSlider : Xamarin.Forms.Slider\n{\n}\n\n\n\n\n\nMyXamlView.xaml\n\n\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nContentPage xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n    xmlns:local=\nclr-namespace:HelloMFractor\n\n    xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n    \nlocal:MyCustomSlider \n        MinRangeColor=\n{Binding MinColor}\n\n    x:Class=\nHelloMFractor.HelloMFractorPage\n\n        MaxRangeColor=\n{Binding MaxColor}\n/\n\n\n/ContentPage\n\n\n\n\n\n\n\nWhen \nImplement Missing Members\n is actioned MFractor can generate the members/properties as plain old properties (EG: \nget; set;\n) or as a bindable property implementation.\n\n\nFor example, when actioned to generate bindable properties, \nMyCustomSlider\n would become:\n\n\n\npublic class MyCustomSlider : Slider\n{\n    public static readonly BindableProperty MaxRangeColorProperty = BindableProperty.Create(nameof(MaxRangeColor), typeof(Color), typeof(HelloMFractor.MyCustomSlider), default(Color));\n    public Color MaxRangeColor\n    {\n        get\n        {\n            return (Xamarin.Forms.Color)GetValue(MaxRangeColorProperty);\n        }\n\n        set\n        {\n            SetValue(MaxRangeColorProperty, value);\n        }\n    }\n\n    public static readonly BindableProperty MinRangeColorProperty = BindableProperty.Create(nameof(MinRangeColor), typeof(object), typeof(HelloMFractor.MyCustomSlider), default(Color));\n    public Color MinRangeColor\n    {\n        get\n        {\n            return (Xamarin.Forms.Color)GetValue(MinRangeColorProperty);\n        }\n\n        set\n        {\n            SetValue(MinRangeColorProperty, value);\n        }\n    }\n}\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Instance Property\n\n\nGenerate Event Handler Declaration\n\n\nGenerate Bindable Property\n\n\n\n\nGenerate Grid ColumnDefinitions\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.generate_grid_column_definitions\n\n\nThis code generation action adds column definition setter to a Xamarin.Forms.Grid Xaml node with a single \nColumnDefinition Width=\\\"*\\\"/\n element; this allows you to quickly setup a boilerplate grid.\nWhen this refactoring is used, the \nGrid\n node will have the following code injected:\n\n\nGrid\n\n\\t\nGrid.ColumnDefinitions\n\n\\t\nColumnDefinition Width=\\\n*\\\n\n\\t\n/Grid.ColumnDefinitions\n\n\n/Grid\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Grid Column Definition\n\n\n\n\nGenerate Grid RowDefinitions\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.generate_grid_row_definitions\n\n\nThis code generation action adds row definition setter to a Xamarin.Forms.Grid Xaml node with a single \nRowDefinition Height=\"*\"/\n element; this allows you to quickly setup a boilerplate grid.\n\n\nWhen this refactoring is used, the \nGrid\n node will have the following code injected:\n\n\n\n\nGrid\n\n\n    \nGrid.RowDefinitions\n\n\n    \nRowDefinition Height=\n*\n\n\n    \n/Grid.RowDefinitions\n\n\n\n/Grid\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Grid Row Definition\n\n\n\n\nGenerate Grid Column Definition\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.generate_column_definition\n\n\nAdds a single \nColumnDefinition Width=\\\"*\\\"/\n element to the \nGrid.ColumnDefinitions\n node.\n\n\nUses:\n\n\n\n\nGenerate Grid Column Definition\n\n\n\n\nGenerate Grid Row Definition\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.generate_row_definition\n\n\nAdds a single \nRowDefinition Height=\\\"*\\\"/\n element to the \nGrid.RowDefinitions\n node.\n\n\nUses:\n\n\n\n\nGenerate Grid Row Definition\n\n\n\n\nGenerate Resource Dictionary\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.generate_resource_dictionary\n\n\nThe \nGenerate Resource Dictionary\n code action adds a \nMyView.ResourceDictionary\n property with a nested resource dictionary to any Xaml node that derives from \nXamarin.Forms.VisualElement\n or is the root application class. Developers can quickly add a resource dictionary in just a few keystrokes; this is especially useful when you need to add a resource dictionary to the root xaml node on a control or page.\n\n\nImplement View Model\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.implement_view_model\n\n\nThe \nImplement View Model\n code action detects when a xaml document has unimplemented bindings, gathers them all and then implements them in bulk into a new or existing view model.\n\n\nConsider the following Xaml code:\n\n\nLoginPage.xaml\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nContentPage xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n    xmlns:local=\nclr-namespace:HelloXamarinForms\n\n    xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n    x:Class=\nHelloXamarinForms.HelloXamarinFormsPage\n\n    \nStackLayout\n\n        \nLabel Text=\n{Binding Message}\n\n            TextColor=\n{Binding Color}\n\n          FontSize=\n{Binding Size}\n/\n\n    \n/StackLayout\n\n\n/ContentPage\n\n\n\n\n\nWhen used, the implement view model code action will gather all missing bindings, resolving the name and type:\n\n\n\n\nText=\"{Binding Message}\"\n: A property named \nMessage\n of type \nstring\n.\n\n\nTextColor=\"{Binding Color}\"\n: A property named \nColor\n of type \nXamarin.Forms.Color\n.\n\n\nFontSize=\"{Binding Size}\"\n: A property named \nMessage\n of type \ndouble\n.\n\n\n\n\nThen it generates the property declarations using those names and types, creates a new class named \nLoginViewModel\n and then writes a new file named \nLoginViewModel.cs\n containing the new class definition.\n\n\nThe generated code would be:\n\n\nusing System;\nnamespace MyApp.ViewModels\n{\n    public class LoginViewModel\n    {\n        public string Message { get; set; }\n        public Xamarin.Forms.Color Color { get; set; }\n        public double Size { get; set; }\n    }\n}\n\n\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBaseClass\n\n\nSystem.String\n\n\nNA\n\n\nThe fully qualified type to use as the base class for the view model. For example, \nMyApp.ViewModels.BaseViewModel\n.\n\n\n\n\n\n\nUseFodyPropertyChanged\n\n\nSystem.Boolean\n\n\nTrue\n\n\nIf the PropertyChanged attribute should be added to the class when Fody.PropertyChanged is referenced by the assembly.\n\n\n\n\n\n\nViewModelsFolder\n\n\nSystem.String\n\n\nNA\n\n\nThe folder path relative to the project root to insert the newly created view model class into. For example \nViewModels/Cells\n.\n\n\n\n\n\n\nViewModelSuffix\n\n\nSystem.String\n\n\n\"ViewModel\"\n\n\nThe suffix to append to the end of the newly created view model. For example, setting this to \nVM\n would cause a page named \nMainPage\n to create a view model named \nMainVM\n.\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Instance Property\n\n\nGenerate ICommand Implementation", 
            "title": "Code Generation"
        }, 
        {
            "location": "/code-actions/xaml/generate/#xamarinforms-xaml-code-generation-tools", 
            "text": "Autogenerated by MFractor v3.0.4", 
            "title": "Xamarin.Forms Xaml Code Generation Tools"
        }, 
        {
            "location": "/code-actions/xaml/generate/#implement-missing-members", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.implement_missing_members  When a control uses undefined members/properties in a Xaml view, this refactoring collects all missing properties, attempts to resolve their types and then generates them onto the control/class.  The following  must  be satisfied for this refactoring to trigger:   One or more undefined members/properties must be in use.  The referenced class must exist.  The referenced class must be writeable; aka it must be in the users source code.  When the referenced class derives from  Xamarin.Forms.BindableObject , this refactoring will allow the generation of bindable properties.   Let's examine the following code:  MyCustomSlider.cs  \npublic class MyCustomSlider : Xamarin.Forms.Slider\n{\n}  MyXamlView.xaml   ?xml version= 1.0  encoding= utf-8 ?  ContentPage xmlns= http://xamarin.com/schemas/2014/forms \n    xmlns:local= clr-namespace:HelloMFractor \n    xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n     local:MyCustomSlider \n        MinRangeColor= {Binding MinColor} \n    x:Class= HelloMFractor.HelloMFractorPage \n        MaxRangeColor= {Binding MaxColor} /  /ContentPage   When  Implement Missing Members  is actioned MFractor can generate the members/properties as plain old properties (EG:  get; set; ) or as a bindable property implementation.  For example, when actioned to generate bindable properties,  MyCustomSlider  would become:  \npublic class MyCustomSlider : Slider\n{\n    public static readonly BindableProperty MaxRangeColorProperty = BindableProperty.Create(nameof(MaxRangeColor), typeof(Color), typeof(HelloMFractor.MyCustomSlider), default(Color));\n    public Color MaxRangeColor\n    {\n        get\n        {\n            return (Xamarin.Forms.Color)GetValue(MaxRangeColorProperty);\n        }\n\n        set\n        {\n            SetValue(MaxRangeColorProperty, value);\n        }\n    }\n\n    public static readonly BindableProperty MinRangeColorProperty = BindableProperty.Create(nameof(MinRangeColor), typeof(object), typeof(HelloMFractor.MyCustomSlider), default(Color));\n    public Color MinRangeColor\n    {\n        get\n        {\n            return (Xamarin.Forms.Color)GetValue(MinRangeColorProperty);\n        }\n\n        set\n        {\n            SetValue(MinRangeColorProperty, value);\n        }\n    }\n}", 
            "title": "Implement Missing Members"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses", 
            "text": "Generate Instance Property  Generate Event Handler Declaration  Generate Bindable Property", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/generate/#generate-grid-columndefinitions", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.generate_grid_column_definitions  This code generation action adds column definition setter to a Xamarin.Forms.Grid Xaml node with a single  ColumnDefinition Width=\\\"*\\\"/  element; this allows you to quickly setup a boilerplate grid.\nWhen this refactoring is used, the  Grid  node will have the following code injected:  Grid \n\\t Grid.ColumnDefinitions \n\\t ColumnDefinition Width=\\ *\\ \n\\t /Grid.ColumnDefinitions  /Grid", 
            "title": "Generate Grid ColumnDefinitions"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses_1", 
            "text": "Generate Grid Column Definition", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/generate/#generate-grid-rowdefinitions", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.generate_grid_row_definitions  This code generation action adds row definition setter to a Xamarin.Forms.Grid Xaml node with a single  RowDefinition Height=\"*\"/  element; this allows you to quickly setup a boilerplate grid.  When this refactoring is used, the  Grid  node will have the following code injected:   Grid \n\n     Grid.RowDefinitions \n\n     RowDefinition Height= * \n\n     /Grid.RowDefinitions  /Grid", 
            "title": "Generate Grid RowDefinitions"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses_2", 
            "text": "Generate Grid Row Definition", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/generate/#generate-grid-column-definition", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.generate_column_definition  Adds a single  ColumnDefinition Width=\\\"*\\\"/  element to the  Grid.ColumnDefinitions  node.", 
            "title": "Generate Grid Column Definition"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses_3", 
            "text": "Generate Grid Column Definition", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/generate/#generate-grid-row-definition", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.generate_row_definition  Adds a single  RowDefinition Height=\\\"*\\\"/  element to the  Grid.RowDefinitions  node.", 
            "title": "Generate Grid Row Definition"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses_4", 
            "text": "Generate Grid Row Definition", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/generate/#generate-resource-dictionary", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.generate_resource_dictionary  The  Generate Resource Dictionary  code action adds a  MyView.ResourceDictionary  property with a nested resource dictionary to any Xaml node that derives from  Xamarin.Forms.VisualElement  or is the root application class. Developers can quickly add a resource dictionary in just a few keystrokes; this is especially useful when you need to add a resource dictionary to the root xaml node on a control or page.", 
            "title": "Generate Resource Dictionary"
        }, 
        {
            "location": "/code-actions/xaml/generate/#implement-view-model", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.implement_view_model  The  Implement View Model  code action detects when a xaml document has unimplemented bindings, gathers them all and then implements them in bulk into a new or existing view model.  Consider the following Xaml code:  LoginPage.xaml  ?xml version= 1.0  encoding= utf-8 ?  ContentPage xmlns= http://xamarin.com/schemas/2014/forms \n    xmlns:local= clr-namespace:HelloXamarinForms \n    xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n    x:Class= HelloXamarinForms.HelloXamarinFormsPage \n     StackLayout \n         Label Text= {Binding Message} \n            TextColor= {Binding Color} \n          FontSize= {Binding Size} / \n     /StackLayout  /ContentPage   When used, the implement view model code action will gather all missing bindings, resolving the name and type:   Text=\"{Binding Message}\" : A property named  Message  of type  string .  TextColor=\"{Binding Color}\" : A property named  Color  of type  Xamarin.Forms.Color .  FontSize=\"{Binding Size}\" : A property named  Message  of type  double .   Then it generates the property declarations using those names and types, creates a new class named  LoginViewModel  and then writes a new file named  LoginViewModel.cs  containing the new class definition.  The generated code would be:  using System;\nnamespace MyApp.ViewModels\n{\n    public class LoginViewModel\n    {\n        public string Message { get; set; }\n        public Xamarin.Forms.Color Color { get; set; }\n        public double Size { get; set; }\n    }\n}", 
            "title": "Implement View Model"
        }, 
        {
            "location": "/code-actions/xaml/generate/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      BaseClass  System.String  NA  The fully qualified type to use as the base class for the view model. For example,  MyApp.ViewModels.BaseViewModel .    UseFodyPropertyChanged  System.Boolean  True  If the PropertyChanged attribute should be added to the class when Fody.PropertyChanged is referenced by the assembly.    ViewModelsFolder  System.String  NA  The folder path relative to the project root to insert the newly created view model class into. For example  ViewModels/Cells .    ViewModelSuffix  System.String  \"ViewModel\"  The suffix to append to the end of the newly created view model. For example, setting this to  VM  would cause a page named  MainPage  to create a view model named  MainVM .", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses_5", 
            "text": "Generate Instance Property  Generate ICommand Implementation", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/organise/", 
            "text": "Xamarin.Forms Xaml Organisation\n\n\nAutogenerated by MFractor v3.0.4\n\n\nCollapse Attributes Onto Same Line\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.collapse_attributes_onto_same_line\n\n\nThis code action collapses all the attributes for a Xaml node onto the same line as the nodes name declaration.\n\n\nExpand Attributes Onto Separate Lines\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.expand_attributes_onto_new_lines\n\n\nThis code action expands all the attributes for a Xaml node onto a separate line for each attribute.\n\n\nFor example, gi\n\n\nSort Xaml Attributes\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.sort_attributes\n\n\nThis code action sorts the attributes for a Xaml node and regenerates the xaml node based on the IDE's xml formatting policy.\nMFractor uses the following rules when sorting:\n\n\n\n\nAttributes that declare an xml namespace are ordered first, sorted alphabetically ascending. For example \nxmlns:forms=\"http://xamarin.com/schemas/2014/forms\"\n will appear before \nxmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n.\n\n\nAttributes that belong to the Microsoft Xaml schema \nhttp://schemas.microsoft.com/winfx/2009/xaml\n are ordered next. For example, the \nx:Class\n or \nx:Name\n declaration.\n\n\nAttributes belonging to the default namespace are ordered next, sorted alphabetically ascending.\n\n\nAttributes belonging to the other namespaces are then ordered next, sorted by namespace ascending and then by attribute name ascending.\n\n\n\n\nUses:\n\n\n\n\nSort Xaml Attributes\n\n\n\n\nFormat Xaml Document\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.format_document\n\n\nApplies the xml formatting policy to the entire document. It will correctly indent nodes, sort attributes, align attributes under the parent node.\n\n\nUses:\n\n\n\n\nSort Xaml Attributes\n\n\n\n\nCollapse Node\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.collapse_node_closing_tag\n\n\nWhen a Xaml node has a closing tag and no children (eg: \nMyNode\n \n/MyNode\n), this refactoring allows the developer to remove the closing tag to make the node self-closing. For example, when applied to the node \nMyNode\n ... \n/MyNode\n, the closing tag \n/MyNode\n is removed and the element becomes self closing like so: \nMyNode/\n.\n\n\nExpand Node\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.expand_node_with_closing_tag\n\n\nWhen a Xaml node is self-closing (EG \nMyNode/\n), this organise refactoring allows a developer to generate a closing tag for the node. For example, the node \nMyNode/\n would become \nMyNode\n ... \n/MyNode\n after applying this refactoring.\n\n\nRemove Unused Namespaces\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.remove_unused_namespaces\n\n\nWhen a xaml node has unused xml namespace declarations, this code action will remove all unused namespaces.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nShouldSort\n\n\nSystem.Boolean\n\n\nTrue\n\n\nIf the attributes for this node should be sorted when the unused namespaces are removed\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nSort Xaml Attributes", 
            "title": "Xaml Organisation"
        }, 
        {
            "location": "/code-actions/xaml/organise/#xamarinforms-xaml-organisation", 
            "text": "Autogenerated by MFractor v3.0.4", 
            "title": "Xamarin.Forms Xaml Organisation"
        }, 
        {
            "location": "/code-actions/xaml/organise/#collapse-attributes-onto-same-line", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.collapse_attributes_onto_same_line  This code action collapses all the attributes for a Xaml node onto the same line as the nodes name declaration.", 
            "title": "Collapse Attributes Onto Same Line"
        }, 
        {
            "location": "/code-actions/xaml/organise/#expand-attributes-onto-separate-lines", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.expand_attributes_onto_new_lines  This code action expands all the attributes for a Xaml node onto a separate line for each attribute.  For example, gi", 
            "title": "Expand Attributes Onto Separate Lines"
        }, 
        {
            "location": "/code-actions/xaml/organise/#sort-xaml-attributes", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.sort_attributes  This code action sorts the attributes for a Xaml node and regenerates the xaml node based on the IDE's xml formatting policy.\nMFractor uses the following rules when sorting:   Attributes that declare an xml namespace are ordered first, sorted alphabetically ascending. For example  xmlns:forms=\"http://xamarin.com/schemas/2014/forms\"  will appear before  xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" .  Attributes that belong to the Microsoft Xaml schema  http://schemas.microsoft.com/winfx/2009/xaml  are ordered next. For example, the  x:Class  or  x:Name  declaration.  Attributes belonging to the default namespace are ordered next, sorted alphabetically ascending.  Attributes belonging to the other namespaces are then ordered next, sorted by namespace ascending and then by attribute name ascending.", 
            "title": "Sort Xaml Attributes"
        }, 
        {
            "location": "/code-actions/xaml/organise/#uses", 
            "text": "Sort Xaml Attributes", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/organise/#format-xaml-document", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.format_document  Applies the xml formatting policy to the entire document. It will correctly indent nodes, sort attributes, align attributes under the parent node.", 
            "title": "Format Xaml Document"
        }, 
        {
            "location": "/code-actions/xaml/organise/#uses_1", 
            "text": "Sort Xaml Attributes", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/organise/#collapse-node", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.collapse_node_closing_tag  When a Xaml node has a closing tag and no children (eg:  MyNode   /MyNode ), this refactoring allows the developer to remove the closing tag to make the node self-closing. For example, when applied to the node  MyNode  ...  /MyNode , the closing tag  /MyNode  is removed and the element becomes self closing like so:  MyNode/ .", 
            "title": "Collapse Node"
        }, 
        {
            "location": "/code-actions/xaml/organise/#expand-node", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.expand_node_with_closing_tag  When a Xaml node is self-closing (EG  MyNode/ ), this organise refactoring allows a developer to generate a closing tag for the node. For example, the node  MyNode/  would become  MyNode  ...  /MyNode  after applying this refactoring.", 
            "title": "Expand Node"
        }, 
        {
            "location": "/code-actions/xaml/organise/#remove-unused-namespaces", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.remove_unused_namespaces  When a xaml node has unused xml namespace declarations, this code action will remove all unused namespaces.", 
            "title": "Remove Unused Namespaces"
        }, 
        {
            "location": "/code-actions/xaml/organise/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      ShouldSort  System.Boolean  True  If the attributes for this node should be sorted when the unused namespaces are removed", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-actions/xaml/organise/#uses_2", 
            "text": "Sort Xaml Attributes", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/refactor/", 
            "text": "Xamarin.Forms Xaml Refactoring\n\n\nAutogenerated by MFractor v3.0.4\n\n\nExtract Attribute Value Into Property Binding\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.extract_into_property_binding\n\n\nWhen a Xaml attribute is initialised by a literal value (rather than an expression), this refactoring action allows a developer to extract that literal value as a property into the binding context and replace the attribute initialiser with a binding expression.\n\n\nFor example, given the attribute initialiser \nText=\\\"Hello Xamarin.Forms!\\\"\n, this refactoring would generate a user named property (EG: Message) in the binding context, initiliase it with the string literal \n\\\"Message\\\"\n and replace the attribute value with the binding expresion \n{Binding Message}\n.\";\n\n\n\n\nUses:\n\n\n\n\nGenerate Instance Property\n\n\n\n\nRename Xaml Namespace\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.rename_xaml_namespace\n\n\nThe \nRename Xaml Namespace\n code action will perform a symbolic rename-refactor on a particular Xaml within your document.\n\n\nThis is handy as you can then rename namespaces in a document without using a Find+Replace action; the rename xaml namespace action works against symbols so it will always rename only the namespace symbols.\n\n\nTo action this refactoring:\n\n\n\n\nWithin a Xaml document right click or \nAlt+Return\n on an \nxmlns\n attribute (EG: \nxmlns:local=\"clr-namespace:myApp\"\n)\n\n\nSelect \nRefactor\n.\n\n\nThen \nRename Namespace\n.\n\n\nEnter a new namespace name when prompted and then click enter.\n\n\n\n\nYour new namespace will be applied across the document:\n\n\n\n\nUses:\n\n\n\n\nRename Xaml Namespace Generator\n\n\n\n\nEdit Color Declaration\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.edit_inline_color\n\n\nThe \nEdit Color Declaration\n code actions allows visual editing of colors from your Xaml.\n\n\nSimply right click on a Xaml node that is a \nSystem.Drawing.Color\n or \nXamarin.Forms.Color\n and select \nEdit Color\n. Then you can use the color picker dialog to select a new color value:\n\n\n\n\nMigrate OnPlatform Usage\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.migrate_on_platform_usage\n\n\nIn Xamarin.Forms 2.3.4, there were changes made to the \nOnPlatform\n class to enable greater platform-specifics flexibility in the future. These changes deprecated the \nOnPlatform.iOS\n, \nOnPlatform.Android\n and \nOnPlatform.WinPhone\n properties in favour of a generic \nOn\n element to control the platform specifics.\n\n\nThe \nMigrate OnPlatform Usage\n code action is a refactoring that converts a pre-2.3.4 Xamarin.Forms \nOnPlatform\n usage to the new methodology using the nested \nOn\n element.\n\n\nFor example, given the following \nOnPlatform\n:\n\n\nOnPlatform x:TypeArguments=\nThickness\n \n            Android=\n0, 0, 0, 0\n \n            iOS=\n0, 20, 0, 0\n\n    \nOnPlatform.WinPhone\n\n        0, 0, 0, 0\n    \n/OnPlatform.WinPhone\n\n\n/OnPlatform\n\n\n\n\n\nMFractor would migrate the code to use the \nOn\n element:\n\n\nOnPlatform x:TypeArguments=\nThickness\n\n    \nOn Platform=\nAndroid\n0, 0, 0, 0\n/On\n\n    \nOn Platform=\niOS\n0, 20, 0, 0\n/On\n\n    \nOn Platform=\nWinPhone\n0, 0, 0, 0\n/On\n\n\n/OnPlatform", 
            "title": "Refactoring"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#xamarinforms-xaml-refactoring", 
            "text": "Autogenerated by MFractor v3.0.4", 
            "title": "Xamarin.Forms Xaml Refactoring"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#extract-attribute-value-into-property-binding", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.extract_into_property_binding  When a Xaml attribute is initialised by a literal value (rather than an expression), this refactoring action allows a developer to extract that literal value as a property into the binding context and replace the attribute initialiser with a binding expression.  For example, given the attribute initialiser  Text=\\\"Hello Xamarin.Forms!\\\" , this refactoring would generate a user named property (EG: Message) in the binding context, initiliase it with the string literal  \\\"Message\\\"  and replace the attribute value with the binding expresion  {Binding Message} .\";", 
            "title": "Extract Attribute Value Into Property Binding"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#uses", 
            "text": "Generate Instance Property", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#rename-xaml-namespace", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.rename_xaml_namespace  The  Rename Xaml Namespace  code action will perform a symbolic rename-refactor on a particular Xaml within your document.  This is handy as you can then rename namespaces in a document without using a Find+Replace action; the rename xaml namespace action works against symbols so it will always rename only the namespace symbols.  To action this refactoring:   Within a Xaml document right click or  Alt+Return  on an  xmlns  attribute (EG:  xmlns:local=\"clr-namespace:myApp\" )  Select  Refactor .  Then  Rename Namespace .  Enter a new namespace name when prompted and then click enter.   Your new namespace will be applied across the document:", 
            "title": "Rename Xaml Namespace"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#uses_1", 
            "text": "Rename Xaml Namespace Generator", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#edit-color-declaration", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.edit_inline_color  The  Edit Color Declaration  code actions allows visual editing of colors from your Xaml.  Simply right click on a Xaml node that is a  System.Drawing.Color  or  Xamarin.Forms.Color  and select  Edit Color . Then you can use the color picker dialog to select a new color value:", 
            "title": "Edit Color Declaration"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#migrate-onplatform-usage", 
            "text": "Configuration Id: com.mfractor.code_actions.xaml.migrate_on_platform_usage  In Xamarin.Forms 2.3.4, there were changes made to the  OnPlatform  class to enable greater platform-specifics flexibility in the future. These changes deprecated the  OnPlatform.iOS ,  OnPlatform.Android  and  OnPlatform.WinPhone  properties in favour of a generic  On  element to control the platform specifics.  The  Migrate OnPlatform Usage  code action is a refactoring that converts a pre-2.3.4 Xamarin.Forms  OnPlatform  usage to the new methodology using the nested  On  element.  For example, given the following  OnPlatform :  OnPlatform x:TypeArguments= Thickness  \n            Android= 0, 0, 0, 0  \n            iOS= 0, 20, 0, 0 \n     OnPlatform.WinPhone \n        0, 0, 0, 0\n     /OnPlatform.WinPhone  /OnPlatform   MFractor would migrate the code to use the  On  element:  OnPlatform x:TypeArguments= Thickness \n     On Platform= Android 0, 0, 0, 0 /On \n     On Platform= iOS 0, 20, 0, 0 /On \n     On Platform= WinPhone 0, 0, 0, 0 /On  /OnPlatform", 
            "title": "Migrate OnPlatform Usage"
        }, 
        {
            "location": "/code-analysis/csharp/android/", 
            "text": "Autogenerated by MFractor v3.0.4\n\n\nVerify Toast Is Shown\n\n\nPremium Only\n\n\nConfiguration Id: com.mfractor.analysis.android.validate_toast_usage\n\n\nSometimes when a Toast is created via MakeText, the Show method is accidently omitted. This analysis routine looks for invocations of Toast.MakeText() that don't then invoke the Show() method on the toast object in the same expression. If the MakeText() result is assigned into a variable or passed as a method argument then this check is skipped.\n\n\nCheck Views Exist In Layout\n\n\nPremium Only\n\n\nConfiguration Id: com.mfractor.analysis.android.views_exist_in_layout\n\n\nWhen using FindViewById() to retrieve views from a layout, sometimes a developer will attempt to retrieve a view that does not exist within the inflated layout. This analyser inspects a class for the MFractor.Annotations.Android.UsesLayoutAttribute annotation and then cross-checks that all FindViewById invocations provide a Resource.Id that exist within the targetted layout(s).\n\n\nValidate Cheeseknife Attributes\n\n\nPremium Only\n\n\nConfiguration Id: com.mfractor.analysis.android.validate_cheeseknife_attributes\n\n\nThis analyser inspect usages of attributes from the Cheeseknife view injection library; it validates that the Resource.Id.* exists in the layout provided into an MFractor.Annotations UsesLayout attribute.\n\n\nWarn Of Static Context References\n\n\nPremium Only\n\n\nConfiguration Id: com.mfractor.analysis.android.detect_static_context_reference\n\n\nThis analyser inspects static variable declarations within classes and checks if the type derives from Android.Content.Context. Static context references have the potential to cause large memory leaks.\n\n\nCheck Android.Content.Res.Resources Usages\n\n\nPremium Only\n\n\nConfiguration Id: com.mfractor.analysis.android.verify_resource_class_usage\n\n\nWhen using the Android.Content.Res.Resources class, all Get* expressions expect the correct resource type identifier. For example, when using Resource.GetString(), a resource identifier of Resources.String.myString is expected. Passing any other resource identifier such as Resource.Color.myColor may result in unintended data being used or runtime exceptions. This code analyser validates that the correct resource type is being provided to the API call.\n\n\nClass Derives From IJavaObject\n\n\nPremium Only\n\n\nConfiguration Id: com.mfractor.analysis.android.class_derivces_from_ijavaobject\n\n\nOften when creating new classes in a Xamarin.Android codebase developers will need a new class to be usable between Java and C#. Xamarin.Android provides the IJavaObject interface to expose a class to Java. Instead of directly inheriting from the IJavaObject interface, a developer should instead inherit from Java.Lang.Object which implements the required interface members.\n\n\nIncorrect Activity Creation\n\n\nPremium Only\n\n\nConfiguration Id: com.mfractor.analysis.android.incorrect_activity_creation\n\n\nThis analyser detects when a developer is instantiating an Android activity or activity subclass directly using a new expression. Activities should only ever be created through the operating system; creating them through a new expression leaves them in an invalid state.\n\n\nApplication Requires Peer Connection Constructor\n\n\nPremium Only\n\n\nConfiguration Id: com.mfractor.analysis.android.application_does_not_implement_peer_constructor\n\n\nThis analyser detects when a developer has created a custom implementation of the \nAndroid.App.Application\n class but has not implemented the peer connection constructor (EG \nMyApp(IntPtr, JniHandleOwnership)\n). This constructor is required for the custom application to be instantiated by the Xamarin.Android runtime.", 
            "title": "Android C# Analysis"
        }, 
        {
            "location": "/code-analysis/csharp/android/#verify-toast-is-shown", 
            "text": "Premium Only  Configuration Id: com.mfractor.analysis.android.validate_toast_usage  Sometimes when a Toast is created via MakeText, the Show method is accidently omitted. This analysis routine looks for invocations of Toast.MakeText() that don't then invoke the Show() method on the toast object in the same expression. If the MakeText() result is assigned into a variable or passed as a method argument then this check is skipped.", 
            "title": "Verify Toast Is Shown"
        }, 
        {
            "location": "/code-analysis/csharp/android/#check-views-exist-in-layout", 
            "text": "Premium Only  Configuration Id: com.mfractor.analysis.android.views_exist_in_layout  When using FindViewById() to retrieve views from a layout, sometimes a developer will attempt to retrieve a view that does not exist within the inflated layout. This analyser inspects a class for the MFractor.Annotations.Android.UsesLayoutAttribute annotation and then cross-checks that all FindViewById invocations provide a Resource.Id that exist within the targetted layout(s).", 
            "title": "Check Views Exist In Layout"
        }, 
        {
            "location": "/code-analysis/csharp/android/#validate-cheeseknife-attributes", 
            "text": "Premium Only  Configuration Id: com.mfractor.analysis.android.validate_cheeseknife_attributes  This analyser inspect usages of attributes from the Cheeseknife view injection library; it validates that the Resource.Id.* exists in the layout provided into an MFractor.Annotations UsesLayout attribute.", 
            "title": "Validate Cheeseknife Attributes"
        }, 
        {
            "location": "/code-analysis/csharp/android/#warn-of-static-context-references", 
            "text": "Premium Only  Configuration Id: com.mfractor.analysis.android.detect_static_context_reference  This analyser inspects static variable declarations within classes and checks if the type derives from Android.Content.Context. Static context references have the potential to cause large memory leaks.", 
            "title": "Warn Of Static Context References"
        }, 
        {
            "location": "/code-analysis/csharp/android/#check-androidcontentresresources-usages", 
            "text": "Premium Only  Configuration Id: com.mfractor.analysis.android.verify_resource_class_usage  When using the Android.Content.Res.Resources class, all Get* expressions expect the correct resource type identifier. For example, when using Resource.GetString(), a resource identifier of Resources.String.myString is expected. Passing any other resource identifier such as Resource.Color.myColor may result in unintended data being used or runtime exceptions. This code analyser validates that the correct resource type is being provided to the API call.", 
            "title": "Check Android.Content.Res.Resources Usages"
        }, 
        {
            "location": "/code-analysis/csharp/android/#class-derives-from-ijavaobject", 
            "text": "Premium Only  Configuration Id: com.mfractor.analysis.android.class_derivces_from_ijavaobject  Often when creating new classes in a Xamarin.Android codebase developers will need a new class to be usable between Java and C#. Xamarin.Android provides the IJavaObject interface to expose a class to Java. Instead of directly inheriting from the IJavaObject interface, a developer should instead inherit from Java.Lang.Object which implements the required interface members.", 
            "title": "Class Derives From IJavaObject"
        }, 
        {
            "location": "/code-analysis/csharp/android/#incorrect-activity-creation", 
            "text": "Premium Only  Configuration Id: com.mfractor.analysis.android.incorrect_activity_creation  This analyser detects when a developer is instantiating an Android activity or activity subclass directly using a new expression. Activities should only ever be created through the operating system; creating them through a new expression leaves them in an invalid state.", 
            "title": "Incorrect Activity Creation"
        }, 
        {
            "location": "/code-analysis/csharp/android/#application-requires-peer-connection-constructor", 
            "text": "Premium Only  Configuration Id: com.mfractor.analysis.android.application_does_not_implement_peer_constructor  This analyser detects when a developer has created a custom implementation of the  Android.App.Application  class but has not implemented the peer connection constructor (EG  MyApp(IntPtr, JniHandleOwnership) ). This constructor is required for the custom application to be instantiated by the Xamarin.Android runtime.", 
            "title": "Application Requires Peer Connection Constructor"
        }, 
        {
            "location": "/code-analysis/csharp/xamarin-forms/", 
            "text": "Autogenerated by MFractor v3.0.4\n\n\nValidate ExportRendererAttribute Usages\n\n\nPremium Only\n\n\nConfiguration Id: com.mfractor.analysis.csharp.forms.validate_export_renderer_attribute\n\n\nThis analyser inspects usages of the ExportRenderer attribute, validating the type passed into the view argument is derived from Xamarin.Forms.View and that the type passed into the renderer argument is a renderer type.", 
            "title": "Xamarin.Forms C# Analysis"
        }, 
        {
            "location": "/code-analysis/csharp/xamarin-forms/#validate-exportrendererattribute-usages", 
            "text": "Premium Only  Configuration Id: com.mfractor.analysis.csharp.forms.validate_export_renderer_attribute  This analyser inspects usages of the ExportRenderer attribute, validating the type passed into the view argument is derived from Xamarin.Forms.View and that the type passed into the renderer argument is a renderer type.", 
            "title": "Validate ExportRendererAttribute Usages"
        }, 
        {
            "location": "/code-analysis/android-resources/", 
            "text": "Android Resource Analysis\n\n\nAutogenerated by MFractor v3.0.4\n\n\nCheck For Invalid Android Xml Elements\n\n\nInspects an xml file for unknown elements. For example, a res/menu xml file may only contain 'menu', 'item' and 'group' elements.\n\n\nCheck Public Android Resource Usage\n\n\nInspects Android resource usages and ensure that the resource referenced has been declared as public.\n\n\nDeclarative ID In Style\n\n\nDefining a style which sets android:id to a dynamically generated id can cause many versions of aapt, the resource packaging tool, to crash. To work around this, declare the id explicitly with \nitem type=\"id\" name=\"...\" /\n instead.\n\n\nDetect Duplicate Plurals Entries\n\n\nInspects a 'plurals' resource entry for 'item' elements that have the same 'quantity' value.\n\n\nCheck For Required Value\n\n\nChecks that the input argument for an XML attribute matches the required value for that attribute. For example, 'xmlns:android' must always be 'http://schemas.android.com/apk/res/android'.\n\n\nCheck For Invalid Characters In Value Resource Names\n\n\nChecks that the 'name' attribute for value based resources do not contain invalid characters. Any character apart for 0-9, a-z, A-Z, '.' and '_' are considered to be an invalid character. This check prevents characters that are also operators (such as +, * or \n) from being baked into the Resource.Designer.cs file when the resource ids are generated.\n\n\nValidate Flag Input\n\n\nValidates that any flags provided to an xml attribute are valid.\n\n\nValid Keyword Input\n\n\nValidates that a keyword or sequence of flags provided to an xml attribute are valid. For instance, the installation location is doen by the 'android:installLocation' manifest attribute. This attribute only accepts 'internalOnly', 'auto' and 'preferExternal', any other value is a compilation error.\n\n\nItem Value Resource Is Valid\n\n\nChecks that the content contained within an \n tag that declares a value resource declaration is a valid format for its type.\n\n\nMispelt Resource Type References\n\n\nChecks that the resource references (EG: @string/myString) have a valid resource type component and suggests an auto-correction if possible.\n\n\nMultiple \n usages in manifest\n\n\nInspects the \n element within the Android manifest for multiple declarations of the \n element. Only a single \n element is allowed.\n\n\nDrawable 9-patch reference check.\n\n\nChecks that a drawable reference does not end with '.9'.\n\n\nNode Missing Required Attributes\n\n\nChecks that a given resource node has all the mandatory attributes.\n\n\nCheck Reference Type\n\n\nVerifies that an attribute that expects a resource reference is provided a reference expression (@type/value) rather than a literal value.\n\n\nValidate quotations in \n elements.\n\n\nVerifies that quotation marks (' and \") are properly escaped when inside a string resource. For instance, single quotes (') must be escaped by a preceeding '\\' unless the whole string is wrapped within double quotes (\"). Furthermore, the use of double quotes must be escaped unless they enclose the entire string.\n\n\nResource Value Format\n\n\nValidates that a resource value (such as a dimension, color or percentage) is entered in the correct format.\n\n\nValues Resource Is Valid\n\n\nChecks that the content contained within a value resource declaration is a valid format for its type.\n\n\nVerify Input Type\n\n\nChecks that a xml attribute accepts the resource type used in a reference expression (EG: @string/myString).\n\n\nVerify Max API Feature Usages\n\n\nChecks that xml resources use Android SDK features that are within the projects Target API level.\n\n\nVerify Resource Exists\n\n\nChecks that a resource used via a reference expression (EG: @string/myString) exists within the project or its references.\n\n\nCheck for Duplicate Attributes.\n\n\nChecks for duplicate attributes on an xml node and then automatically removes the duplicates.\n\n\nTextView 'textSize' uses non-sp dimension\n\n\nInspects 'textSize' attributes for usages of non-sp dimensions\n\n\nValidate Animated Vectors Reference Vector Drawables\n\n\nVerifies that the 'android:drawable' attribute on an 'animated-vector' drawable resource points to a 'vector' base drawable.\n\n\nAppWidget Layout Is Valid\n\n\nAnalyses the layout file referenced by the 'android:initialLayout' attribute for an AppWidget configuration and ensures that it only contains allowed view types.\n\n\nCircular Resource Usage\n\n\nDetects when a resource usage (@type/value) that points to a file based resource (such as a layout or drawable) will generate a circular reference when it is inflated. A common example of this is using \ninclude\n or \nmerge\n tags inside a layout that also references other layouts via merging or including.\n\n\nInconsistent Array Sizes\n\n\nChecks that 'array', 'string-array' and 'integer-array' resources with multiple declarations all have the same number of elements across all locales they are declared in.\n\n\nLayout \n exists in configuration\n\n\nChecks that usages of 'include' tags within a Android layout reference a layout that is available within the current configuration.\n\n\nLayout Width And Height Required\n\n\nChecks that layout elements have both the 'android:layout_width' and 'android:layout_height' attributes declared. Elements that are missing these attributes will generate a runtime exception when the layout is inflated.\n\n\nCheck NFC Tech-List for whitespace\n\n\nLooks at the 'tech' elements inside an nfc 'tech-list' definition and verifies that they do not containi whitespace. The loader for tech-list elements is very strict and will cause a runtime exception when this tech-list is used. See https://code.google.com/p/android/issues/detail?id=65351\n\n\nDetect Resource Self Reference\n\n\nAnalyses resources usages to detect when a usage attempts to reference itself. This error is most likely to occur when using animations, drawables and particularly for layout includes.\n\n\nScroll View Has Multiple Children\n\n\nVerifies that a ScrollView only has 1 direct child; multiple children will cause a runtime exception when the layout is inflated. If you want more children, encapsulate the child elements into a layout container.", 
            "title": "Android Resource Analysis"
        }, 
        {
            "location": "/code-analysis/android-resources/#android-resource-analysis", 
            "text": "Autogenerated by MFractor v3.0.4", 
            "title": "Android Resource Analysis"
        }, 
        {
            "location": "/code-analysis/android-resources/#check-for-invalid-android-xml-elements", 
            "text": "Inspects an xml file for unknown elements. For example, a res/menu xml file may only contain 'menu', 'item' and 'group' elements.", 
            "title": "Check For Invalid Android Xml Elements"
        }, 
        {
            "location": "/code-analysis/android-resources/#check-public-android-resource-usage", 
            "text": "Inspects Android resource usages and ensure that the resource referenced has been declared as public.", 
            "title": "Check Public Android Resource Usage"
        }, 
        {
            "location": "/code-analysis/android-resources/#declarative-id-in-style", 
            "text": "Defining a style which sets android:id to a dynamically generated id can cause many versions of aapt, the resource packaging tool, to crash. To work around this, declare the id explicitly with  item type=\"id\" name=\"...\" /  instead.", 
            "title": "Declarative ID In Style"
        }, 
        {
            "location": "/code-analysis/android-resources/#detect-duplicate-plurals-entries", 
            "text": "Inspects a 'plurals' resource entry for 'item' elements that have the same 'quantity' value.", 
            "title": "Detect Duplicate Plurals Entries"
        }, 
        {
            "location": "/code-analysis/android-resources/#check-for-required-value", 
            "text": "Checks that the input argument for an XML attribute matches the required value for that attribute. For example, 'xmlns:android' must always be 'http://schemas.android.com/apk/res/android'.", 
            "title": "Check For Required Value"
        }, 
        {
            "location": "/code-analysis/android-resources/#check-for-invalid-characters-in-value-resource-names", 
            "text": "Checks that the 'name' attribute for value based resources do not contain invalid characters. Any character apart for 0-9, a-z, A-Z, '.' and '_' are considered to be an invalid character. This check prevents characters that are also operators (such as +, * or  ) from being baked into the Resource.Designer.cs file when the resource ids are generated.", 
            "title": "Check For Invalid Characters In Value Resource Names"
        }, 
        {
            "location": "/code-analysis/android-resources/#validate-flag-input", 
            "text": "Validates that any flags provided to an xml attribute are valid.", 
            "title": "Validate Flag Input"
        }, 
        {
            "location": "/code-analysis/android-resources/#valid-keyword-input", 
            "text": "Validates that a keyword or sequence of flags provided to an xml attribute are valid. For instance, the installation location is doen by the 'android:installLocation' manifest attribute. This attribute only accepts 'internalOnly', 'auto' and 'preferExternal', any other value is a compilation error.", 
            "title": "Valid Keyword Input"
        }, 
        {
            "location": "/code-analysis/android-resources/#item-value-resource-is-valid", 
            "text": "Checks that the content contained within an   tag that declares a value resource declaration is a valid format for its type.", 
            "title": "Item Value Resource Is Valid"
        }, 
        {
            "location": "/code-analysis/android-resources/#mispelt-resource-type-references", 
            "text": "Checks that the resource references (EG: @string/myString) have a valid resource type component and suggests an auto-correction if possible.", 
            "title": "Mispelt Resource Type References"
        }, 
        {
            "location": "/code-analysis/android-resources/#multiple-usages-in-manifest", 
            "text": "Inspects the   element within the Android manifest for multiple declarations of the   element. Only a single   element is allowed.", 
            "title": "Multiple  usages in manifest"
        }, 
        {
            "location": "/code-analysis/android-resources/#drawable-9-patch-reference-check", 
            "text": "Checks that a drawable reference does not end with '.9'.", 
            "title": "Drawable 9-patch reference check."
        }, 
        {
            "location": "/code-analysis/android-resources/#node-missing-required-attributes", 
            "text": "Checks that a given resource node has all the mandatory attributes.", 
            "title": "Node Missing Required Attributes"
        }, 
        {
            "location": "/code-analysis/android-resources/#check-reference-type", 
            "text": "Verifies that an attribute that expects a resource reference is provided a reference expression (@type/value) rather than a literal value.", 
            "title": "Check Reference Type"
        }, 
        {
            "location": "/code-analysis/android-resources/#validate-quotations-in-elements", 
            "text": "Verifies that quotation marks (' and \") are properly escaped when inside a string resource. For instance, single quotes (') must be escaped by a preceeding '\\' unless the whole string is wrapped within double quotes (\"). Furthermore, the use of double quotes must be escaped unless they enclose the entire string.", 
            "title": "Validate quotations in  elements."
        }, 
        {
            "location": "/code-analysis/android-resources/#resource-value-format", 
            "text": "Validates that a resource value (such as a dimension, color or percentage) is entered in the correct format.", 
            "title": "Resource Value Format"
        }, 
        {
            "location": "/code-analysis/android-resources/#values-resource-is-valid", 
            "text": "Checks that the content contained within a value resource declaration is a valid format for its type.", 
            "title": "Values Resource Is Valid"
        }, 
        {
            "location": "/code-analysis/android-resources/#verify-input-type", 
            "text": "Checks that a xml attribute accepts the resource type used in a reference expression (EG: @string/myString).", 
            "title": "Verify Input Type"
        }, 
        {
            "location": "/code-analysis/android-resources/#verify-max-api-feature-usages", 
            "text": "Checks that xml resources use Android SDK features that are within the projects Target API level.", 
            "title": "Verify Max API Feature Usages"
        }, 
        {
            "location": "/code-analysis/android-resources/#verify-resource-exists", 
            "text": "Checks that a resource used via a reference expression (EG: @string/myString) exists within the project or its references.", 
            "title": "Verify Resource Exists"
        }, 
        {
            "location": "/code-analysis/android-resources/#check-for-duplicate-attributes", 
            "text": "Checks for duplicate attributes on an xml node and then automatically removes the duplicates.", 
            "title": "Check for Duplicate Attributes."
        }, 
        {
            "location": "/code-analysis/android-resources/#textview-textsize-uses-non-sp-dimension", 
            "text": "Inspects 'textSize' attributes for usages of non-sp dimensions", 
            "title": "TextView 'textSize' uses non-sp dimension"
        }, 
        {
            "location": "/code-analysis/android-resources/#validate-animated-vectors-reference-vector-drawables", 
            "text": "Verifies that the 'android:drawable' attribute on an 'animated-vector' drawable resource points to a 'vector' base drawable.", 
            "title": "Validate Animated Vectors Reference Vector Drawables"
        }, 
        {
            "location": "/code-analysis/android-resources/#appwidget-layout-is-valid", 
            "text": "Analyses the layout file referenced by the 'android:initialLayout' attribute for an AppWidget configuration and ensures that it only contains allowed view types.", 
            "title": "AppWidget Layout Is Valid"
        }, 
        {
            "location": "/code-analysis/android-resources/#circular-resource-usage", 
            "text": "Detects when a resource usage (@type/value) that points to a file based resource (such as a layout or drawable) will generate a circular reference when it is inflated. A common example of this is using  include  or  merge  tags inside a layout that also references other layouts via merging or including.", 
            "title": "Circular Resource Usage"
        }, 
        {
            "location": "/code-analysis/android-resources/#inconsistent-array-sizes", 
            "text": "Checks that 'array', 'string-array' and 'integer-array' resources with multiple declarations all have the same number of elements across all locales they are declared in.", 
            "title": "Inconsistent Array Sizes"
        }, 
        {
            "location": "/code-analysis/android-resources/#layout-exists-in-configuration", 
            "text": "Checks that usages of 'include' tags within a Android layout reference a layout that is available within the current configuration.", 
            "title": "Layout  exists in configuration"
        }, 
        {
            "location": "/code-analysis/android-resources/#layout-width-and-height-required", 
            "text": "Checks that layout elements have both the 'android:layout_width' and 'android:layout_height' attributes declared. Elements that are missing these attributes will generate a runtime exception when the layout is inflated.", 
            "title": "Layout Width And Height Required"
        }, 
        {
            "location": "/code-analysis/android-resources/#check-nfc-tech-list-for-whitespace", 
            "text": "Looks at the 'tech' elements inside an nfc 'tech-list' definition and verifies that they do not containi whitespace. The loader for tech-list elements is very strict and will cause a runtime exception when this tech-list is used. See https://code.google.com/p/android/issues/detail?id=65351", 
            "title": "Check NFC Tech-List for whitespace"
        }, 
        {
            "location": "/code-analysis/android-resources/#detect-resource-self-reference", 
            "text": "Analyses resources usages to detect when a usage attempts to reference itself. This error is most likely to occur when using animations, drawables and particularly for layout includes.", 
            "title": "Detect Resource Self Reference"
        }, 
        {
            "location": "/code-analysis/android-resources/#scroll-view-has-multiple-children", 
            "text": "Verifies that a ScrollView only has 1 direct child; multiple children will cause a runtime exception when the layout is inflated. If you want more children, encapsulate the child elements into a layout container.", 
            "title": "Scroll View Has Multiple Children"
        }, 
        {
            "location": "/code-analysis/xaml/", 
            "text": "Xaml Code Analysis\n\n\nAutogenerated by MFractor v3.0.4\n\n\nUnused Xml Namespace\n\n\nValidate that xmlns attributes that declare a namespace and assembly that is used within the current document.\n\n\nObsolete Property Used\n\n\nChecks for attributes that are marked as obsolete/deprecated.\n\n\nx:Name Has Invalid Characters\n\n\nChecks that x:Name expressions define a valid code-behind variable name. A value declared by an x:Name attribute must start with a @, _ or a-Z character followed by underscores or alpha-numeric characters.\n\n\nDuplicate Code Behind Field Declarations\n\n\nChecks that the value assigned to an \nx:Name\n attribute is unique within the scope of the document.\n\n\nEvent Handler Exists In Code Behind Class\n\n\nChecks that an event callback referenced referenced by an attribute value exists in the code behind class.\n\n\nEvent Handler Signature Mismatch\n\n\nChecks that the signature for the event callback in a code behind class matches the expected signature for the property it is assigned to.\n\n\nValidate Binding Expressions Return A Property\n\n\nEvaluates a \nBinding\n expression and validates that it points to property within the binding context. This analyser requires an explict or implicit binding context.\n\n\nBinding Expressions Resolve\n\n\nInspects \nBinding\n expressions and validates that the symbol referred to in the binding context exists. This analyser requires an explict or implicit binding context.\n\n\nBinding Expression Return Type Mismatch\n\n\nValidates that the .NET symbol returned by a binding expression matches the expected type for the property.\n\n\nValue Converter Input Type Mismatch\n\n\nInspects the \nConverter\n property of a \nBinding\nexpression and validates that the input type is correct. This analyser requires that the \nIValueConverter\n implementation uses the \nValueConversion\n attribute to declare it input type.\n\n\nValue Converter Output Type Mismatch\n\n\nInspects the \nConverter\n component of a \nBinding\n expression and validates that the returned output type is valid for the parent attribute. This analyser requires that the \nIValueConverter\n implementation uses the \nValueConversion\n attribute to declare it input type.\n\n\nUnresolved .NET Symbols Within Xaml Expression\n\n\nInspects a .net symbol reference (eg \nlocal:MyClass.MyProperty\n) and validates that the symbol portion ('MyClass.MyProperty') resolves to a .NET symbol within the current project and it's references.\n\n\nUnresolved Namespace Within Xaml Expression\n\n\nInspects a .net symbol reference (eg \nlocal:MyClass.MyProperty\n) and validates that the namespace portion ('local') resolves to a xmlns declaration in the current document.\n\n\nx:Static Return Type Mismatch\n\n\nValidates that the .NET symbol returned by an \nx:Static\n expressions matches the expected type for the property.\n\n\nStaticResource Return Type Mismatch\n\n\nValidates that the symbol returned by a \nStaticResource\n expression matches the expected type for the property.\n\n\nUndefined Static Resource Usage\n\n\nValidates that the element referenced by a \nStaticResource\n expression resource lookup resolves to a resource defined in the xaml file.\n\n\nGeneric Usage Is Missing x:TypeArguments\n\n\nInspects generic classes that are instantiated through Xaml and validates that an \nx:TypeArguments\n attribute or property assignment node is present.\n\n\nx:TypeArguments Used On Non-Generic Class\n\n\nInspects for usages of \nx:TypeArguments\n on elements that are non-generic classes.\n\n\nUnknown Type Provided To Generic\n\n\nInspects usages of \nx:TypeArguments\n and validates that the type provided exists.\n\n\nReferenced Attribute Member Exists In Parent Type\n\n\nChecks that an attribute resolves to a member within its parent type.\n\n\nProperty Setter Attribute Has Value\n\n\nChecks that a value has been provided to an attribute property. This check is skipped if the property type is a string or a valueconverter or type converter is in use.\n\n\nProperty Node Maps To Member In Parent Type\n\n\nChecks that a property node resolves to a member within its parent type.\n\n\nProperty Setter Node Has Value\n\n\nChecks that a value has been provided to a node Property setter (EG \nMyClass.MyProperty\n/MyClass.MyProperty\n).\n\n\nProperty Setter Type Mismatch\n\n\nWhen using MyClass.MyProperty node setter syntax, validate that the inner child node returns a .NET object of the correct type for the property.\n\n\nDuplicate Resource Dictionary Keys\n\n\nValidates the each resource entry within a resource dictionary has a unique key.\n\n\nResource Entry Does Not Define Key\n\n\nValidates the elements provided to a resource dictionary supply an \nx:Key\n attribute to declare their resource dictionary key.\n\n\nMissing Microsoft Schema\n\n\nInspects at the root xaml node and verifies that it references the Microsoft Xaml schema: \nhttp://schemas.microsoft.com/winfx/2009/xaml\n. This schema is required for Xamarin Forms Xaml documents.\n\n\nUnresolved Xml Namespace\n\n\nChecks that the namespace used on the xml nodes is defined within the current document.\n\n\nUnresolved Xmlns Assembly\n\n\nChecks that the 'assembly' component of an xmlns statement resolves to an assembly referenced by the project.\n\n\nClass Does Not Have Attached Property\n\n\nLooks for attached properties (for example \nGrid.Row\n) and validates they exist in the class that they are attempting to use.\n\n\nXaml Node Cannot Be Instantiated\n\n\nChecks that an xml node can be instantiated; xaml elements must resolve to a non-abstract, concrete class implementation.\n\n\nUnknown Static Property Value\n\n\nFor attributes that accept a class object, inspects that the literal value maps to a static property or field in the class type. For example, the \nLayoutOptions\n class has the static fields \nFill\n or \nCentreAndExpand\n that can be used a literal attribute values. If \nCentreAndFill\n was provided (an invalid value), this analyser would inspect the \nLayoutOptions\n class for a static field named \nCentreAndFill\n and trigger an analysis error when it couldn't be found.\n\n\nValidate Value Types\n\n\nInspects the input provided to attributes that expect value types (int, bool, double etc) and validates that the input is valid.\n\n\nXaml Node Resolves\n\n\nChecks that xaml nodes map to a valid .NET symbol.\n\n\nOnPlatform Return Type Mismatch\n\n\nChecks the type returned by a \nXamarin.Forms.OnPlatform\n element is valid with the parent property type.\n\n\nOnIdiom Return Type Mismatch\n\n\nChecks the type returned by a \nXamarin.Forms.OnIdiom\n element is valid with the parent property type.\n\n\nProperty Setter Node Misuse\n\n\nInspects for property setters that don't apply to the outer class. For example, if a developer used OnIdiom.Phone inside a OnPlatform element, the OnIdiom.Phone property setter makes no sense within the given context.\n\n\nDuplicate AutomationIds\n\n\nInspects a Xaml document for occurances of duplicate \nAutomationId\n declarations.\n\n\nEmpty Code Behind Field Declaration\n\n\nInspects occurances of the \nx:Name\n attribute and validates that a value is assigned; empty \nx:Name\n expressions generate an empty named code-behind field, causing compilation errors.\n\n\nRedundant Code Behind Field On Root Node\n\n\nInspects the root Xaml node for a redundant code behind declaration (\nx:Name=\"fieldName\"\n); a code behind field should not be declared on the root element as the code behind class can already be accessed using \nthis\n\n\nDuplicate Namespace Declaration\n\n\nChecks that an xml namespace points to a unique namespace and assembly. For example if both \nxmlns:local=\"clr-namespace:MFractor.Licensing.MobileApp\"\n and \nxmlns:myassembly=\"clr-namespace:MFractor.Licensing.MobileApp\"\n were declared, this analyser would warn that they both reference the same assembly and namespace.\n\n\nCode Behind Class Type Mismatch\n\n\nInspects the type defined by the root Xaml node and compares it against the base type of the code behind class to check for a type-mismatch.\n\n\nRoot Element Defines Code Behind Class\n\n\nChecks that the root xaml node defines a code behind class using the \nx:Class\n directive\n\n\nUnused Resource\n\n\nInspects that resource dictionary entries are used via the \nStaticResource\n markup extension expression within this document.\n\n\nContentView Has Multiple Direct Children\n\n\nInspects usages of the \nContentView\n element and checks that it only has a single child view. Assigning multiple children into a \nContentView\n is a common mistake where the developer usually intended to wrap the chid views with a \nGrid\n or a \nStackLayout\n.\n\n\nContentPage Has Multiple Direct Children\n\n\nInspects usages of \nContentPage\n and checks that it only has a single child view. Assigning multiple children into a \nContentPage\n is a common mistake where the developer usually intended to wrap the chid views with a \nGrid\n or a \nStackLayout\n.\n\n\nInner Element Is Not Resource Dictionary\n\n\nInspects the inner element(s) of a \nMyView.ResourceDictionary\n property setter node  and checks that a resource dictionary is the inner element. It is common to forget to use a resource dictionary before adding resources\n\n\nReferenced Code Behind Field Exists\n\n\nInspects usages of the \nx:Reference\n expression and validates the referenced element has been declared within the document. \nx:Reference\n expressions are used to resolve another Xaml node has a code behind field defined using the \nx:Name\n attribute.", 
            "title": "Xamarin.Forms Xaml Analysis"
        }, 
        {
            "location": "/code-analysis/xaml/#xaml-code-analysis", 
            "text": "Autogenerated by MFractor v3.0.4", 
            "title": "Xaml Code Analysis"
        }, 
        {
            "location": "/code-analysis/xaml/#unused-xml-namespace", 
            "text": "Validate that xmlns attributes that declare a namespace and assembly that is used within the current document.", 
            "title": "Unused Xml Namespace"
        }, 
        {
            "location": "/code-analysis/xaml/#obsolete-property-used", 
            "text": "Checks for attributes that are marked as obsolete/deprecated.", 
            "title": "Obsolete Property Used"
        }, 
        {
            "location": "/code-analysis/xaml/#xname-has-invalid-characters", 
            "text": "Checks that x:Name expressions define a valid code-behind variable name. A value declared by an x:Name attribute must start with a @, _ or a-Z character followed by underscores or alpha-numeric characters.", 
            "title": "x:Name Has Invalid Characters"
        }, 
        {
            "location": "/code-analysis/xaml/#duplicate-code-behind-field-declarations", 
            "text": "Checks that the value assigned to an  x:Name  attribute is unique within the scope of the document.", 
            "title": "Duplicate Code Behind Field Declarations"
        }, 
        {
            "location": "/code-analysis/xaml/#event-handler-exists-in-code-behind-class", 
            "text": "Checks that an event callback referenced referenced by an attribute value exists in the code behind class.", 
            "title": "Event Handler Exists In Code Behind Class"
        }, 
        {
            "location": "/code-analysis/xaml/#event-handler-signature-mismatch", 
            "text": "Checks that the signature for the event callback in a code behind class matches the expected signature for the property it is assigned to.", 
            "title": "Event Handler Signature Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#validate-binding-expressions-return-a-property", 
            "text": "Evaluates a  Binding  expression and validates that it points to property within the binding context. This analyser requires an explict or implicit binding context.", 
            "title": "Validate Binding Expressions Return A Property"
        }, 
        {
            "location": "/code-analysis/xaml/#binding-expressions-resolve", 
            "text": "Inspects  Binding  expressions and validates that the symbol referred to in the binding context exists. This analyser requires an explict or implicit binding context.", 
            "title": "Binding Expressions Resolve"
        }, 
        {
            "location": "/code-analysis/xaml/#binding-expression-return-type-mismatch", 
            "text": "Validates that the .NET symbol returned by a binding expression matches the expected type for the property.", 
            "title": "Binding Expression Return Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#value-converter-input-type-mismatch", 
            "text": "Inspects the  Converter  property of a  Binding expression and validates that the input type is correct. This analyser requires that the  IValueConverter  implementation uses the  ValueConversion  attribute to declare it input type.", 
            "title": "Value Converter Input Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#value-converter-output-type-mismatch", 
            "text": "Inspects the  Converter  component of a  Binding  expression and validates that the returned output type is valid for the parent attribute. This analyser requires that the  IValueConverter  implementation uses the  ValueConversion  attribute to declare it input type.", 
            "title": "Value Converter Output Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#unresolved-net-symbols-within-xaml-expression", 
            "text": "Inspects a .net symbol reference (eg  local:MyClass.MyProperty ) and validates that the symbol portion ('MyClass.MyProperty') resolves to a .NET symbol within the current project and it's references.", 
            "title": "Unresolved .NET Symbols Within Xaml Expression"
        }, 
        {
            "location": "/code-analysis/xaml/#unresolved-namespace-within-xaml-expression", 
            "text": "Inspects a .net symbol reference (eg  local:MyClass.MyProperty ) and validates that the namespace portion ('local') resolves to a xmlns declaration in the current document.", 
            "title": "Unresolved Namespace Within Xaml Expression"
        }, 
        {
            "location": "/code-analysis/xaml/#xstatic-return-type-mismatch", 
            "text": "Validates that the .NET symbol returned by an  x:Static  expressions matches the expected type for the property.", 
            "title": "x:Static Return Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#staticresource-return-type-mismatch", 
            "text": "Validates that the symbol returned by a  StaticResource  expression matches the expected type for the property.", 
            "title": "StaticResource Return Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#undefined-static-resource-usage", 
            "text": "Validates that the element referenced by a  StaticResource  expression resource lookup resolves to a resource defined in the xaml file.", 
            "title": "Undefined Static Resource Usage"
        }, 
        {
            "location": "/code-analysis/xaml/#generic-usage-is-missing-xtypearguments", 
            "text": "Inspects generic classes that are instantiated through Xaml and validates that an  x:TypeArguments  attribute or property assignment node is present.", 
            "title": "Generic Usage Is Missing x:TypeArguments"
        }, 
        {
            "location": "/code-analysis/xaml/#xtypearguments-used-on-non-generic-class", 
            "text": "Inspects for usages of  x:TypeArguments  on elements that are non-generic classes.", 
            "title": "x:TypeArguments Used On Non-Generic Class"
        }, 
        {
            "location": "/code-analysis/xaml/#unknown-type-provided-to-generic", 
            "text": "Inspects usages of  x:TypeArguments  and validates that the type provided exists.", 
            "title": "Unknown Type Provided To Generic"
        }, 
        {
            "location": "/code-analysis/xaml/#referenced-attribute-member-exists-in-parent-type", 
            "text": "Checks that an attribute resolves to a member within its parent type.", 
            "title": "Referenced Attribute Member Exists In Parent Type"
        }, 
        {
            "location": "/code-analysis/xaml/#property-setter-attribute-has-value", 
            "text": "Checks that a value has been provided to an attribute property. This check is skipped if the property type is a string or a valueconverter or type converter is in use.", 
            "title": "Property Setter Attribute Has Value"
        }, 
        {
            "location": "/code-analysis/xaml/#property-node-maps-to-member-in-parent-type", 
            "text": "Checks that a property node resolves to a member within its parent type.", 
            "title": "Property Node Maps To Member In Parent Type"
        }, 
        {
            "location": "/code-analysis/xaml/#property-setter-node-has-value", 
            "text": "Checks that a value has been provided to a node Property setter (EG  MyClass.MyProperty /MyClass.MyProperty ).", 
            "title": "Property Setter Node Has Value"
        }, 
        {
            "location": "/code-analysis/xaml/#property-setter-type-mismatch", 
            "text": "When using MyClass.MyProperty node setter syntax, validate that the inner child node returns a .NET object of the correct type for the property.", 
            "title": "Property Setter Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#duplicate-resource-dictionary-keys", 
            "text": "Validates the each resource entry within a resource dictionary has a unique key.", 
            "title": "Duplicate Resource Dictionary Keys"
        }, 
        {
            "location": "/code-analysis/xaml/#resource-entry-does-not-define-key", 
            "text": "Validates the elements provided to a resource dictionary supply an  x:Key  attribute to declare their resource dictionary key.", 
            "title": "Resource Entry Does Not Define Key"
        }, 
        {
            "location": "/code-analysis/xaml/#missing-microsoft-schema", 
            "text": "Inspects at the root xaml node and verifies that it references the Microsoft Xaml schema:  http://schemas.microsoft.com/winfx/2009/xaml . This schema is required for Xamarin Forms Xaml documents.", 
            "title": "Missing Microsoft Schema"
        }, 
        {
            "location": "/code-analysis/xaml/#unresolved-xml-namespace", 
            "text": "Checks that the namespace used on the xml nodes is defined within the current document.", 
            "title": "Unresolved Xml Namespace"
        }, 
        {
            "location": "/code-analysis/xaml/#unresolved-xmlns-assembly", 
            "text": "Checks that the 'assembly' component of an xmlns statement resolves to an assembly referenced by the project.", 
            "title": "Unresolved Xmlns Assembly"
        }, 
        {
            "location": "/code-analysis/xaml/#class-does-not-have-attached-property", 
            "text": "Looks for attached properties (for example  Grid.Row ) and validates they exist in the class that they are attempting to use.", 
            "title": "Class Does Not Have Attached Property"
        }, 
        {
            "location": "/code-analysis/xaml/#xaml-node-cannot-be-instantiated", 
            "text": "Checks that an xml node can be instantiated; xaml elements must resolve to a non-abstract, concrete class implementation.", 
            "title": "Xaml Node Cannot Be Instantiated"
        }, 
        {
            "location": "/code-analysis/xaml/#unknown-static-property-value", 
            "text": "For attributes that accept a class object, inspects that the literal value maps to a static property or field in the class type. For example, the  LayoutOptions  class has the static fields  Fill  or  CentreAndExpand  that can be used a literal attribute values. If  CentreAndFill  was provided (an invalid value), this analyser would inspect the  LayoutOptions  class for a static field named  CentreAndFill  and trigger an analysis error when it couldn't be found.", 
            "title": "Unknown Static Property Value"
        }, 
        {
            "location": "/code-analysis/xaml/#validate-value-types", 
            "text": "Inspects the input provided to attributes that expect value types (int, bool, double etc) and validates that the input is valid.", 
            "title": "Validate Value Types"
        }, 
        {
            "location": "/code-analysis/xaml/#xaml-node-resolves", 
            "text": "Checks that xaml nodes map to a valid .NET symbol.", 
            "title": "Xaml Node Resolves"
        }, 
        {
            "location": "/code-analysis/xaml/#onplatform-return-type-mismatch", 
            "text": "Checks the type returned by a  Xamarin.Forms.OnPlatform  element is valid with the parent property type.", 
            "title": "OnPlatform Return Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#onidiom-return-type-mismatch", 
            "text": "Checks the type returned by a  Xamarin.Forms.OnIdiom  element is valid with the parent property type.", 
            "title": "OnIdiom Return Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#property-setter-node-misuse", 
            "text": "Inspects for property setters that don't apply to the outer class. For example, if a developer used OnIdiom.Phone inside a OnPlatform element, the OnIdiom.Phone property setter makes no sense within the given context.", 
            "title": "Property Setter Node Misuse"
        }, 
        {
            "location": "/code-analysis/xaml/#duplicate-automationids", 
            "text": "Inspects a Xaml document for occurances of duplicate  AutomationId  declarations.", 
            "title": "Duplicate AutomationIds"
        }, 
        {
            "location": "/code-analysis/xaml/#empty-code-behind-field-declaration", 
            "text": "Inspects occurances of the  x:Name  attribute and validates that a value is assigned; empty  x:Name  expressions generate an empty named code-behind field, causing compilation errors.", 
            "title": "Empty Code Behind Field Declaration"
        }, 
        {
            "location": "/code-analysis/xaml/#redundant-code-behind-field-on-root-node", 
            "text": "Inspects the root Xaml node for a redundant code behind declaration ( x:Name=\"fieldName\" ); a code behind field should not be declared on the root element as the code behind class can already be accessed using  this", 
            "title": "Redundant Code Behind Field On Root Node"
        }, 
        {
            "location": "/code-analysis/xaml/#duplicate-namespace-declaration", 
            "text": "Checks that an xml namespace points to a unique namespace and assembly. For example if both  xmlns:local=\"clr-namespace:MFractor.Licensing.MobileApp\"  and  xmlns:myassembly=\"clr-namespace:MFractor.Licensing.MobileApp\"  were declared, this analyser would warn that they both reference the same assembly and namespace.", 
            "title": "Duplicate Namespace Declaration"
        }, 
        {
            "location": "/code-analysis/xaml/#code-behind-class-type-mismatch", 
            "text": "Inspects the type defined by the root Xaml node and compares it against the base type of the code behind class to check for a type-mismatch.", 
            "title": "Code Behind Class Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#root-element-defines-code-behind-class", 
            "text": "Checks that the root xaml node defines a code behind class using the  x:Class  directive", 
            "title": "Root Element Defines Code Behind Class"
        }, 
        {
            "location": "/code-analysis/xaml/#unused-resource", 
            "text": "Inspects that resource dictionary entries are used via the  StaticResource  markup extension expression within this document.", 
            "title": "Unused Resource"
        }, 
        {
            "location": "/code-analysis/xaml/#contentview-has-multiple-direct-children", 
            "text": "Inspects usages of the  ContentView  element and checks that it only has a single child view. Assigning multiple children into a  ContentView  is a common mistake where the developer usually intended to wrap the chid views with a  Grid  or a  StackLayout .", 
            "title": "ContentView Has Multiple Direct Children"
        }, 
        {
            "location": "/code-analysis/xaml/#contentpage-has-multiple-direct-children", 
            "text": "Inspects usages of  ContentPage  and checks that it only has a single child view. Assigning multiple children into a  ContentPage  is a common mistake where the developer usually intended to wrap the chid views with a  Grid  or a  StackLayout .", 
            "title": "ContentPage Has Multiple Direct Children"
        }, 
        {
            "location": "/code-analysis/xaml/#inner-element-is-not-resource-dictionary", 
            "text": "Inspects the inner element(s) of a  MyView.ResourceDictionary  property setter node  and checks that a resource dictionary is the inner element. It is common to forget to use a resource dictionary before adding resources", 
            "title": "Inner Element Is Not Resource Dictionary"
        }, 
        {
            "location": "/code-analysis/xaml/#referenced-code-behind-field-exists", 
            "text": "Inspects usages of the  x:Reference  expression and validates the referenced element has been declared within the document.  x:Reference  expressions are used to resolve another Xaml node has a code behind field defined using the  x:Name  attribute.", 
            "title": "Referenced Code Behind Field Exists"
        }, 
        {
            "location": "/code-generation/csharp/", 
            "text": "C# Code Generators\n\n\nAutogenerated by MFractor v3.0.4\n\n\nGenerate Assignment Expression\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.member_assignment_expression\n\n\nGenerates an assignment expresssion\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIncludeThisForMembers\n\n\nSystem.Boolean\n\n\nFalse\n\n\nWhen assigning to a class member, should a \nthis.\n be added to the variable being assigned?\n\n\n\n\n\n\n\n\nCreate AttributeUsage Annotation\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.attribute_usage_annotation\n\n\nCreate an \n[System.AttributeUsage()]\n annotation that can can be attached to a class declaration that derives from \nSystem.Attribute\n.\n\n\nGenerate Event Handler Declaration\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.event_handler_declaration\n\n\nGenerates an \nevent EventHandler\nEventArgs\n declaration that can be bound against by a callback.\n\n\nGenerate Event Handler Method Callback\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.event_handler_method\n\n\nGenerates a method that's compatible for registration with an \nEventHandler\nEventArgs\n as a callback.\n\n\nGenerate Instance Property\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.instance_property\n\n\nGenerates a instance property with a getter and setter.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUseBackingFields\n\n\nSystem.Boolean\n\n\nFalse\n\n\nWhen creating the implementation for a property with a public getter and setter, should the property generator create a backing field?\n\n\n\n\n\n\nUnderscoreOnBackingField\n\n\nSystem.Boolean\n\n\nFalse\n\n\nWhen creating a backing field for a property, should the field have an underscore appended to the start of the field name?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Member Initialiser\n\n\n\n\nGenerate Member Initialiser\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.member_initialiser_expression\n\n\nGenerates an initilisation expression for a class/struct member (such as a property or field).\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nForceStringLiteral\n\n\nSystem.Boolean\n\n\nFalse\n\n\nShould the code generator always attempt to assign members with a string literal?\n\n\n\n\n\n\n\n\nCreate Base Constructor\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.base_constructor\n\n\nGenerates a class constructor that routes a series of constructor parameters into a \nbase(...)\n constructor.\n\n\nUses:\n\n\n\n\nCreate Constructor\n\n\n\n\nCreate Constructor\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.constructor\n\n\nGenerates a class constructor, optionally with a set of arguments.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nArgumentFirstLetterToLowerCase\n\n\nSystem.Boolean\n\n\nTrue\n\n\nShould all constructor arguments have their first letter forced to lower case?", 
            "title": "C#"
        }, 
        {
            "location": "/code-generation/csharp/#c-code-generators", 
            "text": "Autogenerated by MFractor v3.0.4", 
            "title": "C# Code Generators"
        }, 
        {
            "location": "/code-generation/csharp/#generate-assignment-expression", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.member_assignment_expression  Generates an assignment expresssion", 
            "title": "Generate Assignment Expression"
        }, 
        {
            "location": "/code-generation/csharp/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      IncludeThisForMembers  System.Boolean  False  When assigning to a class member, should a  this.  be added to the variable being assigned?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/csharp/#create-attributeusage-annotation", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.attribute_usage_annotation  Create an  [System.AttributeUsage()]  annotation that can can be attached to a class declaration that derives from  System.Attribute .", 
            "title": "Create AttributeUsage Annotation"
        }, 
        {
            "location": "/code-generation/csharp/#generate-event-handler-declaration", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.event_handler_declaration  Generates an  event EventHandler EventArgs  declaration that can be bound against by a callback.", 
            "title": "Generate Event Handler Declaration"
        }, 
        {
            "location": "/code-generation/csharp/#generate-event-handler-method-callback", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.event_handler_method  Generates a method that's compatible for registration with an  EventHandler EventArgs  as a callback.", 
            "title": "Generate Event Handler Method Callback"
        }, 
        {
            "location": "/code-generation/csharp/#generate-instance-property", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.instance_property  Generates a instance property with a getter and setter.", 
            "title": "Generate Instance Property"
        }, 
        {
            "location": "/code-generation/csharp/#configurable-properties_1", 
            "text": "Name  Type  Defaults To  Description      UseBackingFields  System.Boolean  False  When creating the implementation for a property with a public getter and setter, should the property generator create a backing field?    UnderscoreOnBackingField  System.Boolean  False  When creating a backing field for a property, should the field have an underscore appended to the start of the field name?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/csharp/#uses", 
            "text": "Generate Member Initialiser", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/csharp/#generate-member-initialiser", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.member_initialiser_expression  Generates an initilisation expression for a class/struct member (such as a property or field).", 
            "title": "Generate Member Initialiser"
        }, 
        {
            "location": "/code-generation/csharp/#configurable-properties_2", 
            "text": "Name  Type  Defaults To  Description      ForceStringLiteral  System.Boolean  False  Should the code generator always attempt to assign members with a string literal?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/csharp/#create-base-constructor", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.base_constructor  Generates a class constructor that routes a series of constructor parameters into a  base(...)  constructor.", 
            "title": "Create Base Constructor"
        }, 
        {
            "location": "/code-generation/csharp/#uses_1", 
            "text": "Create Constructor", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/csharp/#create-constructor", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.constructor  Generates a class constructor, optionally with a set of arguments.", 
            "title": "Create Constructor"
        }, 
        {
            "location": "/code-generation/csharp/#configurable-properties_3", 
            "text": "Name  Type  Defaults To  Description      ArgumentFirstLetterToLowerCase  System.Boolean  True  Should all constructor arguments have their first letter forced to lower case?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/", 
            "text": "Xamarin.Forms C# Code Generators\n\n\nAutogenerated by MFractor v3.0.4\n\n\nGenerate Bindable Property\n\n\nConfiguration Id: com.mfractor.code_gen.forms.csharp.bindable_property\n\n\nGenerates a Xamarin.Forms bindable property implementation and a proxy property that calls the \nBindableProperty\n implementation.\n\n\nGenerate ICommand Implementation\n\n\nConfiguration Id: com.mfractor.code_gen.forms.csharp.command_implementation\n\n\nGenerates a boilerplate implementation of ICommand using Xamarin.Forms.Command\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCommandType\n\n\nSystem.String\n\n\n\"Xamarin.Forms.Command\"\n\n\nThe fully qualified type to use as the command implementation. For example, using \nXamarin.Forms.Command\n would cause the new expression to be \nnew Xamarin.Forms.Command\n\n\n\n\n\n\n\n\nGenerate Value Conversion Attribute\n\n\nConfiguration Id: com.mfractor.code_gen.forms.csharp.value_conversion_attribute\n\n\nGenerates an implementation of the \nValueConversionAttribute\n\n\nGenerate IValueConverter Implementation\n\n\nConfiguration Id: com.mfractor.code_gen.forms.csharp.value_converter\n\n\nGenerates an implementation of a value converter.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIncludeValueConversionAttribute\n\n\nSystem.Boolean\n\n\nFalse\n\n\nIf the generated value converter should automatically have a ValueConversionAttribute added to it to denote it's input and output types.\n\n\n\n\n\n\nCreateMissingValueConversionAttribute\n\n\nSystem.Boolean\n\n\nFalse\n\n\nIf an implementation of the ValueConversionAttribute class cannot be resolved within the project compilation, should MFractor automatically create the implementation?\n\n\n\n\n\n\nNamespace\n\n\nSystem.String\n\n\nNA\n\n\nThe namespace to place new value converters inside. When empty, new value converters will be placed under the projects default namespace.\n\n\n\n\n\n\nFolder\n\n\nSystem.String\n\n\nNA\n\n\nThe folder to place new value converters inside. When empty, new value converters will be placed inside the proejcts root folder.\n\n\n\n\n\n\nImplementConversionForConvert\n\n\nSystem.Boolean\n\n\nFalse\n\n\nWhen creating the body of the \nConvert\n method, should a \nvar input = (InputType)value;* and\nreturn default(OutputType)` be inserted instead of a not implemented exception?\n\n\n\n\n\n\nImplementConversionForConvertBack\n\n\nSystem.Boolean\n\n\nFalse\n\n\nWhen creating the body of the \nConvertBack\n method, should a \nvar input = (OutputType)value;* and\nreturn default(InputType)` be inserted instead of a not implemented exception?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Value Conversion Attribute", 
            "title": "Xamarin.Forms - C#"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#xamarinforms-c-code-generators", 
            "text": "Autogenerated by MFractor v3.0.4", 
            "title": "Xamarin.Forms C# Code Generators"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#generate-bindable-property", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.csharp.bindable_property  Generates a Xamarin.Forms bindable property implementation and a proxy property that calls the  BindableProperty  implementation.", 
            "title": "Generate Bindable Property"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#generate-icommand-implementation", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.csharp.command_implementation  Generates a boilerplate implementation of ICommand using Xamarin.Forms.Command", 
            "title": "Generate ICommand Implementation"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      CommandType  System.String  \"Xamarin.Forms.Command\"  The fully qualified type to use as the command implementation. For example, using  Xamarin.Forms.Command  would cause the new expression to be  new Xamarin.Forms.Command", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#generate-value-conversion-attribute", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.csharp.value_conversion_attribute  Generates an implementation of the  ValueConversionAttribute", 
            "title": "Generate Value Conversion Attribute"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#generate-ivalueconverter-implementation", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.csharp.value_converter  Generates an implementation of a value converter.", 
            "title": "Generate IValueConverter Implementation"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#configurable-properties_1", 
            "text": "Name  Type  Defaults To  Description      IncludeValueConversionAttribute  System.Boolean  False  If the generated value converter should automatically have a ValueConversionAttribute added to it to denote it's input and output types.    CreateMissingValueConversionAttribute  System.Boolean  False  If an implementation of the ValueConversionAttribute class cannot be resolved within the project compilation, should MFractor automatically create the implementation?    Namespace  System.String  NA  The namespace to place new value converters inside. When empty, new value converters will be placed under the projects default namespace.    Folder  System.String  NA  The folder to place new value converters inside. When empty, new value converters will be placed inside the proejcts root folder.    ImplementConversionForConvert  System.Boolean  False  When creating the body of the  Convert  method, should a  var input = (InputType)value;* and return default(OutputType)` be inserted instead of a not implemented exception?    ImplementConversionForConvertBack  System.Boolean  False  When creating the body of the  ConvertBack  method, should a  var input = (OutputType)value;* and return default(InputType)` be inserted instead of a not implemented exception?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#uses", 
            "text": "Generate Value Conversion Attribute", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/xaml/", 
            "text": "Xaml Code Generators\n\n\nAutogenerated by MFractor v3.0.4\n\n\nSort Xaml Attributes\n\n\nConfiguration Id: com.mfractor.code_gen.forms.xaml.sorted_attributes\n\n\nGiven a collection of Xaml attributes this code generator sorts them by namespace and name.\n\n\nRename Xaml Namespace Generator\n\n\nConfiguration Id: com.mfractor.code_gen.forms.xaml.rename_xaml_namespace\n\n\nGenerates a series of replace text fixes to rename a namespace\n\n\nGenerate Grid Column Definition\n\n\nConfiguration Id: com.mfractor.code_gen.forms.xaml.grid_column_definition\n\n\nGenerates a \nColumnDefinition\n Xaml node that is used inside a \nGrid.ColumnDefinitions\n node.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultWidthValue\n\n\nSystem.String\n\n\n\"*\"\n\n\nWhen creating a new \nColumnDefinition\n for a grid, what is the\n\n\n\n\n\n\n\n\nGenerate Grid Row Definition\n\n\nConfiguration Id: com.mfractor.code_gen.forms.xaml.grid_row_definition\n\n\nGenerates a \nRowDefinition\n Xaml node that is used inside a \nGrid.RowDefinitions\n node.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultHeightValue\n\n\nSystem.String\n\n\n\"*\"\n\n\nWhen creating a new \nRowDefinition\n for a grid, what is the default height of a newly created row?", 
            "title": "Xaml"
        }, 
        {
            "location": "/code-generation/xaml/#xaml-code-generators", 
            "text": "Autogenerated by MFractor v3.0.4", 
            "title": "Xaml Code Generators"
        }, 
        {
            "location": "/code-generation/xaml/#sort-xaml-attributes", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.xaml.sorted_attributes  Given a collection of Xaml attributes this code generator sorts them by namespace and name.", 
            "title": "Sort Xaml Attributes"
        }, 
        {
            "location": "/code-generation/xaml/#rename-xaml-namespace-generator", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.xaml.rename_xaml_namespace  Generates a series of replace text fixes to rename a namespace", 
            "title": "Rename Xaml Namespace Generator"
        }, 
        {
            "location": "/code-generation/xaml/#generate-grid-column-definition", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.xaml.grid_column_definition  Generates a  ColumnDefinition  Xaml node that is used inside a  Grid.ColumnDefinitions  node.", 
            "title": "Generate Grid Column Definition"
        }, 
        {
            "location": "/code-generation/xaml/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      DefaultWidthValue  System.String  \"*\"  When creating a new  ColumnDefinition  for a grid, what is the", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xaml/#generate-grid-row-definition", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.xaml.grid_row_definition  Generates a  RowDefinition  Xaml node that is used inside a  Grid.RowDefinitions  node.", 
            "title": "Generate Grid Row Definition"
        }, 
        {
            "location": "/code-generation/xaml/#configurable-properties_1", 
            "text": "Name  Type  Defaults To  Description      DefaultHeightValue  System.String  \"*\"  When creating a new  RowDefinition  for a grid, what is the default height of a newly created row?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/release-notes/v3-1/", 
            "text": "Release Notes - v3.1.0\n\n\nTO BE DECIDED\n\n\nDownload MFractor 3.1.0\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v3.1.0 of MFractor for Visual Studio Mac.\n\n\nFeatures\n\n\nPremium Features\n\n\n\n\nC# Code Actions\n\n\nImplement all of a base classes constructors onto the class. See \nImplement Base Class Constructors\n.\n\n\nWhen a class ends with \nAttribute\n, use the \nMake Class Inherit From System.Attribute\n code action to add attribute inheritance.\n\n\nQuickly assign closely named constructor arguments to fields and properites using the \nAssign Constructor Argument To Member\n C# code action.\n\n\nUse \nAnnotate With Attribute Usage\n to add a \nAttributeUsage\n attribute to a class that inherits from \nSystem.Attribute\n.\n\n\nUse the \nCreate Immutable Constructor\n code action to generate a constructor that initialises all readonly fields from constructor arguments.\n\n\n\n\n\n\nAndroid C# Code Diagnostics\n\n\nDetect when a developer tries to manually create an \nActivity\n with new statement. See \nIncorrect Activity Creation\n.\n\n\nDetect when a developer directly implements the \nIJavaObject\n interface instead of inheriting from \nJava.Lang.Object\n. See \nClass Derives From IJavaObject\n.\n\n\nDetect when a subclass of \nAndroid.App.Application\n is missing the peer connection constructor. See \nApplication Requires Peer Connection Constructor\n.\n\n\n\n\n\n\nXamarin.Forms C# Code Diagnostics\n\n\nWhen using the \nExportRendererAttribute\n, validate that the first argument is a view or view cell and the second argument is a renderer. See \nIncorrect Activity Creation\n.\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nAdded a \nFeedback\n menu into the \nHelp\n -\n \nMFractor\n menu. Use this menu to file bug reports and feature requests.\n\n\n\n\nBug Fixes\n\n\n\n\nFixed: Often the Xaml analyser would fail to remove code-issue markers.", 
            "title": "v3.1"
        }, 
        {
            "location": "/release-notes/v3-1/#release-notes-v310", 
            "text": "TO BE DECIDED  Download MFractor 3.1.0", 
            "title": "Release Notes - v3.1.0"
        }, 
        {
            "location": "/release-notes/v3-1/#introduction", 
            "text": "This is a summary of the changes introduced in v3.1.0 of MFractor for Visual Studio Mac.", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v3-1/#features", 
            "text": "", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v3-1/#premium-features", 
            "text": "C# Code Actions  Implement all of a base classes constructors onto the class. See  Implement Base Class Constructors .  When a class ends with  Attribute , use the  Make Class Inherit From System.Attribute  code action to add attribute inheritance.  Quickly assign closely named constructor arguments to fields and properites using the  Assign Constructor Argument To Member  C# code action.  Use  Annotate With Attribute Usage  to add a  AttributeUsage  attribute to a class that inherits from  System.Attribute .  Use the  Create Immutable Constructor  code action to generate a constructor that initialises all readonly fields from constructor arguments.    Android C# Code Diagnostics  Detect when a developer tries to manually create an  Activity  with new statement. See  Incorrect Activity Creation .  Detect when a developer directly implements the  IJavaObject  interface instead of inheriting from  Java.Lang.Object . See  Class Derives From IJavaObject .  Detect when a subclass of  Android.App.Application  is missing the peer connection constructor. See  Application Requires Peer Connection Constructor .    Xamarin.Forms C# Code Diagnostics  When using the  ExportRendererAttribute , validate that the first argument is a view or view cell and the second argument is a renderer. See  Incorrect Activity Creation .", 
            "title": "Premium Features"
        }, 
        {
            "location": "/release-notes/v3-1/#enhancements", 
            "text": "Added a  Feedback  menu into the  Help  -   MFractor  menu. Use this menu to file bug reports and feature requests.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v3-1/#bug-fixes", 
            "text": "Fixed: Often the Xaml analyser would fail to remove code-issue markers.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v3-0/", 
            "text": "Release Notes - v3.0.0\n\n\n23rd May 2017\n\n\nDownload MFractor 3.0.0\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v3.0.0 of MFractor for Visual Studio Mac.\n\n\nThis release supports Visual Studio for Mac.\n\n\nThis release adds the ability to control MFractor through configuration files; this enables developers to change MFractor's behavior when refactoring, analyzing and generating code.\n\n\nFeatures\n\n\n\n\nVisual Studio For Mac Support!\n\n\nPremium Only\n The new config file system enables customization the code generated by MFractor. Create a new file with the extension \n.mfc\n or \n.mfc.xml\n in your project and influence MFractor's internals using the \nconfigure id=\"com.mfractor.XXX\"/\n and \nproperty name=\"Name\" value=\"Value\"/\n syntax. A full tutorial on configuration is [available here].\n\n\nNew Code Analysers\n\n\nDetect when a \nContentView\n has multiple child elements.\n\n\nDetect when a \nContentPage\n has multiple child elements.\n\n\nDetect when a \nMyView.Resources\n resource dictionary setter contains anything but a \nResourceDictionary\n declaration.\n\n\n\n\n\n\nNew Code Generators\n\n\nWhen on a \nGrid.RowDefinitions\n element, the new code generator \nAdd RowDefinition\n will insert a new row definition element.\n\n\nWhen on a \nGrid.ColumnDefinitions\n element, the new code generator \nAdd ColumnDefinition\n will insert a new column definition element.\n\n\n\n\n\n\nNew Code Organisation\n\n\nWhen the root xaml node has unused namespaces, activate \nRemoved Unused Namespaces\n to cleanup all unused xaml namespaces.\n\n\n\n\n\n\nNew Code Fixes\n\n\nWhen a \nMyView.Resources\n property setter contains anything but a \nResourceDictionary\n declaration allow the user to wrap the element declarations with a resource dictionary.\n\n\nWhen the result of a binding expression does not match the input type of the outer attribute and a value converter has a \nValueConversion\n that resolves it, generate a \nConverter=\n expression and import the value converter as resource.\n\n\nWhen the result of a binding expression does not match the input type of the outer attribute, generate an \nIValueConverter\n implementation that resolves the type-flow, generate a \nConverter=\n expression and import the value converter as resource.\n\n\n\n\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nAndroid Layout analysis and IntelliSense has been disabled. It interfered with the stock Xamarin IntelliSense and regressed the layout editors user experience. This will be revisited at a later date.\n\n\nOnly show code fixes in the quick fix menu when it's activated over a code issue. This reduces noise and improves usability.\n\n\nIn Xaml, color literals (EG: #AAA) are now underlined with the color value. This makes it easy to visually see the color at a glance.\n\n\nPress \nAlt+Shift+1\n to jump to the \nview model\n for a code behind or xaml view.\n\n\nPress \nAlt+Shift+2\n to jump to the \ncode behind\n for a view model or xaml view.\n\n\nPress \nAlt+Shift+3\n to jump to the \nxaml view\n for a code behind or view model.\n\n\nSignificantly improved speed/performance of the MVVM navigation shortcut suite.\n\n\nThe \nSimply Static Assignment\n organise code action has been removed as it added no tangible value.\n\n\n\n\nBug Fixes\n\n\n\n\nFixed: Passing \n.\n into a binding expression to reference the binding context would cause an analysis error. Using \n.\n will now correctly resolve to the binding context.\n\n\nFixed: MFractor now detects when the \nBindingContext\n of a Xaml element is specified using a property setter node (\nView.BindingContext\n \nvm:MyViewModel\n \n/View.BindingContext\n).\n\n\nFixed: Generate code files into shared projects when the source xaml is in a shared project.\n\n\nFixed: Don't allow view model creation from the App.xaml.\n\n\nFixed: Don't check for x:Key attributes on \nStyle/\n elements; no x:Key means the style is the implicit control style.\n\n\nFixed: Detect .NET symbol references that are within attributes whose type is \nSystem.Type\n to include them in namespace refactoring and unused namespace detection.", 
            "title": "v3.0"
        }, 
        {
            "location": "/release-notes/v3-0/#release-notes-v300", 
            "text": "23rd May 2017  Download MFractor 3.0.0", 
            "title": "Release Notes - v3.0.0"
        }, 
        {
            "location": "/release-notes/v3-0/#introduction", 
            "text": "This is a summary of the changes introduced in v3.0.0 of MFractor for Visual Studio Mac.  This release supports Visual Studio for Mac.  This release adds the ability to control MFractor through configuration files; this enables developers to change MFractor's behavior when refactoring, analyzing and generating code.", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v3-0/#features", 
            "text": "Visual Studio For Mac Support!  Premium Only  The new config file system enables customization the code generated by MFractor. Create a new file with the extension  .mfc  or  .mfc.xml  in your project and influence MFractor's internals using the  configure id=\"com.mfractor.XXX\"/  and  property name=\"Name\" value=\"Value\"/  syntax. A full tutorial on configuration is [available here].  New Code Analysers  Detect when a  ContentView  has multiple child elements.  Detect when a  ContentPage  has multiple child elements.  Detect when a  MyView.Resources  resource dictionary setter contains anything but a  ResourceDictionary  declaration.    New Code Generators  When on a  Grid.RowDefinitions  element, the new code generator  Add RowDefinition  will insert a new row definition element.  When on a  Grid.ColumnDefinitions  element, the new code generator  Add ColumnDefinition  will insert a new column definition element.    New Code Organisation  When the root xaml node has unused namespaces, activate  Removed Unused Namespaces  to cleanup all unused xaml namespaces.    New Code Fixes  When a  MyView.Resources  property setter contains anything but a  ResourceDictionary  declaration allow the user to wrap the element declarations with a resource dictionary.  When the result of a binding expression does not match the input type of the outer attribute and a value converter has a  ValueConversion  that resolves it, generate a  Converter=  expression and import the value converter as resource.  When the result of a binding expression does not match the input type of the outer attribute, generate an  IValueConverter  implementation that resolves the type-flow, generate a  Converter=  expression and import the value converter as resource.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v3-0/#enhancements", 
            "text": "Android Layout analysis and IntelliSense has been disabled. It interfered with the stock Xamarin IntelliSense and regressed the layout editors user experience. This will be revisited at a later date.  Only show code fixes in the quick fix menu when it's activated over a code issue. This reduces noise and improves usability.  In Xaml, color literals (EG: #AAA) are now underlined with the color value. This makes it easy to visually see the color at a glance.  Press  Alt+Shift+1  to jump to the  view model  for a code behind or xaml view.  Press  Alt+Shift+2  to jump to the  code behind  for a view model or xaml view.  Press  Alt+Shift+3  to jump to the  xaml view  for a code behind or view model.  Significantly improved speed/performance of the MVVM navigation shortcut suite.  The  Simply Static Assignment  organise code action has been removed as it added no tangible value.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v3-0/#bug-fixes", 
            "text": "Fixed: Passing  .  into a binding expression to reference the binding context would cause an analysis error. Using  .  will now correctly resolve to the binding context.  Fixed: MFractor now detects when the  BindingContext  of a Xaml element is specified using a property setter node ( View.BindingContext   vm:MyViewModel   /View.BindingContext ).  Fixed: Generate code files into shared projects when the source xaml is in a shared project.  Fixed: Don't allow view model creation from the App.xaml.  Fixed: Don't check for x:Key attributes on  Style/  elements; no x:Key means the style is the implicit control style.  Fixed: Detect .NET symbol references that are within attributes whose type is  System.Type  to include them in namespace refactoring and unused namespace detection.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v2/", 
            "text": "**IMPORTANT: MFractor v2 is only supported on Xamarin Studio. To use MFractor in Visual Studio Mac, please install \nMFractor v3 and above\n.\n\n\nRelease Notes - v2.10.0\n\n\n6th March 2017\n\n\nDownload MFractor 2.10.2\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.10.2 of MFractor for Visual Studio Mac.\n\n\nThis release is all about improving MFractors usability. You can now tap Alt+Return in Xaml documents to quickly access any fixes or refactorings at that location, the xaml analyser has been tuned for speed and a new code issue tooltip gives deeper insight into the code issue beneath it:\n\n\n\n\nFeatures\n\n\n\n\nThe quick fix menu is now available to quickly access all Xaml actions. Tap Alt+Return in your Xaml document for a list of available code actions to appear!\n\n\nThe xaml analyser integration has been rebuilt and as such, xaml analysis is now much, much quicker. You might notice that fixable issues no longer underline in yellow; the check for available fixes is now.\n\n\nAn improved code issue tooltip now appears when you hover over a xaml or android resource. This tooltip tells you what kind of error it is (Compile time, runtime or code improvement), presents information on the issue and let's you know if any fixes are available.\n\n\n\n\nEnhancements\n\n\n\n\nImprove the can execute checking algorithms for all code actions (refactorings, issue fixes etc) to reduce the noise in the quick fix menu.\n\n\n\n\nBug Fixes\n\n\n\n\nFixed: When generating a view model and the view has bindings against an unknown class, previously these bindings would be missed.\n\n\n\n\n##Release Notes - v2.9.4\n\n\n22nd February 2017\n\n\nDownload MFractor 2.9.4\n\n\n##Introduction\n\n\nThis is a summary of the changes introduced in v2.9.4 of MFractor for Visual Studio Mac.\n\n\nImportant: If Visual Studio Mac loses IntelliSense/Code Completion when you update to cycle 9 (XS v6.2), uninstall MFractor and upgrade to the latest version\n\n\nThis release focuses on keeping your Xaml tidy... you can now rename xaml namespaces, align the naming of duplicate namespace imports and format your entire Xaml document.\n\n\nIt's also easier than ever to build out custom controls, the new \nImplement Missing Members\n code generator can bulk implement properties or bindable properties onto custom views in your Xaml. No need to hand code bindable properties!\n\n\nHold onto your socks!\n\n\n\n\n##Features\n\n\n- **New Refactorings**\n - Right click on an `xmlns` declaration on the root node and select **Refactor** -\n **Rename Xaml Namespace** to rename all occurrences of that namespace in the doc!\n- **New Code Organisers**\n - Right click on the root xaml node and select **Organise** -\n **Format** to organise your entire xaml document.\n- **New Code Generators**\n - Quickly build out Grids by using the **Insert Row Definitions** and **Insert Column Definitions** actions.\n - Bulk implement missing properties on a class by right clicking on the xaml node with the missing members and selecting **Implement missing members**.\n- **New Xaml Analysers**\n - Detect if the root xaml element uses a `x:Name` attribute as this is redundant.\n - Detect duplicate xaml namespaces that reference the same namespace and assembly.\n - Detect when the xaml views code behind class derives from a different type than what is declared by it's root element.\n- **New Code Fixes**\n - When a xaml namespace references the same namespace and assembly, you can now rename all duplicate namespace declarations to a certain namespace to align the usages in your xaml.\n\n\n\n##Enhancements\n\n\n\n\nFreshMVVM style page models (EG: LoginPageModel) are now supported for view \n-\n view model \n-\n code behind association.\n\n\nThe \nModel\n suffix (EG: LoginModel) is now supported for view \n-\n view model \n-\n code behind association.\n\n\nThis release targets Visual Studio Mac v6.2.\n\n\n\n\n##Bug Fixes\n\n\n\n\nUndefined StaticResource detection has been disabled in this release.\n\n\nFixed: When generating view models, if a binding expression was within an undefined control property, the refactoring would fail as it could not resolve the member type. Undefined properties will now auto-generate using \nSystem.Object\n.\n\n\nFixed: When generating a static property from an x:Static expression whose outer attribute is unresolved, now default to use \nSystem.Object\n.\n\n\nFixed: When generating members or static properties onto a code behind class, sometimes the insertion point would jump to the xaml.g.cs auto-generated class.\n\n\nFixed: When the Visual Studio Mac Xamarin Forms Previewer is open, the refactoring engine would fail to commit text replace changes.\n\n\n\n\n##Release Notes - v2.8.0\n\n\n12th February 2017\n\n\nDownload MFractor 2.8.0\n\n\n##Introduction\n\n\nThis is a summary of the changes introduced in v2.8.0 of MFractor for Visual Studio Mac.\n\n\nThis release focuses on adding new refactoring and code generation actions into the Xaml editor.\n\n\nYou can now sort your xaml, edit colors interactively, extract values into binding expressions and more:\n\n\n\n\n##Features\n\n\n - **New Refactorings**\n  - Right click on a xaml attribute property that's a `System.Drawing.Color` or a `Xamarin.Forms.Color` and edit it using the color selection dialog. This action won't be available if the attribute value is an expression.\n  - Right click on a xaml attribute property that has a literal value and extract it into a `Binding` expression. This action is not available if the attribute value is an expression or the attribute does not have a corresponding bindable property.\n  - **Organise Refactorings:**\n      - The *Collapse Xaml Attributes* refactoring will collapse all xaml attributes onto the same line as the parent xaml node.\n      - The *Expand Xaml Attributes* refactoring will expand all xaml attributes onto separate lines.\n      - The *Sort Xaml Attributes* refactoring will sort the attributes for a xaml node by namespace and name.\n      - The *Expand Node* refactoring takes a self-closing xaml node and generate a closing tag for it.\n      - The *Collapse Node* refactoring takes a xaml node with no children and a closing tag and removes the closing tag to make the node self-closing.\n - **New Code Generators**\n  - Right click on an xaml node that inherits from `Xamarin.Forms.VisualElement` or `Xamarin.Forms.Application` and select **Add Resource Dictionary** to generate a resource dictionary for that element.\n - **New Xaml Analysers**\n  - Detect when an `x:Name` code-behind field declaration is empty.\n\n\n\n##Enhancements\n\n\n\n\nThis release targets Visual Studio Mac v6.1.5\n\n\nThe \nImplement View Model\n refactoring has been moved from the \nRefactor\n menu to \nGenerate\n.\n\n\nHover over a xaml attribute property that's a \nSystem.Drawing.Color\n or a \nXamarin.Forms.Color\n to see the color value inside the tooltip.\n\n\nThe Android SDK meta-data has been removed from MFractor.mpack; you can download and update the sdk meta-data through the \nHelp\n -\n \nMFractor\n -\n \nInstall Android SDK Meta-Data\n menu item.\n\n\n\n\n##Bug Fixes\n\n\n\n\nCorrectly validate the type provided to x:TypeArguments; there was a bug in the type checking algorithm.\n\n\nDon't allow the 'Simplify' refactoring to run against expressions.\n\n\nFix multiple type conversion checking bugs in the ValueConversion attribute validation.\n\n\n\n\n##Release Notes - v2.7.0\n\n\n8th January 2017\n\n\nDownload MFractor 2.7.0\n\n\n##Introduction\n\n\nThis is a summary of the changes introduced in v2.7.0 of MFractor for Visual Studio Mac.\n\n\nThis release adds the ability implement entire view models, introduces a dozen xaml analysers and fixes many bugs.\n\n\nI recommend taking a moment to read these tutorials:\n\n\n* [Implementing View Models](/xamarin-forms/implementing-view-models.md): Learn implement entire view models using the **Implement View Model** refactoring.\n* [Value Converter Type Safety](/xamarin-forms/value-converter-type-safety.md): Learn to annotate `IValueConverter`s with value conversion attributes for `Converter` expression type-safety.\n\n\n\n##Introducing View Model Generation\n\n\nYou already love being able to generate bindings but I've taken it to the next level this release \ud83d\udcaa\n\n\n\n\nGot a heap of unimplemented bindings? Right click anywhere in your Xaml document and select \nRefactor\n -\n \nImplement View Model\n.\n\n\nMFractor will collect all the missing bindings and then generate a new class with \nall\n of those properties into a namespace named \nMyDefaultNamespace.ViewModels\n.\n\n\nDoes the view model already exist? Then MFractor simply inserts the missing bindings into the existing view model.\n\n\nI think it'll save you enough time during the week that you may just get to Friday beers a few hours early \ud83c\udf7b\n\n\n##Features\n\n\n- By right clicking anywhere in a Xaml document, implement all missing bindings as a new or into an existing view model:\n    - Implement view model properties with a getter and setter.\n    - Implement view model properties with a backing field.\n    - Bound properties that return `ICommand` will have an empty `Xamarin.Forms.Command` instance generated.\n    - When MFractor encounters binding expressions that use a `Converter`, it inspects the converter for a `ValueConversion` attribute to deduce the input typed required. If it can't resolve the converter or the converter does not have value conversion information, it will default to using `System.Object`.\n    - When implementing a new view model with getter and setters, MFractor will inspect for references to Fody's `ImplementPropertyChanged` and annotate the new class with it.\n- **New Xaml Analysers:**\n    - Validate that elements declared inside a resource dictionary have an x:Key.\n    - Validate that elements declared inside a resource dictionary have a unique x:Key value.\n    - Detect when an x:TypeArguments is used on a non-generic type and warn of incorrect usage.\n    - Detect when a property setter node (`\nMyClass.MyProperty/\n`) references a non-existent member on the parent class.\n    - Detect when a property setter attribute is empty.\n    - Detect when an undefined static resource is referenced by a `StaticResource` expression.\n    - Detect when the value returned by a `StaticResource` expression causes a type mismatch.\n    - Detect when an unknown type is being provided to a `x:TypeArguments` attribute.\n    - Validate that `OnIdiom` elements return the correct type for the outer property setter.\n    - Validate that `OnPlatform` elements return the correct type for the outer property setter.\n    - Detect when a developer has misused a property setter inside another xaml element. For example, `OnIdiom.Phone` doesn't make any sense when wrapped by the outer element `OnPlatform`.\n    - Detect when an incorrect input type is provided to a `Converter`. The value converter must have a `ValueConversion` attribute for this to trigger.\n    - Detect when an incorrect output type is returned by a `Converter` expression. The value converter must have a `ValueConversion` attribute for this to trigger.\n    - Detect when multiple occurrences of the same automation ID exists within a Xaml document.\n- **New Xaml Fixes:**\n    - Generate missing resource dictionary keys.\n    - Auto-correct misspelt `StaticResource` references.\n- **New Simplify Refactorings:**\n    - Attributes that use a static instance to initialize the property (eg `VerticalOptions=\"LayoutOptions.CentreAndExpand\"`) can now be simplified to just the instance name (eg `VerticalOptions=\"CentreAndExpand\"`).\n\n\n\n##Enhancements\n\n\n- This release targets Visual Studio Mac v6.1.3\n- The **About MFractor** dialog now contains a button to copy version and IDE information into the clipboard for bug reports. See [Support - Filing A Bug Report](/faq.md#how-do-i-file-a-bug-report) for more information on filing a bug report.\n- This release introduces the framework for an Xml and Xaml refactoring engine. Over time, I'll be adding Xml and Xaml refactoring operations to make code cleanup a breeze.\n- Annotating value converters with a `ValueConversion(typeof(InputType), typeof(OutputType))` attribute will trigger the conversion information to render into tooltip. See [FormsCommunityToolkit.Converters](https://github.com/FormsCommunityToolkit/Converters) for examples.\n\n\n\n##Bug Fixes\n\n\n- Sometimes the Xaml document analyser would fail to load and bring down the Xaml editor. This has been fixed.\n- The View \n - \n Code Behind navigation shortcuts would break when an AST parse was in progress. View \n - \n Code Behind shortcuts will now always be active.\n- When property setter nodes are used (`\nMyClass.MyProperty/\n`), the class component is now correctly validated.\n- When importing a Xaml namespace, the element is inserted on a newline and formatted to align with other attributes.\n- When resolving the binding context for nested DataTemplates, sometimes the binding context resolver would fail on generics or IEnumerables\n- More resilient Mvvm resolver to drive the 'Go To View Model', 'Go To Xaml View' and 'Go To Code Behind' shortcuts. MFractor will attempt to infer as best possible the associations between those 3 files.\n- Save the project after adding a new file to it.\n\n\n##Release Notes - v2.6.0\n\n**31st October 2016**\n\n**[Download MFractor 2.6.0](http://addins.mfractor.com/releases/2.06.00/MFractor.MFractor_2.06.00.mpack)**\n\n##Introduction\n\nThis is a summary of the changes introduced in v2.6.0 of MFractor for Visual Studio Mac.\n\nAs a major release, this release adds several code generation capabilities to improve your Xaml workflow. Generate views, classes and value converters in only a few clicks...\n\nJust right click on that little yellow squiggle and use the fix to generate a whole lotta code.\n\nThere are also more xaml code checks to watch out for nasty Xaml issues and bug fixes galore.\n\nEnjoy!\n\n##Features\n\n - **New code generation actions:**\n    - Generate classes from `\nmy_namespace:MyMissingClass\n` in xaml.\n    - Generate views from `\nmy_namespace:MyMissingView\n` in xaml.\n    - Generate value converters when a missing xaml node ends with \"[cC]onverter] in xaml.\n - **New Xaml analysers:**\n    - For generics, validate that an x:TypeArguments attribute or xml node setter exists.\n    - For generics, validate that the count of parameters provided to x:TypeArguments matches the generics signature.\n    - Validate the root xaml node contains an x:Class directive to set the code behind class name and namespace.\n\n##Enhancements\n\n - This release targets Visual Studio Mac v6.1.1\n\n## Bug Fixes\n\n - Fix a bug in xaml namespace resolution that prevented the \"import new xmlns\" fix from triggering.\n - Allow importing of xaml namespaces from x:Static symbols.\n - For Setters, don't validate TargetType property that the provided type is a static member of System.Type.\n - When a symbol name matches but its in the wrong namespace, don't suggest it as a fix.\n - Remove the MFractor settings panel to fix the Visual Studio Mac preferences dialog from not opening when it didn't exist.\n - When using native view declaration, the xaml symbolicator will now honor the targetPlatform flag and find the assembly for that platform. Previously this was a naive search that used the first assembly found; using the wrong symbols if a assembly of the same name existed in both an iOS and Android project.\n\n\n ##Release Notes - v2.5.3\n\n **10th of October 2016**\n\n **[Download MFractor 2.5.0](http://addins.mfractor.com/releases/2.06.00/MFractor.MFractor_2.06.00.mpack)**\n\n ##Introduction\n\n This is a summary of the changes introduced in v2.5.3 of MFractor for Visual Studio Mac.\n\n This release adds support for native view declaration and property generation for missing view attributes.\n\n ##Features\n\n  - Generate properties and bindable properties onto classes that implement Xamarin.Forms.ObservableObject.\n  - Full support for native view declaration. Tooltips, go-to declaration, xaml analysis and code generation enabled on native views used in Xaml.\n\n ##Bug Fixes\n\n  - Xaml expressions now parsed on attributes that cannot be resolved to a .NET symbol. This enables Tooltips, go-to declaration, xaml analysis and code generation.\n  - The analysis engine no longer assumes that the Xamarin.Forms and Microsoft schemas are the implicit and 'x' namespaces. This means that Xamarin.Forms could be remapped to xmlns:xf etc and the xaml analyser will still function correctly.", 
            "title": "v2"
        }, 
        {
            "location": "/release-notes/v2/#release-notes-v2100", 
            "text": "6th March 2017  Download MFractor 2.10.2", 
            "title": "Release Notes - v2.10.0"
        }, 
        {
            "location": "/release-notes/v2/#introduction", 
            "text": "This is a summary of the changes introduced in v2.10.2 of MFractor for Visual Studio Mac.  This release is all about improving MFractors usability. You can now tap Alt+Return in Xaml documents to quickly access any fixes or refactorings at that location, the xaml analyser has been tuned for speed and a new code issue tooltip gives deeper insight into the code issue beneath it:", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2/#features", 
            "text": "The quick fix menu is now available to quickly access all Xaml actions. Tap Alt+Return in your Xaml document for a list of available code actions to appear!  The xaml analyser integration has been rebuilt and as such, xaml analysis is now much, much quicker. You might notice that fixable issues no longer underline in yellow; the check for available fixes is now.  An improved code issue tooltip now appears when you hover over a xaml or android resource. This tooltip tells you what kind of error it is (Compile time, runtime or code improvement), presents information on the issue and let's you know if any fixes are available.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2/#enhancements", 
            "text": "Improve the can execute checking algorithms for all code actions (refactorings, issue fixes etc) to reduce the noise in the quick fix menu.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v2/#bug-fixes", 
            "text": "Fixed: When generating a view model and the view has bindings against an unknown class, previously these bindings would be missed.   ##Release Notes - v2.9.4  22nd February 2017  Download MFractor 2.9.4  ##Introduction  This is a summary of the changes introduced in v2.9.4 of MFractor for Visual Studio Mac.  Important: If Visual Studio Mac loses IntelliSense/Code Completion when you update to cycle 9 (XS v6.2), uninstall MFractor and upgrade to the latest version  This release focuses on keeping your Xaml tidy... you can now rename xaml namespaces, align the naming of duplicate namespace imports and format your entire Xaml document.  It's also easier than ever to build out custom controls, the new  Implement Missing Members  code generator can bulk implement properties or bindable properties onto custom views in your Xaml. No need to hand code bindable properties!  Hold onto your socks!   ##Features  - **New Refactorings**\n - Right click on an `xmlns` declaration on the root node and select **Refactor** -  **Rename Xaml Namespace** to rename all occurrences of that namespace in the doc!\n- **New Code Organisers**\n - Right click on the root xaml node and select **Organise** -  **Format** to organise your entire xaml document.\n- **New Code Generators**\n - Quickly build out Grids by using the **Insert Row Definitions** and **Insert Column Definitions** actions.\n - Bulk implement missing properties on a class by right clicking on the xaml node with the missing members and selecting **Implement missing members**.\n- **New Xaml Analysers**\n - Detect if the root xaml element uses a `x:Name` attribute as this is redundant.\n - Detect duplicate xaml namespaces that reference the same namespace and assembly.\n - Detect when the xaml views code behind class derives from a different type than what is declared by it's root element.\n- **New Code Fixes**\n - When a xaml namespace references the same namespace and assembly, you can now rename all duplicate namespace declarations to a certain namespace to align the usages in your xaml.  ##Enhancements   FreshMVVM style page models (EG: LoginPageModel) are now supported for view  -  view model  -  code behind association.  The  Model  suffix (EG: LoginModel) is now supported for view  -  view model  -  code behind association.  This release targets Visual Studio Mac v6.2.   ##Bug Fixes   Undefined StaticResource detection has been disabled in this release.  Fixed: When generating view models, if a binding expression was within an undefined control property, the refactoring would fail as it could not resolve the member type. Undefined properties will now auto-generate using  System.Object .  Fixed: When generating a static property from an x:Static expression whose outer attribute is unresolved, now default to use  System.Object .  Fixed: When generating members or static properties onto a code behind class, sometimes the insertion point would jump to the xaml.g.cs auto-generated class.  Fixed: When the Visual Studio Mac Xamarin Forms Previewer is open, the refactoring engine would fail to commit text replace changes.   ##Release Notes - v2.8.0  12th February 2017  Download MFractor 2.8.0  ##Introduction  This is a summary of the changes introduced in v2.8.0 of MFractor for Visual Studio Mac.  This release focuses on adding new refactoring and code generation actions into the Xaml editor.  You can now sort your xaml, edit colors interactively, extract values into binding expressions and more:   ##Features   - **New Refactorings**\n  - Right click on a xaml attribute property that's a `System.Drawing.Color` or a `Xamarin.Forms.Color` and edit it using the color selection dialog. This action won't be available if the attribute value is an expression.\n  - Right click on a xaml attribute property that has a literal value and extract it into a `Binding` expression. This action is not available if the attribute value is an expression or the attribute does not have a corresponding bindable property.\n  - **Organise Refactorings:**\n      - The *Collapse Xaml Attributes* refactoring will collapse all xaml attributes onto the same line as the parent xaml node.\n      - The *Expand Xaml Attributes* refactoring will expand all xaml attributes onto separate lines.\n      - The *Sort Xaml Attributes* refactoring will sort the attributes for a xaml node by namespace and name.\n      - The *Expand Node* refactoring takes a self-closing xaml node and generate a closing tag for it.\n      - The *Collapse Node* refactoring takes a xaml node with no children and a closing tag and removes the closing tag to make the node self-closing.\n - **New Code Generators**\n  - Right click on an xaml node that inherits from `Xamarin.Forms.VisualElement` or `Xamarin.Forms.Application` and select **Add Resource Dictionary** to generate a resource dictionary for that element.\n - **New Xaml Analysers**\n  - Detect when an `x:Name` code-behind field declaration is empty.  ##Enhancements   This release targets Visual Studio Mac v6.1.5  The  Implement View Model  refactoring has been moved from the  Refactor  menu to  Generate .  Hover over a xaml attribute property that's a  System.Drawing.Color  or a  Xamarin.Forms.Color  to see the color value inside the tooltip.  The Android SDK meta-data has been removed from MFractor.mpack; you can download and update the sdk meta-data through the  Help  -   MFractor  -   Install Android SDK Meta-Data  menu item.   ##Bug Fixes   Correctly validate the type provided to x:TypeArguments; there was a bug in the type checking algorithm.  Don't allow the 'Simplify' refactoring to run against expressions.  Fix multiple type conversion checking bugs in the ValueConversion attribute validation.   ##Release Notes - v2.7.0  8th January 2017  Download MFractor 2.7.0  ##Introduction  This is a summary of the changes introduced in v2.7.0 of MFractor for Visual Studio Mac.  This release adds the ability implement entire view models, introduces a dozen xaml analysers and fixes many bugs.  I recommend taking a moment to read these tutorials:  * [Implementing View Models](/xamarin-forms/implementing-view-models.md): Learn implement entire view models using the **Implement View Model** refactoring.\n* [Value Converter Type Safety](/xamarin-forms/value-converter-type-safety.md): Learn to annotate `IValueConverter`s with value conversion attributes for `Converter` expression type-safety.  ##Introducing View Model Generation  You already love being able to generate bindings but I've taken it to the next level this release \ud83d\udcaa   Got a heap of unimplemented bindings? Right click anywhere in your Xaml document and select  Refactor  -   Implement View Model .  MFractor will collect all the missing bindings and then generate a new class with  all  of those properties into a namespace named  MyDefaultNamespace.ViewModels .  Does the view model already exist? Then MFractor simply inserts the missing bindings into the existing view model.  I think it'll save you enough time during the week that you may just get to Friday beers a few hours early \ud83c\udf7b  ##Features  - By right clicking anywhere in a Xaml document, implement all missing bindings as a new or into an existing view model:\n    - Implement view model properties with a getter and setter.\n    - Implement view model properties with a backing field.\n    - Bound properties that return `ICommand` will have an empty `Xamarin.Forms.Command` instance generated.\n    - When MFractor encounters binding expressions that use a `Converter`, it inspects the converter for a `ValueConversion` attribute to deduce the input typed required. If it can't resolve the converter or the converter does not have value conversion information, it will default to using `System.Object`.\n    - When implementing a new view model with getter and setters, MFractor will inspect for references to Fody's `ImplementPropertyChanged` and annotate the new class with it.\n- **New Xaml Analysers:**\n    - Validate that elements declared inside a resource dictionary have an x:Key.\n    - Validate that elements declared inside a resource dictionary have a unique x:Key value.\n    - Detect when an x:TypeArguments is used on a non-generic type and warn of incorrect usage.\n    - Detect when a property setter node (` MyClass.MyProperty/ `) references a non-existent member on the parent class.\n    - Detect when a property setter attribute is empty.\n    - Detect when an undefined static resource is referenced by a `StaticResource` expression.\n    - Detect when the value returned by a `StaticResource` expression causes a type mismatch.\n    - Detect when an unknown type is being provided to a `x:TypeArguments` attribute.\n    - Validate that `OnIdiom` elements return the correct type for the outer property setter.\n    - Validate that `OnPlatform` elements return the correct type for the outer property setter.\n    - Detect when a developer has misused a property setter inside another xaml element. For example, `OnIdiom.Phone` doesn't make any sense when wrapped by the outer element `OnPlatform`.\n    - Detect when an incorrect input type is provided to a `Converter`. The value converter must have a `ValueConversion` attribute for this to trigger.\n    - Detect when an incorrect output type is returned by a `Converter` expression. The value converter must have a `ValueConversion` attribute for this to trigger.\n    - Detect when multiple occurrences of the same automation ID exists within a Xaml document.\n- **New Xaml Fixes:**\n    - Generate missing resource dictionary keys.\n    - Auto-correct misspelt `StaticResource` references.\n- **New Simplify Refactorings:**\n    - Attributes that use a static instance to initialize the property (eg `VerticalOptions=\"LayoutOptions.CentreAndExpand\"`) can now be simplified to just the instance name (eg `VerticalOptions=\"CentreAndExpand\"`).  ##Enhancements  - This release targets Visual Studio Mac v6.1.3\n- The **About MFractor** dialog now contains a button to copy version and IDE information into the clipboard for bug reports. See [Support - Filing A Bug Report](/faq.md#how-do-i-file-a-bug-report) for more information on filing a bug report.\n- This release introduces the framework for an Xml and Xaml refactoring engine. Over time, I'll be adding Xml and Xaml refactoring operations to make code cleanup a breeze.\n- Annotating value converters with a `ValueConversion(typeof(InputType), typeof(OutputType))` attribute will trigger the conversion information to render into tooltip. See [FormsCommunityToolkit.Converters](https://github.com/FormsCommunityToolkit/Converters) for examples.  ##Bug Fixes  - Sometimes the Xaml document analyser would fail to load and bring down the Xaml editor. This has been fixed.\n- The View   -   Code Behind navigation shortcuts would break when an AST parse was in progress. View   -   Code Behind shortcuts will now always be active.\n- When property setter nodes are used (` MyClass.MyProperty/ `), the class component is now correctly validated.\n- When importing a Xaml namespace, the element is inserted on a newline and formatted to align with other attributes.\n- When resolving the binding context for nested DataTemplates, sometimes the binding context resolver would fail on generics or IEnumerables\n- More resilient Mvvm resolver to drive the 'Go To View Model', 'Go To Xaml View' and 'Go To Code Behind' shortcuts. MFractor will attempt to infer as best possible the associations between those 3 files.\n- Save the project after adding a new file to it.\n\n\n##Release Notes - v2.6.0\n\n**31st October 2016**\n\n**[Download MFractor 2.6.0](http://addins.mfractor.com/releases/2.06.00/MFractor.MFractor_2.06.00.mpack)**\n\n##Introduction\n\nThis is a summary of the changes introduced in v2.6.0 of MFractor for Visual Studio Mac.\n\nAs a major release, this release adds several code generation capabilities to improve your Xaml workflow. Generate views, classes and value converters in only a few clicks...\n\nJust right click on that little yellow squiggle and use the fix to generate a whole lotta code.\n\nThere are also more xaml code checks to watch out for nasty Xaml issues and bug fixes galore.\n\nEnjoy!\n\n##Features\n\n - **New code generation actions:**\n    - Generate classes from ` my_namespace:MyMissingClass ` in xaml.\n    - Generate views from ` my_namespace:MyMissingView ` in xaml.\n    - Generate value converters when a missing xaml node ends with \"[cC]onverter] in xaml.\n - **New Xaml analysers:**\n    - For generics, validate that an x:TypeArguments attribute or xml node setter exists.\n    - For generics, validate that the count of parameters provided to x:TypeArguments matches the generics signature.\n    - Validate the root xaml node contains an x:Class directive to set the code behind class name and namespace.\n\n##Enhancements\n\n - This release targets Visual Studio Mac v6.1.1\n\n## Bug Fixes\n\n - Fix a bug in xaml namespace resolution that prevented the \"import new xmlns\" fix from triggering.\n - Allow importing of xaml namespaces from x:Static symbols.\n - For Setters, don't validate TargetType property that the provided type is a static member of System.Type.\n - When a symbol name matches but its in the wrong namespace, don't suggest it as a fix.\n - Remove the MFractor settings panel to fix the Visual Studio Mac preferences dialog from not opening when it didn't exist.\n - When using native view declaration, the xaml symbolicator will now honor the targetPlatform flag and find the assembly for that platform. Previously this was a naive search that used the first assembly found; using the wrong symbols if a assembly of the same name existed in both an iOS and Android project.\n\n\n ##Release Notes - v2.5.3\n\n **10th of October 2016**\n\n **[Download MFractor 2.5.0](http://addins.mfractor.com/releases/2.06.00/MFractor.MFractor_2.06.00.mpack)**\n\n ##Introduction\n\n This is a summary of the changes introduced in v2.5.3 of MFractor for Visual Studio Mac.\n\n This release adds support for native view declaration and property generation for missing view attributes.\n\n ##Features\n\n  - Generate properties and bindable properties onto classes that implement Xamarin.Forms.ObservableObject.\n  - Full support for native view declaration. Tooltips, go-to declaration, xaml analysis and code generation enabled on native views used in Xaml.\n\n ##Bug Fixes\n\n  - Xaml expressions now parsed on attributes that cannot be resolved to a .NET symbol. This enables Tooltips, go-to declaration, xaml analysis and code generation.\n  - The analysis engine no longer assumes that the Xamarin.Forms and Microsoft schemas are the implicit and 'x' namespaces. This means that Xamarin.Forms could be remapped to xmlns:xf etc and the xaml analyser will still function correctly.", 
            "title": "Bug Fixes"
        }
    ]
}