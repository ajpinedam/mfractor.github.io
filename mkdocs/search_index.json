{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome\n\n\nHey there fellow Xamarin developer!\n\n\nWelcome to the documentation for MFractor, incredible Xamarin tools.\n\n\nMFractor adds several features so you can make great Xamarin.Forms apps faster:\n\n\n\n\nA xaml analyser turns runtime crashes into in-editor code warnings.\n\n\nA code generation engine auto-magically creates boilerplate code in a few clicks instead of a few hundred keystrokes.\n\n\nSeveral navigation improvements remove the friction of navigating your apps source code.\n\n\n\n\nSlowly, I am building the ReSharper for Xamarin Studio and I'm thrilled that you have joined me on the journey.\n\n\nTo get started, checkout:\n\n\n\n\nThe Xamarin.Forms Quickstart Guide\n\n\nThe Xamarin.Android Quickstart Guide\n\n\n\n\nIf something doesn't work quite right or you'd like a sweet new feature added, be patient and contact me:\n\n\n\n\nVia Twitter: Give me a holla at \n@matthewrdev\n\n\nVia Slack: Drop in to chat anytime in the \n#mfractor Xamarin Slack sub-channel\n.\n\n\nVia Email: Shot an email to hello@mfractor.com\n\n\n\n\nFinally, thank you for installing and using MFractor. It means the world to me.\n\n\nMatthew Robbins - Creator of MFractor. \u270c\ufe0f", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome", 
            "text": "Hey there fellow Xamarin developer!  Welcome to the documentation for MFractor, incredible Xamarin tools.  MFractor adds several features so you can make great Xamarin.Forms apps faster:   A xaml analyser turns runtime crashes into in-editor code warnings.  A code generation engine auto-magically creates boilerplate code in a few clicks instead of a few hundred keystrokes.  Several navigation improvements remove the friction of navigating your apps source code.   Slowly, I am building the ReSharper for Xamarin Studio and I'm thrilled that you have joined me on the journey.  To get started, checkout:   The Xamarin.Forms Quickstart Guide  The Xamarin.Android Quickstart Guide   If something doesn't work quite right or you'd like a sweet new feature added, be patient and contact me:   Via Twitter: Give me a holla at  @matthewrdev  Via Slack: Drop in to chat anytime in the  #mfractor Xamarin Slack sub-channel .  Via Email: Shot an email to hello@mfractor.com   Finally, thank you for installing and using MFractor. It means the world to me.  Matthew Robbins - Creator of MFractor. \u270c\ufe0f", 
            "title": "Welcome"
        }, 
        {
            "location": "/setup/", 
            "text": "Setup\n\n\nInstalling, activating and updating MFractor\n\n\nIntroduction\n\n\nThis document covers how to install, activate and update MFractor for Xamarin Studio.\n\n\nInstall MFractor\n\n\nThe simplest way to install MFractor into Xamarin Studio is by using the MFractor.Installer helper addin.\n\n\nThis addin lives inside the Addin Manager in Xamarin Studio, under \nGallery\n -\n \nIDE extensions\n.\n\n\nOpen up Xamarin Studio and click on the \nXamarin Studio\n then \nAddins...\n\n\n\n\nOnce the Addin Manager opens, click \nGallery\n and under \nIDE extensions\n locate \nMFractor.Installer\n. If this isn't present, hit the \nRefresh\n button to update the Gallery listings.\n\n\n\n\nOnce you've located \nMFractor.Installer\n, left click on it to select it. In the right hand detail view, click \nInstall\n. Xamarin Studio will prompt you for confirmation, click \nInstall\n\n\n\n\nYou will then see a download dialog appear and MFractor will download and install!\n\n\n\n\nNext we need to activate MFractor.\n\n\nActivation\n\n\nAfter installing MFractor, you'll need activate it using your email address.\n\n\nFirst things first, \nclose the Addin Manager\n. There is a known bug that blocks the email entry field from receiving keyboard when the Addin Manager is open. It's a pain and we are working on fixing this.\n\n\nTo activate MFractor, enter you email and then click \nActivate\n.\n\n\n\n\nTada! You are now ready to rock. Why not learn how to use MFractor for \nXamarin.Forms\n or \nXamarin.Android\n next?\n\n\nUpdating\n\n\nMFractor will receive regular updates adding sweet new features and bug fixes so it's important to keep up to date!\n\n\nWhen MFractor installs into Xamarin Studio, it'll register itself into Xamarin Studios addin updater.\n\n\nThis means that Xamarin Studio \nshould\n automatically prompt you that an update is available.\n\n\nHowever, you can check for udpate at any time by opening the \nXamarin Studio\n main menu and selecting \nCheck for Updates...\n\n\n\n\nXamarin Studio will check the MFractor addin server for updates and prompt you to update if there is a new version!\n\n\nUninstalling MFractor\n\n\nYou can uninstall MFractor through the addin manager at any time. We'll be sad to see you go!\n\n\nSelect the \nXamarin Studio\n main menu and then \nAddins\n\n\nUnder \nGallery\n then \nIDE extensions\n select the MFractor addin list item and then click \nUninstall\n\n\nYou will be prompted to uninstall the addin, confirm uninstallation by clicking \nUninstall", 
            "title": "Setup"
        }, 
        {
            "location": "/setup/#setup", 
            "text": "Installing, activating and updating MFractor", 
            "title": "Setup"
        }, 
        {
            "location": "/setup/#introduction", 
            "text": "This document covers how to install, activate and update MFractor for Xamarin Studio.", 
            "title": "Introduction"
        }, 
        {
            "location": "/setup/#install-mfractor", 
            "text": "The simplest way to install MFractor into Xamarin Studio is by using the MFractor.Installer helper addin.  This addin lives inside the Addin Manager in Xamarin Studio, under  Gallery  -   IDE extensions .  Open up Xamarin Studio and click on the  Xamarin Studio  then  Addins...   Once the Addin Manager opens, click  Gallery  and under  IDE extensions  locate  MFractor.Installer . If this isn't present, hit the  Refresh  button to update the Gallery listings.   Once you've located  MFractor.Installer , left click on it to select it. In the right hand detail view, click  Install . Xamarin Studio will prompt you for confirmation, click  Install   You will then see a download dialog appear and MFractor will download and install!   Next we need to activate MFractor.", 
            "title": "Install MFractor"
        }, 
        {
            "location": "/setup/#activation", 
            "text": "After installing MFractor, you'll need activate it using your email address.  First things first,  close the Addin Manager . There is a known bug that blocks the email entry field from receiving keyboard when the Addin Manager is open. It's a pain and we are working on fixing this.  To activate MFractor, enter you email and then click  Activate .   Tada! You are now ready to rock. Why not learn how to use MFractor for  Xamarin.Forms  or  Xamarin.Android  next?", 
            "title": "Activation"
        }, 
        {
            "location": "/setup/#updating", 
            "text": "MFractor will receive regular updates adding sweet new features and bug fixes so it's important to keep up to date!  When MFractor installs into Xamarin Studio, it'll register itself into Xamarin Studios addin updater.  This means that Xamarin Studio  should  automatically prompt you that an update is available.  However, you can check for udpate at any time by opening the  Xamarin Studio  main menu and selecting  Check for Updates...   Xamarin Studio will check the MFractor addin server for updates and prompt you to update if there is a new version!", 
            "title": "Updating"
        }, 
        {
            "location": "/setup/#uninstalling-mfractor", 
            "text": "You can uninstall MFractor through the addin manager at any time. We'll be sad to see you go!  Select the  Xamarin Studio  main menu and then  Addins  Under  Gallery  then  IDE extensions  select the MFractor addin list item and then click  Uninstall  You will be prompted to uninstall the addin, confirm uninstallation by clicking  Uninstall", 
            "title": "Uninstalling MFractor"
        }, 
        {
            "location": "/support/", 
            "text": "WORK IN PROGRESS\n\n\nSupport\n\n\nIf something doesn't work quite right or you'd like a sweet new feature added, be patient and contact me:\n\n\n\n\nVia Twitter: Give me a holla at \n@matthewrdev\n\n\nVia Slack: Drop in to chat anytime in the \n#mfractor Xamarin Slack sub-channel\n.\n\n\nVia Email: Shot an email to hello@mfractor.com", 
            "title": "Support"
        }, 
        {
            "location": "/support/#support", 
            "text": "If something doesn't work quite right or you'd like a sweet new feature added, be patient and contact me:   Via Twitter: Give me a holla at  @matthewrdev  Via Slack: Drop in to chat anytime in the  #mfractor Xamarin Slack sub-channel .  Via Email: Shot an email to hello@mfractor.com", 
            "title": "Support"
        }, 
        {
            "location": "/xamarin-forms-quickstart/", 
            "text": "Xamarin.Forms Quick Start\n\n\nLearn to use the most handy features in MFractor for Xamarin.Forms\n\n\nIntroduction\n\n\nWelcome to the quickstart guide for using MFractor with Xamarin.Forms.\n\n\nThis document is a short reference of the most useful features of MFractor for Xamarin.Forms.\n\n\nConfiguring A Binding Context\n\n\nWhen the \nBindingContext\n property is explicitly set for a Xaml view, MFractor can analyse binding expressions and perform refactoring from Xaml to the binding context.\n\n\nWe explicitly configure the binding context using a view model locator:\n\n\nView Model Locator\n\n\npublic namespace MyApp\n{\n  public static class ViewModelLocator\n  {\n      public static readonly LoginViewModel LoginViewModel = new LoginViewModel();\n  }\n}\n\n\n\n\nLoginPage.xaml\n\n\nContentPage\n  xmlns:local=\nclr-namespace:MyApp;assembly=MyApp\n\n  BindingContext=\n{x:Static local:ViewModelLocator.LoginViewModel}\n/\n\n\n\n\n\nFor more detail, see \nConfigure Binding Context\n.\n\n\nMvvm Naming Conventions\n\n\nImplicitly associate a view to a ViewModel using these naming conventions:\n\n\n\n\nClasses that end with \nViewModel\n are assumed to be a view model for a Xaml view.\n\n\nXaml files that end with \nPage\n or \nView\n are assumed to be a xaml view for a view model.\n\n\nWhen a view and view model share the same name without \nPage\n, \nView\n or \nViewModel\n, MFractor assumes an implicit association.\n\n\n\n\nConsider \nLoginPage.xaml\n, \nLoginPage.xaml.cs\n and \nLoginViewMode.cs\n:\n\n\n\n\nLoginPage.xaml\n is considered a xaml view.\n\n\nLoginPage.xaml.cs\n is considered the code behind class.\n\n\nLoginViewModel.cs\n is considered the view model.\n\n\n\n\nFor more detail, see \nImplicit Binding Context Resolution\n.\n\n\nUsing Mvvm Navigation\n\n\nWe can quickly navigate between Views, Code Behind Class and ViewModel when we use the \nMvvm naming conventions\n.\n\n\nRight click and select:\n\n\n\n\nXaml Analysis\n\n\nFixing Code Issues\n\n\nGenerating ViewModel Bindings\n\n\nImplementing ViewModels", 
            "title": "Xamarin.Forms Quickstart"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#xamarinforms-quick-start", 
            "text": "Learn to use the most handy features in MFractor for Xamarin.Forms", 
            "title": "Xamarin.Forms Quick Start"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#introduction", 
            "text": "Welcome to the quickstart guide for using MFractor with Xamarin.Forms.  This document is a short reference of the most useful features of MFractor for Xamarin.Forms.", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#configuring-a-binding-context", 
            "text": "When the  BindingContext  property is explicitly set for a Xaml view, MFractor can analyse binding expressions and perform refactoring from Xaml to the binding context.  We explicitly configure the binding context using a view model locator:  View Model Locator  public namespace MyApp\n{\n  public static class ViewModelLocator\n  {\n      public static readonly LoginViewModel LoginViewModel = new LoginViewModel();\n  }\n}  LoginPage.xaml  ContentPage\n  xmlns:local= clr-namespace:MyApp;assembly=MyApp \n  BindingContext= {x:Static local:ViewModelLocator.LoginViewModel} /   For more detail, see  Configure Binding Context .", 
            "title": "Configuring A Binding Context"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#mvvm-naming-conventions", 
            "text": "Implicitly associate a view to a ViewModel using these naming conventions:   Classes that end with  ViewModel  are assumed to be a view model for a Xaml view.  Xaml files that end with  Page  or  View  are assumed to be a xaml view for a view model.  When a view and view model share the same name without  Page ,  View  or  ViewModel , MFractor assumes an implicit association.   Consider  LoginPage.xaml ,  LoginPage.xaml.cs  and  LoginViewMode.cs :   LoginPage.xaml  is considered a xaml view.  LoginPage.xaml.cs  is considered the code behind class.  LoginViewModel.cs  is considered the view model.   For more detail, see  Implicit Binding Context Resolution .", 
            "title": "Mvvm Naming Conventions"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#using-mvvm-navigation", 
            "text": "We can quickly navigate between Views, Code Behind Class and ViewModel when we use the  Mvvm naming conventions .  Right click and select:", 
            "title": "Using Mvvm Navigation"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#xaml-analysis", 
            "text": "", 
            "title": "Xaml Analysis"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#fixing-code-issues", 
            "text": "", 
            "title": "Fixing Code Issues"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#generating-viewmodel-bindings", 
            "text": "", 
            "title": "Generating ViewModel Bindings"
        }, 
        {
            "location": "/xamarin-forms-quickstart/#implementing-viewmodels", 
            "text": "", 
            "title": "Implementing ViewModels"
        }, 
        {
            "location": "/xamarin-android-quickstart/", 
            "text": "WORK IN PROGRESS\n\n\nXamarin.Android Quickstart\n\n\nLearn to use the most handy features in MFractor for Xamarin.Android\n\n\nIntroduction\n\n\nProject Resource Indexing\n\n\nResource tooltips\n\n\nGo-To Resource Declaration\n\n\nResource IntelliSense\n\n\nResource Analysis\n\n\nFind All Resource References\n\n\nC# Code Analysis For Android", 
            "title": "Xamarin.Android Quickstart"
        }, 
        {
            "location": "/xamarin-android-quickstart/#xamarinandroid-quickstart", 
            "text": "Learn to use the most handy features in MFractor for Xamarin.Android", 
            "title": "Xamarin.Android Quickstart"
        }, 
        {
            "location": "/xamarin-android-quickstart/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-android-quickstart/#project-resource-indexing", 
            "text": "", 
            "title": "Project Resource Indexing"
        }, 
        {
            "location": "/xamarin-android-quickstart/#resource-tooltips", 
            "text": "", 
            "title": "Resource tooltips"
        }, 
        {
            "location": "/xamarin-android-quickstart/#go-to-resource-declaration", 
            "text": "", 
            "title": "Go-To Resource Declaration"
        }, 
        {
            "location": "/xamarin-android-quickstart/#resource-intellisense", 
            "text": "", 
            "title": "Resource IntelliSense"
        }, 
        {
            "location": "/xamarin-android-quickstart/#resource-analysis", 
            "text": "", 
            "title": "Resource Analysis"
        }, 
        {
            "location": "/xamarin-android-quickstart/#find-all-resource-references", 
            "text": "", 
            "title": "Find All Resource References"
        }, 
        {
            "location": "/xamarin-android-quickstart/#c-code-analysis-for-android", 
            "text": "", 
            "title": "C# Code Analysis For Android"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/", 
            "text": "Configuring A Binding Context\n\n\nPower the refactoring engine and xaml analyser by targeting a binding context\n\n\nIntroduction\n\n\nIn Mvvm architected applications, views use a \nBinding Context\n to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through \ndata binding\n; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts \nThe Mvvm Pattern\n article.\n\n\nWhen working with Xaml, we can specify a binding context to activate . If MFractor can resolve a binding context for a Xaml view, it will consume binding expressions and analyse them.\n\n\nThis is tremendously beneficial as MFractor will pickup runtime errors and high-light them directly within the Xaml editor.\n\n\nWe can specify a binding context \nexplicitly\n via in inline Xaml expression or \nimplicitly\n through the use of common MVVM naming conventions.\n\n\nExplicit Binding Context Resolution\n\n\nLet's start with explicitly providing a binding context to MFractor.\n\n\nIn Xamarin.Forms, all views have the property \nBindingContext\n; this specifies the object that a view should data-bind with. When coding with Xaml, we can use the \nx:Static\n markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context:\n\n\n \nEntry BindingContext=\n{x:Static local:MyStaticClass.MyStaticProperty}\n/\n\n\n\n\n\nThis is known as the \nView Model Locator Pattern\n. We implement a static class named \nViewModelLocator\n and use a static, readonly property to return an instance of the object we want our Xaml view to data-bind with. Historically the \nView Model Locator Pattern\n has been used to provide design time data to the Xamarin.Forms Xaml previewer. For a deeper insight into this pattern, read James Montemagnos excellent \nView Model Locator\n article.\n\n\nFor example, given a Xaml page named \nLoginPage\n, we could explicitly provide an instance of \nLoginViewModel\n as the binding context like so:\n\n\nView Model Locator\n\n\npublic namespace MyApp\n{\n  public static class ViewModelLocator\n  {\n      public static readonly LoginViewModel LoginViewModel = new LoginViewModel();\n  }\n}\n\n\n\n\nLoginPage.xaml\n\n\nContentPage\n  xmlns:local=\nclr-namespace:MyApp;assembly=MyApp\n\n  BindingContext=\n{x:Static local:ViewModelLocator.LoginViewModel}\n/\n\n\n\n\n\nWhen MFractor begins analysis on LoginPage.xaml it will check if any \nBindingContext\n properties have been assigned to. As the root \nContentPage\n assigns a binding context, it will inspect the value component of the \nBindingContext\n attribute, check if it is a Xaml expression and then evaluate it for the return type.\n\n\nFor the \n{x:Static local:ViewModelLocator.LoginViewModel}\n expression, MFractor will resolve the \nViewModelLocator\n class in the \nlocal\n namespace and then grab the C# type of the \nLoginViewModel\n property. This informs MFractor that the page will be bound to a \nLoginViewModel\n instance and therefore to analyse all \nBinding\n expressions against the \nLoginViewModel\n type.\n\n\nExplicit binding context resolution will also work when referencing another element using \nx:Reference\n expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so:\n\n\n  \nSwitch x:Name=\nmySwitch\n /\n\n  \nLabel BindingContext=\n{x:Reference mySwitch}\n IsVisible=\n{Binding IsToggled}\n/\n\n\n\n\n\nWhen MFractor analyses the \n{Binding IsToggled}\n expression, it will evaluate the \n{x:Reference mySwitch}\n expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch).\n\n\nImplicit Binding Context Resolution\n\n\nIn addition to explicit binding context resolution, MFractor will attempt to infer the relationship between your view models and xaml views via \nimplicit binding context resolution\n. This is done by looking for classes and Xaml views that share a common naming convention.\n\n\nLet's consider the following files:\n\n\n\n\nLoginPage.xaml\n - The xaml view.\n\n\nLoginPage.xaml.cs\n - The code behind for the xaml view.\n\n\nLoginViewModel\n - The a C# class that is the view model for the LoginPage view.\n\n\n\n\n\n\nBecause these pages share the prefix \nLogin\n and each has a distinct file extension or suffix, we can infer the following relationships:\n\n\n\n\nThe \n.xaml\n extension denotes that \nLoginPage.xaml\n is a xaml view.\n\n\nThe \n.xaml.cs\n extension and the \nLoginPage\n component denotes that \nLoginPage.xaml.cs\n is the code behind implementation \nLoginPage\n view.\n\n\nThe \nViewModel\n suffix implies that \nLoginViewModel\n is a view model. When \nViewModel\n is removed from \nLoginViewModel\n and \nPage\n is removed from \nLoginPage\n, the \nLogin\n component implies that the \nLoginViewModel\n is related to the \nLoginPage\n xaml view and it's code behind file.\n\n\n\n\nMFractor uses these common naming conventions of Page.xaml, Page.xaml.cs and ViewModel to decide that \nLoginViewModel\n will probably be the BindingContext for \nLoginPage\n. It will then\n\n\nThe following suffixes are supported for Xaml views:\n\n\n\n\nPage\n: EG LoginPage.xaml \n-\n LoginViewModel\n\n\nView\n: EG LoginView.xaml \n-\n LoginViewModel\n\n\n\n\nExplicit binding context resolution will \nalways\n override implicit binding context resolution. If your xaml views are named using the conventions listed above but your page or a view explicitly assigns the \nBindingContext\n property then MFractor will use the \nBindingContext\n return type instead of the implicit Mvvm relationship.\n\n\nData Template Binding Context Resolution\n\n\nData templates are used to provide a nested Xaml view to a view that displays many occurances of that view. For example, a ListView uses a \nDataTemplate\n to specify the view appearance of each instance provided through the \nItemsSource\n property.\n\n\nMFractor will attempt to infer the BindingContext for a data templates view by resolving the \nItemsSource\n property on the wrapping view.\n\n\nConsider the following code:\n\n\n  \nListView ItemsSource=\n{Binding Contacts}\n\n      \nListView.ItemTemplate\n\n        \nDataTemplate\n\n          \nTextCell Text=\n{Binding DisplayName}\n /\n\n        \n/DataTemplate\n\n      \n/ListView.ItemTemplate\n\n  \n/ListView\n\n\n\n\n\nThe inner \nDataTemplate\n has a \nTextCell\n where the \nText\n property is provided by the binding expression \n{Binding DisplayName}\n. To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the \nItemsSource\n property and evaluate the expression.\n\n\nWhen the return type is an \nIEnumerable\n or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.\n\n\nSummary\n\n\nIn summary, we've learnt that MFractor will use the binding context to power the Xaml analyser and navigation improvements.\n\n\n\n\nBinding expressions require a binding context to be analysed.\n\n\nWe can explicitly specify a binding context by assigning the \nBindingContext\n property of any Xaml element.\n\n\nWhen we name our code files using the Page.xaml, Page.xaml.cs and ViewModel convention, MFractor will assume an implicit MVVM relationship.\n\n\nData templates use the return type of the wrapping views \nItemSource\n property.", 
            "title": "Configure Binding Context"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#configuring-a-binding-context", 
            "text": "Power the refactoring engine and xaml analyser by targeting a binding context", 
            "title": "Configuring A Binding Context"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#introduction", 
            "text": "In Mvvm architected applications, views use a  Binding Context  to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through  data binding ; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts  The Mvvm Pattern  article.  When working with Xaml, we can specify a binding context to activate . If MFractor can resolve a binding context for a Xaml view, it will consume binding expressions and analyse them.  This is tremendously beneficial as MFractor will pickup runtime errors and high-light them directly within the Xaml editor.  We can specify a binding context  explicitly  via in inline Xaml expression or  implicitly  through the use of common MVVM naming conventions.", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#explicit-binding-context-resolution", 
            "text": "Let's start with explicitly providing a binding context to MFractor.  In Xamarin.Forms, all views have the property  BindingContext ; this specifies the object that a view should data-bind with. When coding with Xaml, we can use the  x:Static  markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context:    Entry BindingContext= {x:Static local:MyStaticClass.MyStaticProperty} /   This is known as the  View Model Locator Pattern . We implement a static class named  ViewModelLocator  and use a static, readonly property to return an instance of the object we want our Xaml view to data-bind with. Historically the  View Model Locator Pattern  has been used to provide design time data to the Xamarin.Forms Xaml previewer. For a deeper insight into this pattern, read James Montemagnos excellent  View Model Locator  article.  For example, given a Xaml page named  LoginPage , we could explicitly provide an instance of  LoginViewModel  as the binding context like so:  View Model Locator  public namespace MyApp\n{\n  public static class ViewModelLocator\n  {\n      public static readonly LoginViewModel LoginViewModel = new LoginViewModel();\n  }\n}  LoginPage.xaml  ContentPage\n  xmlns:local= clr-namespace:MyApp;assembly=MyApp \n  BindingContext= {x:Static local:ViewModelLocator.LoginViewModel} /   When MFractor begins analysis on LoginPage.xaml it will check if any  BindingContext  properties have been assigned to. As the root  ContentPage  assigns a binding context, it will inspect the value component of the  BindingContext  attribute, check if it is a Xaml expression and then evaluate it for the return type.  For the  {x:Static local:ViewModelLocator.LoginViewModel}  expression, MFractor will resolve the  ViewModelLocator  class in the  local  namespace and then grab the C# type of the  LoginViewModel  property. This informs MFractor that the page will be bound to a  LoginViewModel  instance and therefore to analyse all  Binding  expressions against the  LoginViewModel  type.  Explicit binding context resolution will also work when referencing another element using  x:Reference  expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so:     Switch x:Name= mySwitch  / \n   Label BindingContext= {x:Reference mySwitch}  IsVisible= {Binding IsToggled} /   When MFractor analyses the  {Binding IsToggled}  expression, it will evaluate the  {x:Reference mySwitch}  expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch).", 
            "title": "Explicit Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#implicit-binding-context-resolution", 
            "text": "In addition to explicit binding context resolution, MFractor will attempt to infer the relationship between your view models and xaml views via  implicit binding context resolution . This is done by looking for classes and Xaml views that share a common naming convention.  Let's consider the following files:   LoginPage.xaml  - The xaml view.  LoginPage.xaml.cs  - The code behind for the xaml view.  LoginViewModel  - The a C# class that is the view model for the LoginPage view.    Because these pages share the prefix  Login  and each has a distinct file extension or suffix, we can infer the following relationships:   The  .xaml  extension denotes that  LoginPage.xaml  is a xaml view.  The  .xaml.cs  extension and the  LoginPage  component denotes that  LoginPage.xaml.cs  is the code behind implementation  LoginPage  view.  The  ViewModel  suffix implies that  LoginViewModel  is a view model. When  ViewModel  is removed from  LoginViewModel  and  Page  is removed from  LoginPage , the  Login  component implies that the  LoginViewModel  is related to the  LoginPage  xaml view and it's code behind file.   MFractor uses these common naming conventions of Page.xaml, Page.xaml.cs and ViewModel to decide that  LoginViewModel  will probably be the BindingContext for  LoginPage . It will then  The following suffixes are supported for Xaml views:   Page : EG LoginPage.xaml  -  LoginViewModel  View : EG LoginView.xaml  -  LoginViewModel   Explicit binding context resolution will  always  override implicit binding context resolution. If your xaml views are named using the conventions listed above but your page or a view explicitly assigns the  BindingContext  property then MFractor will use the  BindingContext  return type instead of the implicit Mvvm relationship.", 
            "title": "Implicit Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#data-template-binding-context-resolution", 
            "text": "Data templates are used to provide a nested Xaml view to a view that displays many occurances of that view. For example, a ListView uses a  DataTemplate  to specify the view appearance of each instance provided through the  ItemsSource  property.  MFractor will attempt to infer the BindingContext for a data templates view by resolving the  ItemsSource  property on the wrapping view.  Consider the following code:     ListView ItemsSource= {Binding Contacts} \n       ListView.ItemTemplate \n         DataTemplate \n           TextCell Text= {Binding DisplayName}  / \n         /DataTemplate \n       /ListView.ItemTemplate \n   /ListView   The inner  DataTemplate  has a  TextCell  where the  Text  property is provided by the binding expression  {Binding DisplayName} . To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the  ItemsSource  property and evaluate the expression.  When the return type is an  IEnumerable  or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.", 
            "title": "Data Template Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#summary", 
            "text": "In summary, we've learnt that MFractor will use the binding context to power the Xaml analyser and navigation improvements.   Binding expressions require a binding context to be analysed.  We can explicitly specify a binding context by assigning the  BindingContext  property of any Xaml element.  When we name our code files using the Page.xaml, Page.xaml.cs and ViewModel convention, MFractor will assume an implicit MVVM relationship.  Data templates use the return type of the wrapping views  ItemSource  property.", 
            "title": "Summary"
        }, 
        {
            "location": "/xamarin-forms/navigation/", 
            "text": "Navigation\n\n\nMove efficiently through a Xamarin.Forms project with rich Xaml code navigation\n\n\nIntroduction\n\n\nMFractor enriches the navigation between C# and Xaml code by adding a few handy shortcuts. We can:\n\n\n\n\nQuickly cycle between views, code behind classes and view models with the Mvvm shortcuts.\n\n\nJump to .NET symbols from Xaml with Go-To Symbol support.\n\n\nHover over any xaml element to see a .NET tooltip along with its included documentation\n\n\nPreview images through image tooltips when we hover over an image source value.\n\n\n\n\nMvvm Navigation\n\n\nWhen MFractor can \nimplicitly resolve the View - Code Behind Class - ViewModel relationship\n, the Mvvm navigation shortcut suite is activatated.\n\n\nWe can access these shortcuts by right clicking\n\n\nXaml Go-To Symbol\n\n\nXaml Tooltips\n\n\nImage Tooltips", 
            "title": "Navigation"
        }, 
        {
            "location": "/xamarin-forms/navigation/#navigation", 
            "text": "Move efficiently through a Xamarin.Forms project with rich Xaml code navigation", 
            "title": "Navigation"
        }, 
        {
            "location": "/xamarin-forms/navigation/#introduction", 
            "text": "MFractor enriches the navigation between C# and Xaml code by adding a few handy shortcuts. We can:   Quickly cycle between views, code behind classes and view models with the Mvvm shortcuts.  Jump to .NET symbols from Xaml with Go-To Symbol support.  Hover over any xaml element to see a .NET tooltip along with its included documentation  Preview images through image tooltips when we hover over an image source value.", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms/navigation/#mvvm-navigation", 
            "text": "When MFractor can  implicitly resolve the View - Code Behind Class - ViewModel relationship , the Mvvm navigation shortcut suite is activatated.  We can access these shortcuts by right clicking", 
            "title": "Mvvm Navigation"
        }, 
        {
            "location": "/xamarin-forms/navigation/#xaml-go-to-symbol", 
            "text": "", 
            "title": "Xaml Go-To Symbol"
        }, 
        {
            "location": "/xamarin-forms/navigation/#xaml-tooltips", 
            "text": "", 
            "title": "Xaml Tooltips"
        }, 
        {
            "location": "/xamarin-forms/navigation/#image-tooltips", 
            "text": "", 
            "title": "Image Tooltips"
        }, 
        {
            "location": "/xamarin-forms/analysis/", 
            "text": "Xaml Analysis\n\n\nUse the Xaml analyser to spend less time debugging and see Xaml errors in-editor\n\n\nIntroduction\n\n\nIt's common that xaml issues in Xamarin.Forms applications are undetected until runtime or worse, when sent out to a client. MFractor solves this by detecting Xaml issues \nimmediately\n and then marking them inside the xaml editor with a concise error message.\n\n\nBye bye Xaml bugs! \ud83d\udc4b\n\n\nUnder The Hood\n\n\nLet's take a look at what happens \"under the hood\" in MFractor when you open a Xaml document:\n\n\n\n\nWhen you open a Xaml file that's part of a .NET project, Xamarin Studio notifies MFractor that a new Xaml document was opened for editing. MFractor will  inject the Xaml analyser into the Xaml editor and consume the Xaml document.\n\n\nOnce MFractor has a copy of the Xaml DOM, it \nsymbolicates\n the xaml document. In this step all Xaml nodes are resolved to their corresponding .NET class, all attributes are resolved to properties, fields or methods and all markup extension expressions are parsed.\n\n\nIt may take a little while for MFractor to parse and symbolicate the Xaml DOM the first time a solution opens. While it's consuming the Xaml document, you might see a tooltip informing you that MFractor is not quite ready to analyse the document:\n\n\n\n\nWhen the Xaml document has been parsed and symbolicated, MFractor will analyse the document for a range of code issues. Any issues that are found are marked as either\n\n\nA full list of available Xaml analysers can be found at \nXamarin.Forms Analysers\n.\n\n\nWhenever you edit a Xaml code file, MFractor will cancel any running analysis, re-parse and symbolicate the document and then re-run the xaml analyser against your xaml.\n\n\nCode Fixes\n\n\nWhen MFractor detects a code issue, it is usually able to suggest a fix as well. When MFractor can fix an issue, the squiggle beneath that issue will be yellow like so:\n\n\nYou can action this fix by right clicking on the text area marked by the yellow squiggle\n\n\nSee \nRefactoring Code Generation\n for further documentation on using Xaml to C# code generation.\n\n\nExpression Analysis\n\n\nBinding Expression Analysis", 
            "title": "Analysis"
        }, 
        {
            "location": "/xamarin-forms/analysis/#xaml-analysis", 
            "text": "Use the Xaml analyser to spend less time debugging and see Xaml errors in-editor", 
            "title": "Xaml Analysis"
        }, 
        {
            "location": "/xamarin-forms/analysis/#introduction", 
            "text": "It's common that xaml issues in Xamarin.Forms applications are undetected until runtime or worse, when sent out to a client. MFractor solves this by detecting Xaml issues  immediately  and then marking them inside the xaml editor with a concise error message.  Bye bye Xaml bugs! \ud83d\udc4b", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms/analysis/#under-the-hood", 
            "text": "Let's take a look at what happens \"under the hood\" in MFractor when you open a Xaml document:   When you open a Xaml file that's part of a .NET project, Xamarin Studio notifies MFractor that a new Xaml document was opened for editing. MFractor will  inject the Xaml analyser into the Xaml editor and consume the Xaml document.  Once MFractor has a copy of the Xaml DOM, it  symbolicates  the xaml document. In this step all Xaml nodes are resolved to their corresponding .NET class, all attributes are resolved to properties, fields or methods and all markup extension expressions are parsed.  It may take a little while for MFractor to parse and symbolicate the Xaml DOM the first time a solution opens. While it's consuming the Xaml document, you might see a tooltip informing you that MFractor is not quite ready to analyse the document:   When the Xaml document has been parsed and symbolicated, MFractor will analyse the document for a range of code issues. Any issues that are found are marked as either  A full list of available Xaml analysers can be found at  Xamarin.Forms Analysers .  Whenever you edit a Xaml code file, MFractor will cancel any running analysis, re-parse and symbolicate the document and then re-run the xaml analyser against your xaml.", 
            "title": "Under The Hood"
        }, 
        {
            "location": "/xamarin-forms/analysis/#code-fixes", 
            "text": "When MFractor detects a code issue, it is usually able to suggest a fix as well. When MFractor can fix an issue, the squiggle beneath that issue will be yellow like so:  You can action this fix by right clicking on the text area marked by the yellow squiggle  See  Refactoring Code Generation  for further documentation on using Xaml to C# code generation.", 
            "title": "Code Fixes"
        }, 
        {
            "location": "/xamarin-forms/analysis/#expression-analysis", 
            "text": "", 
            "title": "Expression Analysis"
        }, 
        {
            "location": "/xamarin-forms/analysis/#binding-expression-analysis", 
            "text": "", 
            "title": "Binding Expression Analysis"
        }, 
        {
            "location": "/xamarin-forms/refactoring-and-code-generation/", 
            "text": "Refactoring And Code Generation\n\n\nGenerate C# code from Xaml in just a few clicks\n\n\nIntroduction\n\n\nFor a full list of available refactoring and code generation actions, see the \nTools In-Depth - Refactoring\n article.\n\n\nFixing Code Issues\n\n\nImplementing a ViewModel\n\n\nImplementing Missing Bindings\n\n\nGenerating Missing Classes\n\n\nGenerating Views\n\n\nGenerating Bindable Properties", 
            "title": "Refactoring And Code Generation"
        }, 
        {
            "location": "/xamarin-forms/refactoring-and-code-generation/#refactoring-and-code-generation", 
            "text": "Generate C# code from Xaml in just a few clicks", 
            "title": "Refactoring And Code Generation"
        }, 
        {
            "location": "/xamarin-forms/refactoring-and-code-generation/#introduction", 
            "text": "For a full list of available refactoring and code generation actions, see the  Tools In-Depth - Refactoring  article.", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms/refactoring-and-code-generation/#fixing-code-issues", 
            "text": "", 
            "title": "Fixing Code Issues"
        }, 
        {
            "location": "/xamarin-forms/refactoring-and-code-generation/#implementing-a-viewmodel", 
            "text": "", 
            "title": "Implementing a ViewModel"
        }, 
        {
            "location": "/xamarin-forms/refactoring-and-code-generation/#implementing-missing-bindings", 
            "text": "", 
            "title": "Implementing Missing Bindings"
        }, 
        {
            "location": "/xamarin-forms/refactoring-and-code-generation/#generating-missing-classes", 
            "text": "", 
            "title": "Generating Missing Classes"
        }, 
        {
            "location": "/xamarin-forms/refactoring-and-code-generation/#generating-views", 
            "text": "", 
            "title": "Generating Views"
        }, 
        {
            "location": "/xamarin-forms/refactoring-and-code-generation/#generating-bindable-properties", 
            "text": "", 
            "title": "Generating Bindable Properties"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/", 
            "text": "", 
            "title": "Analysers"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/refactorings/", 
            "text": "", 
            "title": "Refactorings"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fixes/", 
            "text": "", 
            "title": "Fixes"
        }, 
        {
            "location": "/xamarin-android/project-resource-indexing/", 
            "text": "", 
            "title": "Project Resource Indexing"
        }, 
        {
            "location": "/xamarin-android/navigation/", 
            "text": "Navigation\n\n\nExplore Android projects in a snap with resource tooltips and navigation shortcuts", 
            "title": "Navigation"
        }, 
        {
            "location": "/xamarin-android/navigation/#navigation", 
            "text": "Explore Android projects in a snap with resource tooltips and navigation shortcuts", 
            "title": "Navigation"
        }, 
        {
            "location": "/xamarin-android/analysis/", 
            "text": "", 
            "title": "Analysis"
        }, 
        {
            "location": "/xamarin-android/refactoring-and-code-generation/", 
            "text": "", 
            "title": "Refactoring And Code Generation"
        }, 
        {
            "location": "/xamarin-android/dotnet-code-analysis/", 
            "text": "", 
            "title": ".NET Code Analysis"
        }, 
        {
            "location": "/xamarin-android/resource-intellisense/", 
            "text": "Resource IntelliSense\n\n\nBuilding Android resource files such as values, menus, drawables or layouts using resource code completion\n\n\nIntroduction", 
            "title": "Resource IntelliSense"
        }, 
        {
            "location": "/xamarin-android/resource-intellisense/#resource-intellisense", 
            "text": "Building Android resource files such as values, menus, drawables or layouts using resource code completion", 
            "title": "Resource IntelliSense"
        }, 
        {
            "location": "/xamarin-android/resource-intellisense/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/", 
            "text": "", 
            "title": "Analysers"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/refactorings/", 
            "text": "", 
            "title": "Refactorings"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/fixes/", 
            "text": "", 
            "title": "Fixes"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/intellisense/", 
            "text": "", 
            "title": "IntelliSense"
        }, 
        {
            "location": "/tutorials/xamarin-android/resource-expressions-and-code-navigation/", 
            "text": "Resource Expressions And Code Navigation\n\n\nLearn the C# and xml expressions that activate tooltips and go-to declaration in MFractor for Android\n\n\nOverview\n\n\nIf you\u2019re a Xamarin.Android developer building apps using the native APIs then chances are you spend a lot of time navigating resource code.\n\n\nThis becomes tedious when you are constantly doing manual searches for your target, browsing through the find results and then clicking the search result to jump to it. What\u2019s more, using go-to declaration on a C# resource symbol takes you to its integer id! It\u2019s tremendously frustrating and a massive time-waster.\n\n\nAnd this problem gets worse the bigger your project is; large Android applications can have dozens to hundreds of xml resources that need to be scanned each time a search takes place.\n\n\nMFractor addresses these navigation issues by overriding the default \u201cgo to declaration\u201d keyboard shortcuts when you are in the context of a resource expression.\n\n\nThese expressions come in 2 flavours:\n\n\n\n\nC#: Code expressions within C# that access the generated Resources class contained in the Resources.Designer.cs file. For instance; Resource.Layout.myLayout.\n\n\nXML: Code expressions within Android xml resources that point to another resource. For instance; @layout/myLayout.\n\n\n\n\nWhen MFractor detects the cursor is within one of these expressions, resource tooltips and go-to-declaration become active. This enables fast and efficient code navigation.\n\n\nIt looks a little like this when in action:\n\n\nThat is much faster than manual searching! Now lets go over each of these expression types.\n\n\nC# Resource Expressions\n\n\nFor C#, resource expressions are always resolved against the Resource.Designer.cs file that is generated alongside a project. This section assumes a basic familiarity of the Resource.Designer.cs file; if this is a new concept I suggested reading the \nAndroid Resource Basics\n page in Xamarins documentation.\n\n\nThe components of a supported resource expression are formatted like so:\n\n\n[Project Namespace].[Resource].[ResourceType].[ResourceName]\n\n\n\n\nWhere:\n\n\n\n\n[Project Namespace] is the project namespace that the Resources designer class resides. This component is either:\n\n\nImplicit: The encapsulating namespace is the same as the resource designers namespace or a using statement provides the resource designer class.\n\n\nExplicit: The expression explicitly uses the namespace that owns the resource class.\n\n\nResource is the constant Resource class that wraps the declarations of the ResourceType sub-classes.\n\n\nResourceType is the nested resource type class.\n\n\nResourceName is the name of the resource being referenced. MFractor will only trigger its behaviour when your caret or mouse cursor is over this component of the c# resource expression.\n\n\n\n\nAn example of a valid expression would be:\n\n\nResources.String.my_string;\n\n\n\n\nWhen your cursor is over the my_string component of this expression, MFractor will attempt to resolve a string resource named my_string.\n\n\nXml Resource Expressions\n\n\nXml resource expressions come in 3 different categories:\n\n\n\n\nReference expressions point directly to a resource. They begin with the \u2018@\u2019 character.\n\n\nDeclarative expressions declare a new resource. These are only used with ids. They begin with a \u2018@+\u2019 character sequence.\n\n\nTheme expression point to a component of the currently scoped theme. They begin with a \u2018?\u2019 character.\n\n\n\n\nReference and declarative expression are structured with the following syntax:\n\n\n@[+][PackageName:]resourceType/resourceName\n\n\n\n\nWhere:\n\n\n\n\n@[+] is the resource reference symbol.\n\n\nPackageName is an optional component that points to the package the resource is within.\n\n\nresourceType is the resource type.\n\n\nresourceName is the name of the resource.\n\n\n\n\nAn example of this would be:\n\n\n@string/my_string\n\n\n\n\nWhen your cursor is any component of this expression, MFractor will attempt to resolve a pre-existing string resource named my_string.\n\n\nLastly, theme resource expressions point to a component of the current theme. These are structured with the following syntax:\n\n\n?[PackageName:][ResourceType/]themeItemName\n\n\n\n\nWhere:\n\n\n\n\nPackageName is the optional package name the theme component resides within.\n\n\nResourceType is the optional resource type of the theme component. This is typically inferred.\n\n\nthemeItemName the name of the theme item.", 
            "title": "Resource Expressions And Code Navigation"
        }, 
        {
            "location": "/tutorials/xamarin-android/resource-expressions-and-code-navigation/#resource-expressions-and-code-navigation", 
            "text": "Learn the C# and xml expressions that activate tooltips and go-to declaration in MFractor for Android", 
            "title": "Resource Expressions And Code Navigation"
        }, 
        {
            "location": "/tutorials/xamarin-android/resource-expressions-and-code-navigation/#overview", 
            "text": "If you\u2019re a Xamarin.Android developer building apps using the native APIs then chances are you spend a lot of time navigating resource code.  This becomes tedious when you are constantly doing manual searches for your target, browsing through the find results and then clicking the search result to jump to it. What\u2019s more, using go-to declaration on a C# resource symbol takes you to its integer id! It\u2019s tremendously frustrating and a massive time-waster.  And this problem gets worse the bigger your project is; large Android applications can have dozens to hundreds of xml resources that need to be scanned each time a search takes place.  MFractor addresses these navigation issues by overriding the default \u201cgo to declaration\u201d keyboard shortcuts when you are in the context of a resource expression.  These expressions come in 2 flavours:   C#: Code expressions within C# that access the generated Resources class contained in the Resources.Designer.cs file. For instance; Resource.Layout.myLayout.  XML: Code expressions within Android xml resources that point to another resource. For instance; @layout/myLayout.   When MFractor detects the cursor is within one of these expressions, resource tooltips and go-to-declaration become active. This enables fast and efficient code navigation.  It looks a little like this when in action:  That is much faster than manual searching! Now lets go over each of these expression types.", 
            "title": "Overview"
        }, 
        {
            "location": "/tutorials/xamarin-android/resource-expressions-and-code-navigation/#c-resource-expressions", 
            "text": "For C#, resource expressions are always resolved against the Resource.Designer.cs file that is generated alongside a project. This section assumes a basic familiarity of the Resource.Designer.cs file; if this is a new concept I suggested reading the  Android Resource Basics  page in Xamarins documentation.  The components of a supported resource expression are formatted like so:  [Project Namespace].[Resource].[ResourceType].[ResourceName]  Where:   [Project Namespace] is the project namespace that the Resources designer class resides. This component is either:  Implicit: The encapsulating namespace is the same as the resource designers namespace or a using statement provides the resource designer class.  Explicit: The expression explicitly uses the namespace that owns the resource class.  Resource is the constant Resource class that wraps the declarations of the ResourceType sub-classes.  ResourceType is the nested resource type class.  ResourceName is the name of the resource being referenced. MFractor will only trigger its behaviour when your caret or mouse cursor is over this component of the c# resource expression.   An example of a valid expression would be:  Resources.String.my_string;  When your cursor is over the my_string component of this expression, MFractor will attempt to resolve a string resource named my_string.", 
            "title": "C# Resource Expressions"
        }, 
        {
            "location": "/tutorials/xamarin-android/resource-expressions-and-code-navigation/#xml-resource-expressions", 
            "text": "Xml resource expressions come in 3 different categories:   Reference expressions point directly to a resource. They begin with the \u2018@\u2019 character.  Declarative expressions declare a new resource. These are only used with ids. They begin with a \u2018@+\u2019 character sequence.  Theme expression point to a component of the currently scoped theme. They begin with a \u2018?\u2019 character.   Reference and declarative expression are structured with the following syntax:  @[+][PackageName:]resourceType/resourceName  Where:   @[+] is the resource reference symbol.  PackageName is an optional component that points to the package the resource is within.  resourceType is the resource type.  resourceName is the name of the resource.   An example of this would be:  @string/my_string  When your cursor is any component of this expression, MFractor will attempt to resolve a pre-existing string resource named my_string.  Lastly, theme resource expressions point to a component of the current theme. These are structured with the following syntax:  ?[PackageName:][ResourceType/]themeItemName  Where:   PackageName is the optional package name the theme component resides within.  ResourceType is the optional resource type of the theme component. This is typically inferred.  themeItemName the name of the theme item.", 
            "title": "Xml Resource Expressions"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/", 
            "text": "Mvvm Navigation\n\n\nQuickly move between Xamarin.Forms Views, View Models and Code behind classes using Mvvm navigation shortcuts.\n\n\nOverview\n\n\nXamarin.Forms is cross platform toolkit that allows developers to build iOS, Android and Windows apps and maximise code reuse across platforms. Xamarin.Forms also facilitates shared UI code through the use of an xml based view markup langauge named Xaml.\n\n\nDevelopers build their UI views in Xaml and Xamarin.Forms then inflate the view into it\u2019s native implementation.\n\n\nAlongside shared UI code, Xamarin.Forms uses the Model \u2013 View \u2013 View Model (Mvvm) design pattern to seperate a UI definition it\u2019s from state/behaviour code.\n\n\nThe Mvvm design pattern is a great for maintainabilty and code clarity however developers can spend a lot of time manually nagivating between Xaml views and an associated view model.\n\n\nMFractor adds several navigation shortcuts to speed up developers.\n\n\nGetting Started\nIn this article we will use MFractor to navigate between a Xaml UI definition, it\u2019s code behind class and its associated view model.\n\n\nWe assume the following:\n\n\n\n\nA Xamarin Studio 6.0 installation.\n\n\nMFractor 2 installed into Xamarin Studio. Install it here: www.mfractor.com/download\n\n\nA familarity with the Xamarin.Forms; particularly building UIs with Xaml and the Model \u2013 View \u2013 View Model design pattern.\n\n\nThe MFractor For Xamarin.Forms sample project downloaded and open in Xamarin Studio.\n\n\n\n\nViews, Code Behind classes and ViewModels\n\n\nLet\u2019s start by examining the MFractor For Xamarin.Forms sample project. Open it up in Xamarin Studio and take a look at the project structure:\n\n\nMFractor For Xamarin.Forms Project\n\n\nThe project itself is trivial; it has a single xaml page with a code behind class and 2 view view models; WelcomeViewModel and GoodbyeViewModel. Notice that this project appends Xaml views with with \u201cPage\u201d and view models with \u201cViewModel\u201d.\n\n\nBefore we get started learning how to use the Mvvm navigation shortcuts, let\u2019s understand the conventions that MFractor uses to drive the navigation.\n\n\nThe \u201cPage/View\" and \"ViewModel\" naming convention\n\n\nIn Xamarin.Forms, the de-facto naming convention is to append views with Page or View and view models are appended with ViewModel.\n\n\nThis naming standard implies that the WelcomePage and the WelcomeViewModel are associated; if we stripped off Page and ViewModel from the file names then both would be named Welcome. This implicit relationship makes the codebase easier to understand by conforming to industry standards.\n\n\nMFractor notices this implicit relationship; if a view and a view model within the same assembly are named like this, a MFractor activates shortcuts between the view, it\u2019s code behind and the associated view model.\n\n\nIf developers don\u2019t want this implicit relationship or their Views/View Models are in seperate assemblies, they may explicitly specify the binding context in the view\u2019s Xaml using the View Model Locator pattern.\n\n\nThe ViewModelLocator Pattern\n\n\nThe ViewModelLocator pattern is a static class used to specify the BindingContext of a Xaml view for design time previewing. James Montemagno re-introduced this concept in his blog post for the Xaml Previewer.\n\n\nDevelopers implement a static class named ViewModelLocator that exposes a static instance of their view models:\n\n\npublic static class ViewModelLocator\n{\n    static MyViewModel _myViewModel;\n    public static MyViewModel MyViewModel =\n _myViewModel ?? (_myViewModel = new MyViewModel());\n}\n\n\n\n\nThis static instance is then bound to the Xaml\u2019s binding context via an x:Static expression:\n\n\n    xmlns:design=\nclr-namespace:MyAppNamespace;assembly=MyApp\n\n    BindingContext=\n{x:Static design:ViewModelLocator.MyViewModel}\n\n\n\n\n\nWhen the BindingContext for a view is explicitly defined, MFractor will honor this relationship and route all Mvvm navigation to the view model class declaration defined by the ViewModelLocator.\n\n\nFor the sample project, we could retarget the WecomePage to link with the GoodbyeViewModel by exposing a static instance through the ViewModelLocator and referencing it using the BindingContext:\n\n\nC#\n\n\npublic static class ViewModelLocator\n{\n    static GoodbyeViewModel _goodebye;\n    public static GoodbyeViewModel GoodbyeViewModel =\n _goodebye ?? (_goodebye = new GoodbyeViewModel());\n}\n\n\n\n\nXaml\n\n\n    xmlns:design=\nclr-namespace:MFractorForForms;assembly=MFractorForForms\n\n    BindingContext=\n{x:Static design:ViewModelLocator.GoodbyeViewModel}\n\n\n\n\n\nFluid Mvvm Navigation\n\n\nNow that we understand how MFractor links the Mvvm code files, let\u2019s get to know the Mvvm navigation shortcuts.\n\n\nOpen up the WelcomePage.xaml and right click in the middle of the editor:\n\n\nMvvm Shortcuts\n\n\nThere are 3 Mvvm navigation shortcuts in MFractor:\n\n\n\n\nGo To Code-Behind Class: Jumps you to the code behind class related to a view or view model\n\n\nGo To View Model: Jumps you to the view model related to a view or code behind class.\n\n\nGo To Xaml View: Jumps you to the xaml view related to a view model or code behind class.\n\n\n\n\nWe can use these short-cuts to quickly navigate around these 3 files:\n\n\nOr we can use an xStatic expression that uses the ViewModelLocator to target a different view model implementation:\n\n\nCustom Binding Context\n\n\nNow the Go To View Model shortcut will instead jump to the class type used by the BindingContext rather than the implicit association.\n\n\nSummary\n\n\nWe\u2019ve learnt how to use MFractors Mvvm navigation shortcuts to quickly move between the View, Code Behind Class and View Model\n\n\nTo continue learning to use MFractor, visit our documentation page.", 
            "title": "Mvvm Navigation"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#mvvm-navigation", 
            "text": "Quickly move between Xamarin.Forms Views, View Models and Code behind classes using Mvvm navigation shortcuts.", 
            "title": "Mvvm Navigation"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#overview", 
            "text": "Xamarin.Forms is cross platform toolkit that allows developers to build iOS, Android and Windows apps and maximise code reuse across platforms. Xamarin.Forms also facilitates shared UI code through the use of an xml based view markup langauge named Xaml.  Developers build their UI views in Xaml and Xamarin.Forms then inflate the view into it\u2019s native implementation.  Alongside shared UI code, Xamarin.Forms uses the Model \u2013 View \u2013 View Model (Mvvm) design pattern to seperate a UI definition it\u2019s from state/behaviour code.  The Mvvm design pattern is a great for maintainabilty and code clarity however developers can spend a lot of time manually nagivating between Xaml views and an associated view model.  MFractor adds several navigation shortcuts to speed up developers.  Getting Started\nIn this article we will use MFractor to navigate between a Xaml UI definition, it\u2019s code behind class and its associated view model.  We assume the following:   A Xamarin Studio 6.0 installation.  MFractor 2 installed into Xamarin Studio. Install it here: www.mfractor.com/download  A familarity with the Xamarin.Forms; particularly building UIs with Xaml and the Model \u2013 View \u2013 View Model design pattern.  The MFractor For Xamarin.Forms sample project downloaded and open in Xamarin Studio.", 
            "title": "Overview"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#views-code-behind-classes-and-viewmodels", 
            "text": "Let\u2019s start by examining the MFractor For Xamarin.Forms sample project. Open it up in Xamarin Studio and take a look at the project structure:  MFractor For Xamarin.Forms Project  The project itself is trivial; it has a single xaml page with a code behind class and 2 view view models; WelcomeViewModel and GoodbyeViewModel. Notice that this project appends Xaml views with with \u201cPage\u201d and view models with \u201cViewModel\u201d.  Before we get started learning how to use the Mvvm navigation shortcuts, let\u2019s understand the conventions that MFractor uses to drive the navigation.", 
            "title": "Views, Code Behind classes and ViewModels"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#the-pageview-and-viewmodel-naming-convention", 
            "text": "In Xamarin.Forms, the de-facto naming convention is to append views with Page or View and view models are appended with ViewModel.  This naming standard implies that the WelcomePage and the WelcomeViewModel are associated; if we stripped off Page and ViewModel from the file names then both would be named Welcome. This implicit relationship makes the codebase easier to understand by conforming to industry standards.  MFractor notices this implicit relationship; if a view and a view model within the same assembly are named like this, a MFractor activates shortcuts between the view, it\u2019s code behind and the associated view model.  If developers don\u2019t want this implicit relationship or their Views/View Models are in seperate assemblies, they may explicitly specify the binding context in the view\u2019s Xaml using the View Model Locator pattern.", 
            "title": "The \u201cPage/View\" and \"ViewModel\" naming convention"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#the-viewmodellocator-pattern", 
            "text": "The ViewModelLocator pattern is a static class used to specify the BindingContext of a Xaml view for design time previewing. James Montemagno re-introduced this concept in his blog post for the Xaml Previewer.  Developers implement a static class named ViewModelLocator that exposes a static instance of their view models:  public static class ViewModelLocator\n{\n    static MyViewModel _myViewModel;\n    public static MyViewModel MyViewModel =  _myViewModel ?? (_myViewModel = new MyViewModel());\n}  This static instance is then bound to the Xaml\u2019s binding context via an x:Static expression:      xmlns:design= clr-namespace:MyAppNamespace;assembly=MyApp \n    BindingContext= {x:Static design:ViewModelLocator.MyViewModel}   When the BindingContext for a view is explicitly defined, MFractor will honor this relationship and route all Mvvm navigation to the view model class declaration defined by the ViewModelLocator.  For the sample project, we could retarget the WecomePage to link with the GoodbyeViewModel by exposing a static instance through the ViewModelLocator and referencing it using the BindingContext:  C#  public static class ViewModelLocator\n{\n    static GoodbyeViewModel _goodebye;\n    public static GoodbyeViewModel GoodbyeViewModel =  _goodebye ?? (_goodebye = new GoodbyeViewModel());\n}  Xaml      xmlns:design= clr-namespace:MFractorForForms;assembly=MFractorForForms \n    BindingContext= {x:Static design:ViewModelLocator.GoodbyeViewModel}", 
            "title": "The ViewModelLocator Pattern"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#fluid-mvvm-navigation", 
            "text": "Now that we understand how MFractor links the Mvvm code files, let\u2019s get to know the Mvvm navigation shortcuts.  Open up the WelcomePage.xaml and right click in the middle of the editor:", 
            "title": "Fluid Mvvm Navigation"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#mvvm-shortcuts", 
            "text": "There are 3 Mvvm navigation shortcuts in MFractor:   Go To Code-Behind Class: Jumps you to the code behind class related to a view or view model  Go To View Model: Jumps you to the view model related to a view or code behind class.  Go To Xaml View: Jumps you to the xaml view related to a view model or code behind class.   We can use these short-cuts to quickly navigate around these 3 files:  Or we can use an xStatic expression that uses the ViewModelLocator to target a different view model implementation:", 
            "title": "Mvvm Shortcuts"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#custom-binding-context", 
            "text": "Now the Go To View Model shortcut will instead jump to the class type used by the BindingContext rather than the implicit association.", 
            "title": "Custom Binding Context"
        }, 
        {
            "location": "/tutorials/xamarin-forms/mvvm-navigation/#summary", 
            "text": "We\u2019ve learnt how to use MFractors Mvvm navigation shortcuts to quickly move between the View, Code Behind Class and View Model  To continue learning to use MFractor, visit our documentation page.", 
            "title": "Summary"
        }, 
        {
            "location": "/release-notes/v2-7/", 
            "text": "Release Notes - v2.7.0\n\n\n8th January 2017\n\n\nDownload MFractor 2.7.0\n\n\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.7.0 of MFractor for Xamarin Studio.\n\n\nYou already love being able to generate bindings but I've taken it to the next level this release...\n\n\nIntroducing View Model generation:\n\n\n\n\nGot a heap of unimplemented bindings? Right click anywhere in your Xaml document and select \nRefactor\n -\n \nImplement View Model\n.\n\n\nMFractor will collect all the missing bindings and then generate a new class with \nall\n of those properties into the \"MyDefaultNamespace.ViewModels\".\n\n\nDoes the view model already exist? Then MFractor simply inserts the new bindings into the existing view model.\n\n\nI think it'll save you enough time during the week that you may just get to Friday beers a few hours early \ud83c\udf7b\n\n\nFeatures\n\n\n\n\nBy right clicking anywhere in a Xaml document, implement all missing bindings as a new or into an existing view model:\n\n\nImplement view model\n\n\n\n\n\n\nICommands\n\n\nNew Xaml Analysers:\n\n\nValidate that elements declared inside a resource dictionary have an x:Key.\n\n\nValidate that elements declared inside a resource dictionary have a unique x:Key value.\n\n\nDetect when an x:TypeArguments is used on a non-generic type and warn of incorrect usage.\n\n\nDetect when a property setter node (\nMyClass.MyProperty/\n) references a non-existant member on the parent class.\n\n\nDetect when a property setter attribute is empty.\n\n\nDetect when an undefined static resource is referenced by a \nStaticResource\n expression.\n\n\nDetect when the value returned by a \nStaticResource\n expression causes a type mismatch.\n\n\nDetect when an unknown type is being provided to a \nx:TypeArguments\n attribute.\n\n\nValidate that \nOnIdiom\n elements return the correct type for the outer property setter.\n\n\nValidate that \nOnPlatform\n elements return the correct type for the outer property setter.\n\n\nDetect when a developer has misused a property setter inside another xaml element. For example, \nOnIdiom.Phone\n doesn't make any sense when wrapped by the outer element \nOnPlatform\n.\n\n\n\n\n\n\nNew Xaml Fixes:\n\n\nGenerate missing resource dictionary keys.\n\n\nAuto-correct mispelt StaticResource references.\n\n\n\n\n\n\nNew Simplify Refactorings:\n\n\nAttributes that use a static instance to initialise the property (eg \nVerticalOptions=\"LayoutOptions.CentreAndExpand\"\n) can now be simplified to just the instance name (eg \nVerticalOptions=\"CentreAndExpand\"\n).\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nThe \"About MFractor\" dialog now contains a button to copy version and IDE information into the clipboard for bug reports.\n\n\nThis release introduces the framework for an Xml refactoring engine. Over time, I'll be adding Xml and Xaml refactoring operations to make code cleanup a breeze.\n\n\nAnnotating value converters with a ValueConversion(input, output) attribute will trigger the conversion information to render into tooltip.\n\n\n\n\nBug Fixes\n\n\n\n\nSometimes the Xaml document analyser would fail to load and bring down the Xaml editor. This has been fixed.\n\n\nFixed a bug that caused View \n - \n Code Behind navigation shortcuts to break when an AST parse was in progress. View \n - \n Code Behind shortcuts should now always be active.\n\n\nWhen property setter nodes are used (\n), the class component is now correctly validated.\n\n\nWhen importing a Xaml namespace, the element is inserted on a newline and formatted to align with other attributes.\n\n\nWhen resolving the binding context for nested DataTemplates, sometimes the binding context resolver would fail on generics or IEnumerables\n\n\nMore resilient Mvvm resolver to drive the 'Go To View Model', 'Go To Xaml View' and 'Go To Code Behind' shortcuts. MFractor will attempt to infer as best possible the associations between those 3 files.\n\n\nSave the project after adding a new file to it.", 
            "title": 2.7
        }, 
        {
            "location": "/release-notes/v2-7/#release-notes-v270", 
            "text": "8th January 2017  Download MFractor 2.7.0", 
            "title": "Release Notes - v2.7.0"
        }, 
        {
            "location": "/release-notes/v2-7/#introduction", 
            "text": "This is a summary of the changes introduced in v2.7.0 of MFractor for Xamarin Studio.  You already love being able to generate bindings but I've taken it to the next level this release...  Introducing View Model generation:   Got a heap of unimplemented bindings? Right click anywhere in your Xaml document and select  Refactor  -   Implement View Model .  MFractor will collect all the missing bindings and then generate a new class with  all  of those properties into the \"MyDefaultNamespace.ViewModels\".  Does the view model already exist? Then MFractor simply inserts the new bindings into the existing view model.  I think it'll save you enough time during the week that you may just get to Friday beers a few hours early \ud83c\udf7b", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2-7/#features", 
            "text": "By right clicking anywhere in a Xaml document, implement all missing bindings as a new or into an existing view model:  Implement view model    ICommands  New Xaml Analysers:  Validate that elements declared inside a resource dictionary have an x:Key.  Validate that elements declared inside a resource dictionary have a unique x:Key value.  Detect when an x:TypeArguments is used on a non-generic type and warn of incorrect usage.  Detect when a property setter node ( MyClass.MyProperty/ ) references a non-existant member on the parent class.  Detect when a property setter attribute is empty.  Detect when an undefined static resource is referenced by a  StaticResource  expression.  Detect when the value returned by a  StaticResource  expression causes a type mismatch.  Detect when an unknown type is being provided to a  x:TypeArguments  attribute.  Validate that  OnIdiom  elements return the correct type for the outer property setter.  Validate that  OnPlatform  elements return the correct type for the outer property setter.  Detect when a developer has misused a property setter inside another xaml element. For example,  OnIdiom.Phone  doesn't make any sense when wrapped by the outer element  OnPlatform .    New Xaml Fixes:  Generate missing resource dictionary keys.  Auto-correct mispelt StaticResource references.    New Simplify Refactorings:  Attributes that use a static instance to initialise the property (eg  VerticalOptions=\"LayoutOptions.CentreAndExpand\" ) can now be simplified to just the instance name (eg  VerticalOptions=\"CentreAndExpand\" ).", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2-7/#enhancements", 
            "text": "The \"About MFractor\" dialog now contains a button to copy version and IDE information into the clipboard for bug reports.  This release introduces the framework for an Xml refactoring engine. Over time, I'll be adding Xml and Xaml refactoring operations to make code cleanup a breeze.  Annotating value converters with a ValueConversion(input, output) attribute will trigger the conversion information to render into tooltip.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v2-7/#bug-fixes", 
            "text": "Sometimes the Xaml document analyser would fail to load and bring down the Xaml editor. This has been fixed.  Fixed a bug that caused View   -   Code Behind navigation shortcuts to break when an AST parse was in progress. View   -   Code Behind shortcuts should now always be active.  When property setter nodes are used ( ), the class component is now correctly validated.  When importing a Xaml namespace, the element is inserted on a newline and formatted to align with other attributes.  When resolving the binding context for nested DataTemplates, sometimes the binding context resolver would fail on generics or IEnumerables  More resilient Mvvm resolver to drive the 'Go To View Model', 'Go To Xaml View' and 'Go To Code Behind' shortcuts. MFractor will attempt to infer as best possible the associations between those 3 files.  Save the project after adding a new file to it.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v2-6/", 
            "text": "Release Notes - v2.6.0\n\n\n31st October 2016\n\n\nDownload MFractor 2.6.0\n\n\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.6.0 of MFractor for Xamarin Studio.\n\n\nAs a major release, this release adds several code generation capabilities to improve your Xaml workflow. Generate views, classes and value converters in only a few clicks...\n\n\nJust right click on that little yellow squiggle and use the fix to generate a whole lotta code:\n\n\nThere are also more xaml code checks to watch out for nasty Xaml issues and bug fixes galore.\n\n\nEnjoy!\n\n\nFeatures\n\n\n\n\nNew code generation capabilities:\n\n\nGenerate classes from \nmy_namespace:MyMissingClass\n in xaml.\n\n\nGenerate views from \nmy_namespace:MyMissingView\n in xaml.\n\n\nGenerate value converters when a missing xaml node ends with \"[cC]onverter] in xaml.\n\n\n\n\n\n\nNew Xaml analysers:\n\n\nFor generics, validate that an x:TypeArguments attribute or xml node setter exists.\n\n\nFor generics, validate that the count of parameters provided to x:TypeArguments matches the generics signature.\n\n\nValidate the root xaml node contains an x:Class directive to set the code behind class name and namespace.\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nThis release targets Xamarin Studio v6.1.1\n\n\n\n\nBug Fixes\n\n\n\n\nFix a bug in xaml namespace resolution that prevented the \"import new xmlns\" fix from triggering.\n\n\nAllow importing of xaml namespaces from x:Static symbols.\n\n\nFor Setters, don't validate TargetType property that the provided type is a static member of System.Type.\n\n\nWhen a symbol name matches but its in the wrong namespace, don't suggest it as a fix.\n\n\nRemove the MFractor settings panel to fix the Xamarin Studio preferences dialog from not opening when it didn't exist.\n\n\nWhen using native view declaration, the xaml symbolicator will now honor the targetPlatform flag and find the assembly for that platform. Previously this was a naive search that used the first assembly found; using the wrong symbols if a assembly of the same name existed in both an iOS and Android project.", 
            "title": 2.6
        }, 
        {
            "location": "/release-notes/v2-6/#release-notes-v260", 
            "text": "31st October 2016  Download MFractor 2.6.0", 
            "title": "Release Notes - v2.6.0"
        }, 
        {
            "location": "/release-notes/v2-6/#introduction", 
            "text": "This is a summary of the changes introduced in v2.6.0 of MFractor for Xamarin Studio.  As a major release, this release adds several code generation capabilities to improve your Xaml workflow. Generate views, classes and value converters in only a few clicks...  Just right click on that little yellow squiggle and use the fix to generate a whole lotta code:  There are also more xaml code checks to watch out for nasty Xaml issues and bug fixes galore.  Enjoy!", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2-6/#features", 
            "text": "New code generation capabilities:  Generate classes from  my_namespace:MyMissingClass  in xaml.  Generate views from  my_namespace:MyMissingView  in xaml.  Generate value converters when a missing xaml node ends with \"[cC]onverter] in xaml.    New Xaml analysers:  For generics, validate that an x:TypeArguments attribute or xml node setter exists.  For generics, validate that the count of parameters provided to x:TypeArguments matches the generics signature.  Validate the root xaml node contains an x:Class directive to set the code behind class name and namespace.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2-6/#enhancements", 
            "text": "This release targets Xamarin Studio v6.1.1", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v2-6/#bug-fixes", 
            "text": "Fix a bug in xaml namespace resolution that prevented the \"import new xmlns\" fix from triggering.  Allow importing of xaml namespaces from x:Static symbols.  For Setters, don't validate TargetType property that the provided type is a static member of System.Type.  When a symbol name matches but its in the wrong namespace, don't suggest it as a fix.  Remove the MFractor settings panel to fix the Xamarin Studio preferences dialog from not opening when it didn't exist.  When using native view declaration, the xaml symbolicator will now honor the targetPlatform flag and find the assembly for that platform. Previously this was a naive search that used the first assembly found; using the wrong symbols if a assembly of the same name existed in both an iOS and Android project.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v2-5/", 
            "text": "Release Notes - v2.5.3\n\n\n10th of October 2016\n\n\nDownload MFractor 2.5.0\n\n\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.5.3 of MFractor for Xamarin Studio.\n\n\nThis release adds support for native view declaration and property generation for missing view attributes.\n\n\nFeatures\n\n\n\n\nGenerate properties and bindable properties onto classes that implement Xamarin.Forms.ObservableObject.\n\n\nFull support for native view declaration. Tooltips, go-to declaration, xaml analysis and code generation enabled on native views used in Xaml.\n\n\n\n\nBug Fixes\n\n\n\n\nXaml expressions now parsed on attributes that cannot be resolved to a .NET symbol. This enables Tooltips, go-to declaration, xaml analysis and code generation.\n\n\nThe analysis engine no longer assumes that the Xamarin.Forms and Microsoft schemas are the implicit and 'x' namespaces. This means that Xamarin.Forms could be remapped to xmlns:xf etc and the xaml analyser will still function correctly.", 
            "title": 2.5
        }, 
        {
            "location": "/release-notes/v2-5/#release-notes-v253", 
            "text": "10th of October 2016  Download MFractor 2.5.0", 
            "title": "Release Notes - v2.5.3"
        }, 
        {
            "location": "/release-notes/v2-5/#introduction", 
            "text": "This is a summary of the changes introduced in v2.5.3 of MFractor for Xamarin Studio.  This release adds support for native view declaration and property generation for missing view attributes.", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2-5/#features", 
            "text": "Generate properties and bindable properties onto classes that implement Xamarin.Forms.ObservableObject.  Full support for native view declaration. Tooltips, go-to declaration, xaml analysis and code generation enabled on native views used in Xaml.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2-5/#bug-fixes", 
            "text": "Xaml expressions now parsed on attributes that cannot be resolved to a .NET symbol. This enables Tooltips, go-to declaration, xaml analysis and code generation.  The analysis engine no longer assumes that the Xamarin.Forms and Microsoft schemas are the implicit and 'x' namespaces. This means that Xamarin.Forms could be remapped to xmlns:xf etc and the xaml analyser will still function correctly.", 
            "title": "Bug Fixes"
        }
    ]
}