{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome\n\n\nWelcome to the documentation for MFractor, a mobile first productivity tool for Visual Studio Mac.\n\n\nInstalling MFractor\n\n\nPurchase MFractor\n\n\nActivate MFractor\n\n\nKey Features\n\n\n*\n\n\nHelp And Support\n\n\n\n\nTwitter: \n@matthewrdev\n\n\nSlack: \nMFractor Slack Channel\n.\n\n\nGitter: \nMFractor Gitter Channel\n.\n\n\nEmail: Please email \nmatthew@mfractor.com\n\n\nOfficeHours: Please book me at \nhttps://officehours.io/people/matthewrdev\n\n\n\n\nMatthew Robbins - Creator of MFractor. \u270c\ufe0f", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome", 
            "text": "Welcome to the documentation for MFractor, a mobile first productivity tool for Visual Studio Mac.", 
            "title": "Welcome"
        }, 
        {
            "location": "/#installing-mfractor", 
            "text": "", 
            "title": "Installing MFractor"
        }, 
        {
            "location": "/#purchase-mfractor", 
            "text": "", 
            "title": "Purchase MFractor"
        }, 
        {
            "location": "/#activate-mfractor", 
            "text": "", 
            "title": "Activate MFractor"
        }, 
        {
            "location": "/#key-features", 
            "text": "*", 
            "title": "Key Features"
        }, 
        {
            "location": "/#help-and-support", 
            "text": "Twitter:  @matthewrdev  Slack:  MFractor Slack Channel .  Gitter:  MFractor Gitter Channel .  Email: Please email  matthew@mfractor.com  OfficeHours: Please book me at  https://officehours.io/people/matthewrdev   Matthew Robbins - Creator of MFractor. \u270c\ufe0f", 
            "title": "Help And Support"
        }, 
        {
            "location": "/installation-and-setup/", 
            "text": "Installation And Setup\n\n\nInstalling, activating and updating MFractor for Visual Studio Mac\n\n\nInstall MFractor\n\n\nTo install MFractor, start Visual Studio for Mac.\n\n\nNext, navigate to the top left \nVisual Studio Menu\n and select \nExtensions\n.\n\n\nNext, click on the \nGallery\n tab and under \nIDE Extensions\n choose \nMFractor\n.\n\n\nActivating MFractor\n\n\nWhen you first install MFractor, the activation dialog will open shortly after installation.\n\n\nIn the activation dialog, enter your email and name and then click \nActivate\n.\n\n\n\n\nImporting A Professional License\n\n\nDownload and locate your license file (which ends with the extension \n.lic\n). When purchasing MFractor Professional, this license file will be provided in an email. In this example, our license file is located on our desktop called \nlicense.lic\n.\n\n\n\n\nOpen Visual Studio for Mac. If you have not activated MFractor with an email address, close the activation window.\n\n\n\n\nIn the main Visual Studio for Mac menu bar, select \nMFractor\n and then \nLicensing\n. This will open the licensing window where you can import or remove an MFractor Professional license.\n\n\nNext, click on the \nImport License\n button, browse to the license file (\nlicense.lic\n) and double click it to import the license into MFractor.\n\n\n\n\nIt is safe to delete the license file from its original location. MFractor stores the license inside itself.\n\n\n\n\nThe licensing window will list:\n\n\n\n\nLicensed To\n - The full name of the person that the MFractor Professional license is issued to.\n\n\nLicense Email:\n - The email that this MFractor Professional license is issued against.\n\n\nLicense Type and Expiry Date\n - The type of license issued (Professional, Trial or Lite) and when that license expires.\n\n\n\n\nDeactivating Your Professional License\n\n\nIf you'd like to remove a license from MFractor, you can open the MFractor license information window and click \nRemove License\n.\n\n\nIMPORTANT: This is a destructive operation, you cannot undo removing a license but you can re-import a new license.\n\n\nAfter removing a license, you will be automatically downgraded to a free MFractor license. This allows usage of most features apart from C# code actions, mobile-specific C# code diagnostics, and configuration file support.\n\n\nUpdating MFractor\n\n\nMFractor will periodically notify you when an update is available.\n\n\nYou can also check for updates at any time by opening the \nVisual Studio Mac\n main menu and selecting \nCheck for Updates...\n\n\n\n\nVisual Studio Mac will check the MFractor extension server for updates and prompt you to update if there is a new version!\n\n\nUninstalling MFractor\n\n\nYou can uninstall MFractor through the Extension Manager at any time.\n\n\nSelect the \nVisual Studio Mac\n main menu and then \nAddins\n\n\nUnder \nGallery\n then \nIDE extensions\n select the MFractor extension list item and then click \nUninstall\n\n\nYou will be prompted to uninstall the extension, confirm uninstallation by clicking \nUninstall", 
            "title": "Installation And Setup"
        }, 
        {
            "location": "/installation-and-setup/#installation-and-setup", 
            "text": "Installing, activating and updating MFractor for Visual Studio Mac", 
            "title": "Installation And Setup"
        }, 
        {
            "location": "/installation-and-setup/#install-mfractor", 
            "text": "To install MFractor, start Visual Studio for Mac.  Next, navigate to the top left  Visual Studio Menu  and select  Extensions .  Next, click on the  Gallery  tab and under  IDE Extensions  choose  MFractor .", 
            "title": "Install MFractor"
        }, 
        {
            "location": "/installation-and-setup/#activating-mfractor", 
            "text": "When you first install MFractor, the activation dialog will open shortly after installation.  In the activation dialog, enter your email and name and then click  Activate .", 
            "title": "Activating MFractor"
        }, 
        {
            "location": "/installation-and-setup/#importing-a-professional-license", 
            "text": "Download and locate your license file (which ends with the extension  .lic ). When purchasing MFractor Professional, this license file will be provided in an email. In this example, our license file is located on our desktop called  license.lic .   Open Visual Studio for Mac. If you have not activated MFractor with an email address, close the activation window.   In the main Visual Studio for Mac menu bar, select  MFractor  and then  Licensing . This will open the licensing window where you can import or remove an MFractor Professional license.  Next, click on the  Import License  button, browse to the license file ( license.lic ) and double click it to import the license into MFractor.   It is safe to delete the license file from its original location. MFractor stores the license inside itself.   The licensing window will list:   Licensed To  - The full name of the person that the MFractor Professional license is issued to.  License Email:  - The email that this MFractor Professional license is issued against.  License Type and Expiry Date  - The type of license issued (Professional, Trial or Lite) and when that license expires.", 
            "title": "Importing A Professional License"
        }, 
        {
            "location": "/installation-and-setup/#deactivating-your-professional-license", 
            "text": "If you'd like to remove a license from MFractor, you can open the MFractor license information window and click  Remove License .  IMPORTANT: This is a destructive operation, you cannot undo removing a license but you can re-import a new license.  After removing a license, you will be automatically downgraded to a free MFractor license. This allows usage of most features apart from C# code actions, mobile-specific C# code diagnostics, and configuration file support.", 
            "title": "Deactivating Your Professional License"
        }, 
        {
            "location": "/installation-and-setup/#updating-mfractor", 
            "text": "MFractor will periodically notify you when an update is available.  You can also check for updates at any time by opening the  Visual Studio Mac  main menu and selecting  Check for Updates...   Visual Studio Mac will check the MFractor extension server for updates and prompt you to update if there is a new version!", 
            "title": "Updating MFractor"
        }, 
        {
            "location": "/installation-and-setup/#uninstalling-mfractor", 
            "text": "You can uninstall MFractor through the Extension Manager at any time.  Select the  Visual Studio Mac  main menu and then  Addins  Under  Gallery  then  IDE extensions  select the MFractor extension list item and then click  Uninstall  You will be prompted to uninstall the extension, confirm uninstallation by clicking  Uninstall", 
            "title": "Uninstalling MFractor"
        }, 
        {
            "location": "/mfractor-professional/", 
            "text": "About MFractor Professional\n\n\nEverything you need to know about the Lite and Professional version of MFractor for Visual Studio Mac\n\n\nLite VS Professional\n\n\nMFractor comes in both a free (Lite) and a paid (Professional) version.\n\n\nMFractor Lite is restricted to 4 XAML documents per day and does not include the Image Manager, C# tools or project pad actions.\n\n\nPurchase An MFractor Professional License\n\n\nRRP: $200AUD per user per year\n\n\nProfessional licenses:\n\n\n\n\nAre issued against a single developer.\n\n\nCan be used on up to 3 separate machines for a single developer.\n\n\nExpired 366 days after being issued.\n\n\nIncludes 1 year of maintenance for Professional features.\n\n\nIncludes priority for feature requests and bug fixes.\n\n\n\n\nMFractor Professional licenses can be purchased at \nhttps://www.mfractor.com/buy\n.\n\n\nRenewing A Professional License\n\n\nWhen your license has expired, you can purchase a new license at \nhttps://www.mfractor.com/buy\n. We will issue a new license for 366 + the period until your current license expires.\n\n\nRefund Policy\n\n\nEach purchase of MFractor comes with a 30 day refund period; If you would like a refund, please email \nmatthew@mfractor.com\n requesting a refund and the account details to transfer to. I will refund the full amount minus a $30AUD processing fee.\n\n\nTerms Of Use\n\n\n\n\nEach individual developer must have their own MFractor Professional license.\n\n\nAn individual developer can activate MFractor Professional on up-to 3 separate machines.\n\n\nMFractor Professional licenses expire after 366 days.\n\n\nIf an MFractor Professional license is not renewed, MFractor will automatically downgrade to the free license tier.", 
            "title": "About MFractor Professional"
        }, 
        {
            "location": "/mfractor-professional/#about-mfractor-professional", 
            "text": "Everything you need to know about the Lite and Professional version of MFractor for Visual Studio Mac", 
            "title": "About MFractor Professional"
        }, 
        {
            "location": "/mfractor-professional/#lite-vs-professional", 
            "text": "MFractor comes in both a free (Lite) and a paid (Professional) version.  MFractor Lite is restricted to 4 XAML documents per day and does not include the Image Manager, C# tools or project pad actions.", 
            "title": "Lite VS Professional"
        }, 
        {
            "location": "/mfractor-professional/#purchase-an-mfractor-professional-license", 
            "text": "RRP: $200AUD per user per year  Professional licenses:   Are issued against a single developer.  Can be used on up to 3 separate machines for a single developer.  Expired 366 days after being issued.  Includes 1 year of maintenance for Professional features.  Includes priority for feature requests and bug fixes.   MFractor Professional licenses can be purchased at  https://www.mfractor.com/buy .", 
            "title": "Purchase An MFractor Professional License"
        }, 
        {
            "location": "/mfractor-professional/#renewing-a-professional-license", 
            "text": "When your license has expired, you can purchase a new license at  https://www.mfractor.com/buy . We will issue a new license for 366 + the period until your current license expires.", 
            "title": "Renewing A Professional License"
        }, 
        {
            "location": "/mfractor-professional/#refund-policy", 
            "text": "Each purchase of MFractor comes with a 30 day refund period; If you would like a refund, please email  matthew@mfractor.com  requesting a refund and the account details to transfer to. I will refund the full amount minus a $30AUD processing fee.", 
            "title": "Refund Policy"
        }, 
        {
            "location": "/mfractor-professional/#terms-of-use", 
            "text": "Each individual developer must have their own MFractor Professional license.  An individual developer can activate MFractor Professional on up-to 3 separate machines.  MFractor Professional licenses expire after 366 days.  If an MFractor Professional license is not renewed, MFractor will automatically downgrade to the free license tier.", 
            "title": "Terms Of Use"
        }, 
        {
            "location": "/code-actions/", 
            "text": "Code Actions\n\n\nHow to use MFractors code fixes, actions and refactorings\n\n\nThe Essentials\n\n\nMFractor includes a suite of code actions to organise, refactor and generate source code.\n\n\nTo use MFractors code actions:\n\n\n\n\nPress \nAlt + Return\n within a C#, XAML or Android Resource document.\n\n\nRight click and select \nQuick Fix\n in a C# document.\n\n\n\n\n\n\nC# Code Actions\n\n\nMFractors C# code action suite integrates directly into Visual Studio Macs existing code action suite; you can simply press \nAlt+Return\n to view available code actions and then \nReturn\n to apply a code action.\n\n\nYou can view the full list of MFractors C# code actions here\n\n\nXAML Code Actions\n\n\nXAML code actions can be actioned when the current open is a Xamarin.Forms XAML document.\n\n\nIn addition to being accessible through the quick fix menu, XAML code actions can be action  \n\n\nThe XAML code actions come in 4 types:\n\n\n\n\nFix\n: Fixes code issues. This menu is only available when actioned over a code issue (yellow or red squiggle).\n\n\nOrganise\n: Organises XAML code. For example, sorting attributes or formatting a document.\n\n\nRefactor\n: Refactors XAML code: For example, renaming XAML namespaces or extracting property values into a view model.\n\n\nGenerate\n: Generates C# or XAML code. For example, implementing view models or creating resource dictionaries.\n\n\n\n\nAndroid Resource Code Actions\n\n\nAndroid code actions can be actioned when the current open is an Android resource; for example a menu, values or xml configuration file.\n\n\nDisclaimer: Support for Android resource code actions is currently very limited. This feature-set will be added to over time.", 
            "title": "Code Actions"
        }, 
        {
            "location": "/code-actions/#code-actions", 
            "text": "How to use MFractors code fixes, actions and refactorings", 
            "title": "Code Actions"
        }, 
        {
            "location": "/code-actions/#the-essentials", 
            "text": "MFractor includes a suite of code actions to organise, refactor and generate source code.  To use MFractors code actions:   Press  Alt + Return  within a C#, XAML or Android Resource document.  Right click and select  Quick Fix  in a C# document.", 
            "title": "The Essentials"
        }, 
        {
            "location": "/code-actions/#c-code-actions", 
            "text": "MFractors C# code action suite integrates directly into Visual Studio Macs existing code action suite; you can simply press  Alt+Return  to view available code actions and then  Return  to apply a code action.  You can view the full list of MFractors C# code actions here", 
            "title": "C# Code Actions"
        }, 
        {
            "location": "/code-actions/#xaml-code-actions", 
            "text": "XAML code actions can be actioned when the current open is a Xamarin.Forms XAML document.  In addition to being accessible through the quick fix menu, XAML code actions can be action    The XAML code actions come in 4 types:   Fix : Fixes code issues. This menu is only available when actioned over a code issue (yellow or red squiggle).  Organise : Organises XAML code. For example, sorting attributes or formatting a document.  Refactor : Refactors XAML code: For example, renaming XAML namespaces or extracting property values into a view model.  Generate : Generates C# or XAML code. For example, implementing view models or creating resource dictionaries.", 
            "title": "XAML Code Actions"
        }, 
        {
            "location": "/code-actions/#android-resource-code-actions", 
            "text": "Android code actions can be actioned when the current open is an Android resource; for example a menu, values or xml configuration file.  Disclaimer: Support for Android resource code actions is currently very limited. This feature-set will be added to over time.", 
            "title": "Android Resource Code Actions"
        }, 
        {
            "location": "/image-importing-wizard/", 
            "text": "Working With Images\n\n\nUsing MFractors image tooling to simplify working with your apps image resources\n\n\nUsing The Image Wizard\n\n\nWhen an Android and/or iOS project is within the active solution, the image wizard will become available.\n\n\nTo access the image wizard, go to the \nTools\n menu and then select \nImport Image Wizard\n:\n\n\n\n\nLet's examine each section of the image wizard:\n\n\n\n\n\n\n1:\n The file path selecter is used to choose your source image. Once chosen, it will appear as preview in the image pane to the right. MFractor supports importing png, jpg and jpeg images.\n\n\n2:\n The new name of this image resource. MFractor will warn you when the new image name contains characters that are invalid for an Android resource name. You can correct these naming issues using the \"Fix Image Name\" wand.\n\n\n3:\n The iOS and Android projects that you want to import the new image into. Here you can include or exclude certain projects, choose the image type (\nBundle Resource\n for iOS, \nMipMap\n or \nDrawable\n for Android) and select density the image represents.\n\n\n4:\n The image preview window will display the image you have chosen to import.\n\n\n5:\n The width and height of the image that will be imported.\n\n\n6:\n Click the \nImport Image\n button to import the image!\n\n\n\n\nWhen you click import, the new image \njonsnow.jpg\n will be placed into the selected projects:\n\n\n\n\nImage Downscaling\n\n\nWhen importing a new image resource, MFractor will automatically generate lower resolution versions of the image based on the \nImage Density\n you specific per project.\n\n\nFor iOS, MFractor uses the following scales and names:\n\n\n\n\n\n\n\n\nName\n\n\nOutput\n\n\nRelative Scale\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n@1x\n\n\nmyimage.png\n\n\n1\n\n\nResources\\myimage.png\n\n\n\n\n\n\n@2x\n\n\nmyimage@2x.png\n\n\n2\n\n\nResources\\myimage.png\n\n\n\n\n\n\n@3x\n\n\nmyimage@3x.png\n\n\n3\n\n\nResources\\myimage.png\n\n\n\n\n\n\n\n\nFor Android, MFractor uses the following scales and names:\n\n\n\n\n\n\n\n\nName\n\n\nOutput\n\n\nRelative Scale\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nldpi\n\n\n*-ldpi\\myimage.png\n\n\n0.75\n\n\nResources\\drawable-ldpi\\myimage.png\n\n\n\n\n\n\nmdpi\n\n\n*-mdpi\\myimage.png\n\n\n1\n\n\nResources\\drawable-mdpi\\myimage.png\n\n\n\n\n\n\nhdpi\n\n\n*-hdpi\\myimage.png\n\n\n1.5\n\n\nResources\\drawable-hdpi\\myimage.png\n\n\n\n\n\n\nxhdpi\n\n\n*-xhdpi\\myimage.png\n\n\n2\n\n\nResources\\drawable-xhdpi\\myimage.png\n\n\n\n\n\n\nxxhdpi\n\n\n*-xxhdpi\\myimage.png\n\n\n3\n\n\nResources\\drawable-xxhdpi\\myimage.png\n\n\n\n\n\n\nxxxhdpi\n\n\n*-xxxhdpi\\myimage.png\n\n\n4\n\n\nResources\\drawable-xxxhdpi\\myimage.png\n\n\n\n\n\n\n\n\nSay you chose \n@3x\n and \nxxhdpi\n as your source densities when importing a new image with the resolutions of 1000w by 1000h, MFractor would generate the following sizes:\n\n\niOS\n\n\n\n\n@3x\n: 1000w by 1000h (\n@3x\n / \n@3x\n)\n\n\n@2x\n: 666w by 666h (\n@2x\n / \n@3x\n)\n\n\n@1x\n: 333w by 333h (\n@1x\n / \n@3x\n)\n\n\n\n\nAndroid\n\n\n\n\nxxhdpi\n: 1000w by 1000h (\nxxhdpi\n / \nxxhdpi\n)\n\n\nxhdpi\n : 666w by 666h   (\nxhdpi\n / \nxxhdpi\n)\n\n\nhdpi\n  : 500w by 500h   (\nhdpi\n / \nxxhdpi\n)\n\n\nmdpi\n  : 333w by 333h   (\nmdpi\n / \nxxhdpi\n)\n\n\nldpi\n  : 250w by 250h   (\nldpi\n / \nxxhdpi\n)\n\n\n\n\nImage Type Conversion\n\n\nMFractor will the automatically convert images between formats.\n\n\nIf you provide a \npng\n image as the source image but change the image name to export a \njpg\n, MFractor will automatically convert the png to a jpg.\n\n\nAccessing The Image Wizard From XAML\n\n\nWhen you are developing a UI with XAML, the image wizard can be opened from a missing image resource.\n\n\nTo activate the image wizard from XAML, assign a missing image resource into an \nImageSource\n attribute and then activate the \"Import Image\" quick fix:\n\n\n\n\nHere you can select the image you want to import, specify the projects to place the image into, choose the image size and then import the new image.", 
            "title": "Image Importing Wizard"
        }, 
        {
            "location": "/image-importing-wizard/#working-with-images", 
            "text": "Using MFractors image tooling to simplify working with your apps image resources", 
            "title": "Working With Images"
        }, 
        {
            "location": "/image-importing-wizard/#using-the-image-wizard", 
            "text": "When an Android and/or iOS project is within the active solution, the image wizard will become available.  To access the image wizard, go to the  Tools  menu and then select  Import Image Wizard :   Let's examine each section of the image wizard:    1:  The file path selecter is used to choose your source image. Once chosen, it will appear as preview in the image pane to the right. MFractor supports importing png, jpg and jpeg images.  2:  The new name of this image resource. MFractor will warn you when the new image name contains characters that are invalid for an Android resource name. You can correct these naming issues using the \"Fix Image Name\" wand.  3:  The iOS and Android projects that you want to import the new image into. Here you can include or exclude certain projects, choose the image type ( Bundle Resource  for iOS,  MipMap  or  Drawable  for Android) and select density the image represents.  4:  The image preview window will display the image you have chosen to import.  5:  The width and height of the image that will be imported.  6:  Click the  Import Image  button to import the image!   When you click import, the new image  jonsnow.jpg  will be placed into the selected projects:", 
            "title": "Using The Image Wizard"
        }, 
        {
            "location": "/image-importing-wizard/#image-downscaling", 
            "text": "When importing a new image resource, MFractor will automatically generate lower resolution versions of the image based on the  Image Density  you specific per project.  For iOS, MFractor uses the following scales and names:     Name  Output  Relative Scale  Example      @1x  myimage.png  1  Resources\\myimage.png    @2x  myimage@2x.png  2  Resources\\myimage.png    @3x  myimage@3x.png  3  Resources\\myimage.png     For Android, MFractor uses the following scales and names:     Name  Output  Relative Scale  Example      ldpi  *-ldpi\\myimage.png  0.75  Resources\\drawable-ldpi\\myimage.png    mdpi  *-mdpi\\myimage.png  1  Resources\\drawable-mdpi\\myimage.png    hdpi  *-hdpi\\myimage.png  1.5  Resources\\drawable-hdpi\\myimage.png    xhdpi  *-xhdpi\\myimage.png  2  Resources\\drawable-xhdpi\\myimage.png    xxhdpi  *-xxhdpi\\myimage.png  3  Resources\\drawable-xxhdpi\\myimage.png    xxxhdpi  *-xxxhdpi\\myimage.png  4  Resources\\drawable-xxxhdpi\\myimage.png     Say you chose  @3x  and  xxhdpi  as your source densities when importing a new image with the resolutions of 1000w by 1000h, MFractor would generate the following sizes:  iOS   @3x : 1000w by 1000h ( @3x  /  @3x )  @2x : 666w by 666h ( @2x  /  @3x )  @1x : 333w by 333h ( @1x  /  @3x )   Android   xxhdpi : 1000w by 1000h ( xxhdpi  /  xxhdpi )  xhdpi  : 666w by 666h   ( xhdpi  /  xxhdpi )  hdpi   : 500w by 500h   ( hdpi  /  xxhdpi )  mdpi   : 333w by 333h   ( mdpi  /  xxhdpi )  ldpi   : 250w by 250h   ( ldpi  /  xxhdpi )", 
            "title": "Image Downscaling"
        }, 
        {
            "location": "/image-importing-wizard/#image-type-conversion", 
            "text": "MFractor will the automatically convert images between formats.  If you provide a  png  image as the source image but change the image name to export a  jpg , MFractor will automatically convert the png to a jpg.", 
            "title": "Image Type Conversion"
        }, 
        {
            "location": "/image-importing-wizard/#accessing-the-image-wizard-from-xaml", 
            "text": "When you are developing a UI with XAML, the image wizard can be opened from a missing image resource.  To activate the image wizard from XAML, assign a missing image resource into an  ImageSource  attribute and then activate the \"Import Image\" quick fix:   Here you can select the image you want to import, specify the projects to place the image into, choose the image size and then import the new image.", 
            "title": "Accessing The Image Wizard From XAML"
        }, 
        {
            "location": "/localisation-wizard/", 
            "text": "The Localisation Wizard\n\n\nUsing the localisation wizard to quickly and easily migrate string literals into application resources for localisation\n\n\nIntroduction\n\n\nWhen building apps, it's very common to put text that displays in the user interface directly inside your C# or XAML. However, there is usually a point where you will need to support more than just one language.\n\n\nThis presents a problem; you now need to convert all inline strings in XAML and C# into a localisation lookup, typically to a .resx file. The process of replacing each of these strings with a resource lookup is cumbersome, time-consume and error prone.\n\n\nTo make the process faster, you can use MFractor's Localisation Wizard.\n\n\nThe Localisation Wizard\n\n\nThe localisation wizard finds all localisable strings in a C# or XAML file and allows you to migrate them into your projects .resx files.\n\n\nOnce opened, the localisation wizard let's you step through all localisable strings within a document. You can choose the \n.resx\n file to place that string into, enter a key for the new resource and then selecting replace. Alternatively, you can apply the localisation action by press the \nReturn\n key.\n\n\nIf the string value already exists in the \n.resx\n file that you have chosen, MFractor warns you that it's a duplicate with a yellow exclamation icon. If you'd like to use the existing key for the string value, you can press \nShift+Return\n.\n\n\nLocalising XAML\n\n\nWhen localising XAML, MFractor expects that you are following Xamarins recommended localisation practices as outlined in \nLocalizing Xamarin.Forms Apps with RESX Resource Files\n\n\nIf you are just getting started with localising your XAML, you can use the \nGenerate Localisation Infrastructure\n code action to quickly setup the needed files.\n\n\nOtherwise, for the localisation wizard to activate in XAML you will need the following:\n\n\n\n\nA class named \nTranslateExtension\n located in a folder named \nil8n\n. It should resolve to the symbol \nMyAppsDefaultNamespace.il8n.TranslateExtension\n.\n\n\nOne or more .rex files.\n\n\n\n\nIf you'd like to use your own custom translation extension, you can target a different symbol by providing it's fully qualified type to the \nTranslateExtensionSymbol property in the string localisation generator\n.\n\n\nOnce you have setup the necessary infrastructure, you can open the localisation wizard by right clicking on any string literal that's provided to a bindable property and selecting \nReplace with a localised value lookup\n.\n\n\n\n\nLocalising CSharp\n\n\nIn order to localise a C# file, you will need to have at least one .resx file present in the project you are localising.\n\n\nWhen you have at least one \n.resx\n file, you can access the localisation wizard by pressing \nOption+Return\n on a string literal.\n\n\nUnder the quick fix menu that opens, choose \nReplace with resx lookup\n.\n\n\n\n\nConfiguration\n\n\nWhen using the loclaisation wizard, MFractor will choose the first resource file it finds; for some users this may be undesirable.\n\n\nIf you'd like to change the default \n.resx\n file that MFractor uses for localisation, you can customise it by including an MFractor configuration and targeting the \nDefault Resource File\n configuration.\n\n\napp.mfc.xml\n\n\nmfractor\n\n  \nconfigure id=\ncom.mfractor.configuration.resx.default_resource_file\n\n    \nproperty Name=\nProjectFilePath\n value=\nResources/Strings.resx\n/\n\n  \n/configure\n\n\n/mfractor", 
            "title": "Localisation Wizard"
        }, 
        {
            "location": "/localisation-wizard/#the-localisation-wizard", 
            "text": "Using the localisation wizard to quickly and easily migrate string literals into application resources for localisation", 
            "title": "The Localisation Wizard"
        }, 
        {
            "location": "/localisation-wizard/#introduction", 
            "text": "When building apps, it's very common to put text that displays in the user interface directly inside your C# or XAML. However, there is usually a point where you will need to support more than just one language.  This presents a problem; you now need to convert all inline strings in XAML and C# into a localisation lookup, typically to a .resx file. The process of replacing each of these strings with a resource lookup is cumbersome, time-consume and error prone.  To make the process faster, you can use MFractor's Localisation Wizard.", 
            "title": "Introduction"
        }, 
        {
            "location": "/localisation-wizard/#the-localisation-wizard_1", 
            "text": "The localisation wizard finds all localisable strings in a C# or XAML file and allows you to migrate them into your projects .resx files.  Once opened, the localisation wizard let's you step through all localisable strings within a document. You can choose the  .resx  file to place that string into, enter a key for the new resource and then selecting replace. Alternatively, you can apply the localisation action by press the  Return  key.  If the string value already exists in the  .resx  file that you have chosen, MFractor warns you that it's a duplicate with a yellow exclamation icon. If you'd like to use the existing key for the string value, you can press  Shift+Return .", 
            "title": "The Localisation Wizard"
        }, 
        {
            "location": "/localisation-wizard/#localising-xaml", 
            "text": "When localising XAML, MFractor expects that you are following Xamarins recommended localisation practices as outlined in  Localizing Xamarin.Forms Apps with RESX Resource Files  If you are just getting started with localising your XAML, you can use the  Generate Localisation Infrastructure  code action to quickly setup the needed files.  Otherwise, for the localisation wizard to activate in XAML you will need the following:   A class named  TranslateExtension  located in a folder named  il8n . It should resolve to the symbol  MyAppsDefaultNamespace.il8n.TranslateExtension .  One or more .rex files.   If you'd like to use your own custom translation extension, you can target a different symbol by providing it's fully qualified type to the  TranslateExtensionSymbol property in the string localisation generator .  Once you have setup the necessary infrastructure, you can open the localisation wizard by right clicking on any string literal that's provided to a bindable property and selecting  Replace with a localised value lookup .", 
            "title": "Localising XAML"
        }, 
        {
            "location": "/localisation-wizard/#localising-csharp", 
            "text": "In order to localise a C# file, you will need to have at least one .resx file present in the project you are localising.  When you have at least one  .resx  file, you can access the localisation wizard by pressing  Option+Return  on a string literal.  Under the quick fix menu that opens, choose  Replace with resx lookup .", 
            "title": "Localising CSharp"
        }, 
        {
            "location": "/localisation-wizard/#configuration", 
            "text": "When using the loclaisation wizard, MFractor will choose the first resource file it finds; for some users this may be undesirable.  If you'd like to change the default  .resx  file that MFractor uses for localisation, you can customise it by including an MFractor configuration and targeting the  Default Resource File  configuration.  app.mfc.xml  mfractor \n   configure id= com.mfractor.configuration.resx.default_resource_file \n     property Name= ProjectFilePath  value= Resources/Strings.resx / \n   /configure  /mfractor", 
            "title": "Configuration"
        }, 
        {
            "location": "/annotations/", 
            "text": "Using MFractor.Annotations\n\n\nUsing the MFractor.Annotations library to power mobile-specific C# code diagnostics\n\n\nIntroduction\n\n\nThe MFractor.Annotations library is a Nuget package that powers a suite of mobile-specific code diagnostics. When this library is installed and used in a .NET project, developers can annotate their code with MFractor attributes to activate features like the \nCheck Views Exist In Layout\n C# code analyser.\n\n\nInstalling the MFractor.Annotations NuGet\n\n\nTo add the MFractor.Annotations library into your project:\n\n\nRight click on 'Packages' and select 'Add Packages...'\n\n\n\n\nSearch for 'MFractor.Annotations' and select 'Add Package'\n\n\n\n\nTargeting A Layout In Xamarin.Android\n\n\nWhen working in Xamarin.Android, developers use layouts to define the UI contents for an \nActivity\n, \nFragment\n, \nView\n etc. A layout is connected to these UI components by either an \nSetContentView\n call (for Activities) or a \nInflate\n call. Developers then retrieve views from within that layout using the \nFindViewById\n method.\n\n\nFor example:\n\n\nMain.axml\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nLinearLayout xmlns:android=\nhttp://schemas.android.com/apk/res/android\n\n    android:orientation=\nvertical\n\n    android:layout_width=\nmatch_parent\n\n    android:layout_height=\nmatch_parent\n\n    \nButton\n        android:id=\n@+id/myButton\n\n        android:layout_width=\nmatch_parent\n\n        android:layout_height=\nwrap_content\n\n        android:text=\n@string/hello\n /\n\n\n/LinearLayout\n\n\n\n\n\nMainActivity.cs\n\n\n[Activity(Label = \nHelloMFractor\n, MainLauncher = true, Icon = \n@mipmap/icon\n)]\npublic class MainActivity : Activity\n{\n    protected override void OnCreate(Bundle savedInstanceState)\n    {\n        // Set our view from the \nmain\n layout resource\n        SetContentView(Resource.Layout.Main);\n\n        Button button = FindViewById\nButton\n(Resource.Id.myButton);\n        Button otherButton = FindViewById\nButton\n(Resource.Id.myOtherButton);\n    }\n}\n\n\n\n\nIn the \nMainActivity.cs\n example above, the second \nFindViewById\n call points to the \nButton\n declaration, \nmyOtherButton\n, that is not declared in the Main.axml layout. At runtime the \nFindViewById\n call will fail\n\n\nMFractor.Annotations includes the attribute \nUsesLayout\n that we can attach to a class declaration to tell MFractor what the expected layout for a call is\n\nMainActivity.cs\n\n\n[MFrator.Annotations.Android.UsesLayout(Resource.Layout.Main)]\n[Activity(Label = \nHelloMFractor\n, MainLauncher = true, Icon = \n@mipmap/icon\n)]\npublic class MainActivity : Activity\n{\n  // ...\n}\n\n\n\n\nThis activates the \nCheck Views Exist In Layout\n C# analyser; uses of \nFindViewById\n will be inspected and check that the view referenced by the \nResource.Id\n expression inspected exists in the layout specified by the \nUsesLayout\n attribute:", 
            "title": "Using MFractor.Annotations"
        }, 
        {
            "location": "/annotations/#using-mfractorannotations", 
            "text": "Using the MFractor.Annotations library to power mobile-specific C# code diagnostics", 
            "title": "Using MFractor.Annotations"
        }, 
        {
            "location": "/annotations/#introduction", 
            "text": "The MFractor.Annotations library is a Nuget package that powers a suite of mobile-specific code diagnostics. When this library is installed and used in a .NET project, developers can annotate their code with MFractor attributes to activate features like the  Check Views Exist In Layout  C# code analyser.", 
            "title": "Introduction"
        }, 
        {
            "location": "/annotations/#installing-the-mfractorannotations-nuget", 
            "text": "To add the MFractor.Annotations library into your project:  Right click on 'Packages' and select 'Add Packages...'   Search for 'MFractor.Annotations' and select 'Add Package'", 
            "title": "Installing the MFractor.Annotations NuGet"
        }, 
        {
            "location": "/annotations/#targeting-a-layout-in-xamarinandroid", 
            "text": "When working in Xamarin.Android, developers use layouts to define the UI contents for an  Activity ,  Fragment ,  View  etc. A layout is connected to these UI components by either an  SetContentView  call (for Activities) or a  Inflate  call. Developers then retrieve views from within that layout using the  FindViewById  method.  For example:  Main.axml  ?xml version= 1.0  encoding= utf-8 ?  LinearLayout xmlns:android= http://schemas.android.com/apk/res/android \n    android:orientation= vertical \n    android:layout_width= match_parent \n    android:layout_height= match_parent \n     Button\n        android:id= @+id/myButton \n        android:layout_width= match_parent \n        android:layout_height= wrap_content \n        android:text= @string/hello  /  /LinearLayout   MainActivity.cs  [Activity(Label =  HelloMFractor , MainLauncher = true, Icon =  @mipmap/icon )]\npublic class MainActivity : Activity\n{\n    protected override void OnCreate(Bundle savedInstanceState)\n    {\n        // Set our view from the  main  layout resource\n        SetContentView(Resource.Layout.Main);\n\n        Button button = FindViewById Button (Resource.Id.myButton);\n        Button otherButton = FindViewById Button (Resource.Id.myOtherButton);\n    }\n}  In the  MainActivity.cs  example above, the second  FindViewById  call points to the  Button  declaration,  myOtherButton , that is not declared in the Main.axml layout. At runtime the  FindViewById  call will fail  MFractor.Annotations includes the attribute  UsesLayout  that we can attach to a class declaration to tell MFractor what the expected layout for a call is MainActivity.cs  [MFrator.Annotations.Android.UsesLayout(Resource.Layout.Main)]\n[Activity(Label =  HelloMFractor , MainLauncher = true, Icon =  @mipmap/icon )]\npublic class MainActivity : Activity\n{\n  // ...\n}  This activates the  Check Views Exist In Layout  C# analyser; uses of  FindViewById  will be inspected and check that the view referenced by the  Resource.Id  expression inspected exists in the layout specified by the  UsesLayout  attribute:", 
            "title": "Targeting A Layout In Xamarin.Android"
        }, 
        {
            "location": "/configuration/getting-started/", 
            "text": "Configuration\n\n\nLearn to customise MFractor to your project needs\n\n\nConfiguring MFractor Files\n\n\nMFractor configuration files allow you to change the behaviour of MFractor to better suite it to your own working style.\n\n\nMFractor configuration files are an XML based file  \n.mfc.xml\n; a configuration file can be named anything and be placed in any directory in a project as long as it ends in the extension \n.mfc.xml\n.\n\n\nHow does it work? Let's consider the following configuration file:\n\n\napp.mfc.xml\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n ?\n\n\nmfractor\n\n        \n!-- Change the behaviour of the Implement View Model code action --\n\n    \nconfigure id=\ncom.mfractor.code_actions.xaml.implement_view_model\n\n            \nproperty name=\nBaseClass\n value=\nMyNamespace.ViewModels.ViewModelBase\n/\n\n    \n/configure\n\n\n/mfractor\n\n\n\n\n\nLet's examine each of the each element in the above configuration in depth:\n\n\n\n\nWe open a configuration file with the \nmfractor\n tag; this is ceremony to denote to MFractor this is a config file.\n\n\nWe \ntarget\n a configurable by using the \nconfigure\n element:\n\n\nThe \nid\n attribute specifies the unique identifier of the configurable we wish to modify. An id could refer a code action, a code generator or an analysis routine.\n\n\n\n\n\n\nWe \nmodify\n a property using the \nproperty\n element:\n\n\nThe \nname\n attribute specifies the configurable property we wish to edit.\n\n\nThe \nvalue\n attribute specifies the value we wish to set the property to.\n\n\n\n\n\n\n\n\nTargeting An Element for Configuration\n\n\nEvery element inside MFractor that can be configured has it's own unique \nconfiguration identifier\n. This a unique string that can be used to reference a particular code action, code generator, code analyser etc within MFractor.\n\n\nFor example, the Xamarin.Forms \nImplement View Model\n code action has the configuration identifier \ncom.mfractor.code_actions.xaml.implement_view_model\n.\n\n\nTo discover the ID of a feature you want to customise, locate that feature in MFractor's documentation; a features id is located below the heading inside the documentation:\n\n\n\n\nIf we wanted to change the behaviour of the \nImplement View Model\n code action, we add a \nconfigure\n element into our \n.mfc.xml\n and target the identifier \ncom.mfractor.code_actions.xaml.implement_view_model\n:\n\n\nconfigure id=\ncom.mfractor.code_actions.xaml.implement_view_model\n\n\n/configure\n\n\n\n\n\nInside the \nconfigure\n element we can now specify multiple \nproperty\n tags to change properties inside the configurable.\n\n\nConfiguring Properties\n\n\nAfter targeting a configurable, we can use \nConfigurable Properties\n to change the behaviour of that feature.\n\n\nConfigurable properties are settings that can be edited on a configurable through the use of the \nproperty\n tag.\n\n\nWe place a \nproperty\n tag inside a \nconfigure\n tag; we can then target the property name using the \nname\n attribute and apply a new value using the \nvalue\n attribute.\n\n\nFor example, we can change the output folder for new ViewModels by using a \nproperty\n setter on the \nViewModelsFolder\n property:\n\n\nconfigure id=\ncom.mfractor.code_actions.xaml.implement_view_model\n\n    \nproperty name=\nViewModelsFolder\n value=\nPath/To/ViewModelsFolder\n/\n\n\n/configure\n\n\n\n\n\nCode Generation Dependencies\n\n\nOften multiple code actions need to generate the same source; rather than configuring each code action separately each code action reuses a common \ncode generator\n. A code generator is a configurable that encapsulates the logic needed to generate a specific piece of code.\n\n\nFor example, both the \nImplement View Model\n and \nGenerate Missing Command\n use the \nGenerate ICommand Implementation\n code generator; this allows us to set the \nICommand\n type once and have the behaviour propagate through all code-actions that need to generate an ICommand implementation.\n\n\nThis documentation site lists the code-generation dependencies under the \nUses:\n section.\n\n\nHidden Configuration Files", 
            "title": "Getting Started"
        }, 
        {
            "location": "/configuration/getting-started/#configuration", 
            "text": "Learn to customise MFractor to your project needs", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/getting-started/#configuring-mfractor-files", 
            "text": "MFractor configuration files allow you to change the behaviour of MFractor to better suite it to your own working style.  MFractor configuration files are an XML based file   .mfc.xml ; a configuration file can be named anything and be placed in any directory in a project as long as it ends in the extension  .mfc.xml .  How does it work? Let's consider the following configuration file:  app.mfc.xml  ?xml version= 1.0  encoding= UTF-8  ?  mfractor \n         !-- Change the behaviour of the Implement View Model code action -- \n     configure id= com.mfractor.code_actions.xaml.implement_view_model \n             property name= BaseClass  value= MyNamespace.ViewModels.ViewModelBase / \n     /configure  /mfractor   Let's examine each of the each element in the above configuration in depth:   We open a configuration file with the  mfractor  tag; this is ceremony to denote to MFractor this is a config file.  We  target  a configurable by using the  configure  element:  The  id  attribute specifies the unique identifier of the configurable we wish to modify. An id could refer a code action, a code generator or an analysis routine.    We  modify  a property using the  property  element:  The  name  attribute specifies the configurable property we wish to edit.  The  value  attribute specifies the value we wish to set the property to.", 
            "title": "Configuring MFractor Files"
        }, 
        {
            "location": "/configuration/getting-started/#targeting-an-element-for-configuration", 
            "text": "Every element inside MFractor that can be configured has it's own unique  configuration identifier . This a unique string that can be used to reference a particular code action, code generator, code analyser etc within MFractor.  For example, the Xamarin.Forms  Implement View Model  code action has the configuration identifier  com.mfractor.code_actions.xaml.implement_view_model .  To discover the ID of a feature you want to customise, locate that feature in MFractor's documentation; a features id is located below the heading inside the documentation:   If we wanted to change the behaviour of the  Implement View Model  code action, we add a  configure  element into our  .mfc.xml  and target the identifier  com.mfractor.code_actions.xaml.implement_view_model :  configure id= com.mfractor.code_actions.xaml.implement_view_model  /configure   Inside the  configure  element we can now specify multiple  property  tags to change properties inside the configurable.", 
            "title": "Targeting An Element for Configuration"
        }, 
        {
            "location": "/configuration/getting-started/#configuring-properties", 
            "text": "After targeting a configurable, we can use  Configurable Properties  to change the behaviour of that feature.  Configurable properties are settings that can be edited on a configurable through the use of the  property  tag.  We place a  property  tag inside a  configure  tag; we can then target the property name using the  name  attribute and apply a new value using the  value  attribute.  For example, we can change the output folder for new ViewModels by using a  property  setter on the  ViewModelsFolder  property:  configure id= com.mfractor.code_actions.xaml.implement_view_model \n     property name= ViewModelsFolder  value= Path/To/ViewModelsFolder /  /configure", 
            "title": "Configuring Properties"
        }, 
        {
            "location": "/configuration/getting-started/#code-generation-dependencies", 
            "text": "Often multiple code actions need to generate the same source; rather than configuring each code action separately each code action reuses a common  code generator . A code generator is a configurable that encapsulates the logic needed to generate a specific piece of code.  For example, both the  Implement View Model  and  Generate Missing Command  use the  Generate ICommand Implementation  code generator; this allows us to set the  ICommand  type once and have the behaviour propagate through all code-actions that need to generate an ICommand implementation.  This documentation site lists the code-generation dependencies under the  Uses:  section.", 
            "title": "Code Generation Dependencies"
        }, 
        {
            "location": "/configuration/getting-started/#hidden-configuration-files", 
            "text": "", 
            "title": "Hidden Configuration Files"
        }, 
        {
            "location": "/configuration/configurable-items/", 
            "text": "Configurable Items\n\n\nAutogenerated by MFractor v3.7.3\n\n\nAndroid Custom Renderer Code Snippets\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPageRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the page that this custom renderer is for.\ncontrol_name\n: The name of the page that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for customised pages.\n\n\n\n\n\n\nLayoutRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the layout that this custom renderer is for.\ncontrol_name\n: The name of the layout that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for customised layouts.\n\n\n\n\n\n\nViewRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the control that this custom renderer is for.\ncontrol_name\n: The name of the control that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for customised controls.\n\n\n\n\n\n\nCellRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the control that this custom renderer is for.\ncontrol_name\n: The name of the control that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for customised cells in ListViews.\n\n\n\n\n\n\nRenderersFolder\n\n\nSystem.String\n\n\nRenderers\n\n\nWhat is the folder path that new renderers should be placed into?\n\n\n\n\n\n\nRenderersNamespace\n\n\nSystem.String\n\n\n.Renderers\n\n\nWhat is the fully qualifed namespace that new renderers should be placed into? Prepend the namespace name with a dot to make it relative to the projects default namespace.\n\n\n\n\n\n\n\n\nApplication Name Configuration\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAppXamlFileName\n\n\nSystem.String\n\n\nApp.xaml\n\n\nThe name of the App.xaml file for the project.\n\n\n\n\n\n\n\n\nBehaviors Configuration\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBehaviorsFolder\n\n\nSystem.String\n\n\nBehaviors\n\n\nThe default folder to place new behaviors into.\n\n\n\n\n\n\nBehaviorsNamespace\n\n\nSystem.String\n\n\n.Behaviors\n\n\nThe default names that new behaviors will be placed into. Prepending the namespace with a \n.\n will cause the namespace to be appended to the projects default namespace.\n\n\n\n\n\n\n\n\nCreate Class Declaration\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nImplementBaseConstructors\n\n\nBoolean\n\n\nFalse\n\n\nShould the base class constructors be automatically created?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nMember Field Generator\n\n\nGenerate Instance Property\n\n\nMethod Generator\n\n\nCreate Base Constructor\n\n\nGenerate Event Handler Declaration\n\n\n\n\nCreate Constructor\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nArgumentFirstLetterToLowerCase\n\n\nBoolean\n\n\nTrue\n\n\nShould all constructor arguments have their first letter forced to lower case?\n\n\n\n\n\n\n\n\nCreate Missing Property For Class\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nTryInferUnknownTypes\n\n\nBoolean\n\n\nTrue\n\n\nShould MFractor attempt to guess the type for the new property based on it's value? EG: A value of \ntrue\n would cause the output type to be \nbool\n instead of \nSystem.Object\n.\n\n\n\n\n\n\nDefaultColorType\n\n\nSystem.String\n\n\nXamarin.Forms.Color\n\n\nWhen attempting to infer the property type based on its value and MFractor decides it's a color, what is the color type MFractor should use?\n\n\n\n\n\n\nDefaultPropertyType\n\n\nSystem.String\n\n\nSystem.Object\n\n\nWhat is the default type for the new property if MFractor can't figure it out based on the attribute value?\n\n\n\n\n\n\nDefaultImageType\n\n\nSystem.String\n\n\nXamarin.Forms.ImageSource\n\n\nWhen attempting to infer the property type based on its value and MFractor decides it's an image, what is the CLR type MFractor should use?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Bindable Property\n\n\nView Model Property Generator\n\n\nGenerate Event Handler Declaration\n\n\n\n\nCreate StaticResource Lookup In Code Behind\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLookupSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the resource to lookup\ntype\n: The type of the resource to loooup\n\n\npublic $type$ $name$ =\n ($type$)Resources[\"$name$\"];\n\n\nThe default code snippet to use when generating a resource lookup on a VisualElement.\n\n\n\n\n\n\nApplicationLookupSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the resource to lookup\ntype\n: The type of the resource to loooup\n\n\npublic static $type$ $name$ =\n ($type$)Application.Current.Resources[\"$name$\"];\n\n\nThe default code snippet to use when generating a resource lookup on the apps Application class.\n\n\n\n\n\n\n\n\nCustom Controls Configuration\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nControlsFolder\n\n\nSystem.String\n\n\nControls\n\n\nWhat is the folder that new controls should be placed into?\n\n\n\n\n\n\nControlsNamespace\n\n\nSystem.String\n\n\n.Controls\n\n\nWhat is the default namespace the new controls be placed into?\n\n\n\n\n\n\n\n\nData Template Selector Code Generator\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The namespace that the new DataTemplateSelector should be placed within.\nname\n: The name of the new DataTemplateSelector\n\n\nView Code Snippet\n\n\nThe code snippet for  to insert onto the code behind class to target a design time binding context.\n\n\n\n\n\n\nNamespace\n\n\nSystem.String\n\n\n.DataTemplateSelectors\n\n\nThe\n\n\n\n\n\n\n\n\nDefault Resource File\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nProjectFilePath\n\n\nSystem.String\n\n\nResources/Resources.resx\n\n\nWhat is the default resource file that string resources should be placed into?\n\n\n\n\n\n\n\n\nDesign Time Binding Context Attribute\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAnnotationSnippet\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The namespace that the design time binding context resides inside.\ntype\n: The type to use as the design time binding context.\n\n\n[$namespace$.DesignTimeBindingContext(typeof($type$))]\n\n\nThe annotation to insert onto the code behind class to target a design time binding context.\n\n\n\n\n\n\nDesignTimeBindingContextAttributeFileName\n\n\nSystem.String\n\n\nDesignTimeBindingContextAttribute.cs\n\n\nWhat is the filename to use when creating the design time binding context?\n\n\n\n\n\n\nDesignTimeBindingContextAttributeFolderPath\n\n\nSystem.String\n\n\nAttributes\n\n\nWhat is the project folder path to place the  to use when creating the default design time binding context?\n\n\n\n\n\n\n\n\nEncapsulate Content Page Children With StackLayout\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultOrientation\n\n\nSystem.String\n\n\n\n\nWhat is the default orientation for the \nStackLayout\n that is created for this fix? If empty, an \nOrientation\n attribute is not inserted.\n\n\n\n\n\n\n\n\nEncapsulate Content View Children With StackLayout\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultOrientation\n\n\nSystem.String\n\n\n\n\nWhat is the default orientation for the \nStackLayout\n that is created for this fix? If empty, an \nOrientation\n attribute is not inserted.\n\n\n\n\n\n\n\n\nEncapsulate Scroll View Children With StackLayout\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultOrientation\n\n\nSystem.String\n\n\n\n\nWhat is the default orientation for the \nStackLayout\n that is created for this fix? If empty, an \nOrientation\n attribute is not inserted.\n\n\n\n\n\n\n\n\nEvent To Command Behavior Configuration\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nEventToCommandBehaviorSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the event to command behaviour\nnamespace\n: The namespace that encapsulates the event to command behaviour\n\n\nView Code Snippet\n\n\nThe code snippet to use for the event to command behavior.\n\n\n\n\n\n\nSelectedItemEventArgsToSelectedItemConverterSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the converter.\nnamespace\n: The namespace that encapsulates the converter\n\n\nView Code Snippet\n\n\nThe code snippet to use for the \nSelectedItemEventArgsToSelectedItemConverter\n.\n\n\n\n\n\n\nEventToCommandBehaviorName\n\n\nSystem.String\n\n\nEventToCommandBehavior\n\n\nThe class name of the event to command behavior.\n\n\n\n\n\n\nSelectedItemEventArgsToSelectedItemConverterName\n\n\nSystem.String\n\n\nSelectedItemEventArgsToSelectedItemConverter\n\n\nThe class name of the event to command behavior class.\n\n\n\n\n\n\n\n\nExtract Resource Dictionary\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultXamlNamespace\n\n\nSystem.String\n\n\nresources\n\n\nWhat is the default name of the XAML namespace for the new control?\n\n\n\n\n\n\nDefaultResourcesFolder\n\n\nSystem.String\n\n\nResource Dictionaries\n\n\nWhat is the default folder that the new  of the C# namespace for the new resource? If empty, the projects default namespace will be used.\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate View With XAML and Code-Behind Class\n\n\n\n\nExtract XAML Into Control\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultXamlNamespace\n\n\nSystem.String\n\n\ncontrols\n\n\nWhat is the default name of the XAML namespace for the new control?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate View With XAML and Code-Behind Class\n\n\nCustom Controls Configuration\n\n\n\n\nFormat Xaml Document\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAttributesOnSeparateLines\n\n\nBoolean\n\n\nFalse\n\n\nShould attributes be placed onto separate lines?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nSort Attributes\n\n\n\n\nGenerate Assignment Expression\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIncludeThisForMembers\n\n\nBoolean\n\n\nFalse\n\n\nWhen assigning to a class member, should a \nthis.\n be added to the variable being assigned?\n\n\n\n\n\n\n\n\nGenerate Bindable Property\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new bindable property.\ntype\n: The type of the new bindable property.\ncontrol_type\n: The control type that the new bindable property has been created inside.\n\n\nView Code Snippet\n\n\nWhen creating the new bindable property, what is the default code snippet MFractor should use?\n\n\n\n\n\n\n\n\nGenerate Event Handler Declaration\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new event handler.\nevent_type\n: The fully qualified type of the event handler.\narguments_type\n: The fully qualified type of the event arguments.\n\n\npublic event $event_type$\n$argument_type$\n $name$;\n\n\nWhat is the code snippet to use when creating a new event handler?\n\n\n\n\n\n\n\n\nGenerate Event Handler Method\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new method.\ntype\n: The fully qualified type of the event arguments.\n\n\npublic void $name$(object sender, $type$ e)\n{\n    throw new System.NotImplementedException();\n}\n\n\nWhat is the code snippet to use when creating the new event handler method declaration?\n\n\n\n\n\n\n\n\nGenerate Grid\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIncludeColumnDefinitions\n\n\nBoolean\n\n\nTrue\n\n\nShould the new grid include a \nColumnDefinitions\n element by default?\n\n\n\n\n\n\nIncludeRowDefinitions\n\n\nBoolean\n\n\nTrue\n\n\nShould the new grid include a \nRowDefinitions\n element by default?\n\n\n\n\n\n\nDefaultRowsCount\n\n\nInteger\n\n\n1\n\n\nWhat is the default amount of rows that the new grid should have?\n\n\n\n\n\n\nDefaultColumnsCount\n\n\nInteger\n\n\n1\n\n\nWhat is the default amount of columns that the new grid should have?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Grid Row Definition\n\n\nGenerate Grid Column Definition\n\n\n\n\nGenerate Grid Column Definition\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultWidthValue\n\n\nSystem.String\n\n\n*\n\n\nWhen creating a new \nColumnDefinition\n for a grid, what is the default width value.\n\n\n\n\n\n\n\n\nGenerate Grid Row Definition\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultHeightValue\n\n\nSystem.String\n\n\n*\n\n\nWhen creating a new \nRowDefinition\n for a grid, what is the default height of a newly created row?\n\n\n\n\n\n\n\n\nGenerate ICommand Implementation\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new command.\ntype\n: The fully qualified type of the new command\n\n\nView Code Snippet\n\n\nWhat is the code snippet to use when creating the command stub? If not set, this code generator will default to generating a stub \nXamarin.Forms.Command\n implementation\n\n\n\n\n\n\nCommandType\n\n\nSystem.String\n\n\nXamarin.Forms.Command\n\n\nThe fully qualified type to use as the command implementation. For example, using \nXamarin.Forms.Command\n would cause the new expression to be \nnew Xamarin.Forms.Command\n\n\n\n\n\n\n\n\nGenerate Instance Property\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\ntype\n: The fully qualified type of the new property.\nname\n: The name of the new propety.\nvalue\n: The value to assign to the new property.\n\n\npublic $type$ $name$\n{\n    set;\n}\n\n\nWhat is the code snippet to use when creating the property declaration?\n\n\n\n\n\n\nReadOnlySnippet\n\n\nCode Snippet\nArguments\n:\ntype\n: The fully qualified type of the new property.\nname\n: The name of the new propety.\nvalue\n: The value to assign to the new property.\n\n\npublic $type$ $name$\n{\n    get;\n}\n\n\nWhat is the code snippet to use when creating a readonly property declaration?\n\n\n\n\n\n\nWriteOnlySnippet\n\n\nCode Snippet\nArguments\n:\ntype\n: The fully qualified type of the new property.\nname\n: The name of the new propety.\nvalue\n: The value to assign to the new property.\n\n\npublic $type$ $name$\n{\n    get;\n    set;\n}\n\n\nWhat is the code snippet to use when creating a write only property declaration?\n\n\n\n\n\n\n\n\nGenerate IValueConverter Implementation\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCreateMissingValueConversionAttribute\n\n\nBoolean\n\n\nTrue\n\n\nIf an implementation of the ValueConversionAttribute class cannot be resolved within the project compilation, should MFractor automatically create the implementation?\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new value converter.\nnamespace\n: The namespace the new converter will be placed inside.\nvalue_conversion_attribute\n: The fully qualified type of the value conversion attribute (if available).\ninput_type\n: The fully qualified type that the value converter should accept as it's input type. If unavailable, defaults to \nSystem.Object\n.\noutput_type\n: The fully qualified type that the value converter should accept as it's output type. If unavailable, defaults to \nSystem.Object\n.\nparameter_type\n: The fully qualified type that the value converter should accept as it's parameter type. If unavailable, defaults to \nSystem.Object\n.\n\n\nView Code Snippet\n\n\nWhat is the code snippet to use when generating the value converter class file?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Value Conversion Attribute\n\n\nValue Conversion Settings\n\n\n\n\nGenerate Member Initialiser\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nForceStringLiteral\n\n\nBoolean\n\n\nFalse\n\n\nShould the code generator always attempt to assign members with a string literal?\n\n\n\n\n\n\n\n\nGenerate New Value Converter For Type Flow\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultConverterNamespace\n\n\nSystem.String\n\n\nconverters\n\n\nThe namespace name of the xmlns import statement for the newly created value converter\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate IValueConverter Implementation\n\n\n\n\nGenerate New View Model\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBaseClass\n\n\nSystem.String\n\n\nnull\n\n\nThe fully qualified type to use as the base class for the view model. For example, \nMvvmFramework.ViewModels.BaseViewModel\n.\n\n\n\n\n\n\nViewModelsFolder\n\n\nSystem.String\n\n\nViewModels\n\n\nThe folder path relative to the project root to insert the newly created view model class into. For example \nViewModels/Cells\n.\n\n\n\n\n\n\nViewModelSuffix\n\n\nSystem.String\n\n\nViewModel\n\n\nThe suffix to append to the end of the newly created view model. For example, setting this to \nPageModel\n would cause a page named \nMainPage\n to create a view model named \nMainPageModel\n.\n\n\n\n\n\n\nShouldPlaceViewModelWithView\n\n\nBoolean\n\n\nFalse\n\n\nWhen generating the new ViewModel, should it be placed in the same folder and namespace as the XAML view that is creating it? Setting this property to true will cause the ViewModelNamespace and ViewModelsFolderproperties to be ignored.\n\n\n\n\n\n\nViewModelNamespace\n\n\nSystem.String\n\n\nnull\n\n\nWhat is the default namespace that view models be included into? Use a '.' before the namespace to signify to MFractor that the new namespace is relative to the projects default namespace. If unset, the default project namespace is used.\n\n\n\n\n\n\nShouldRemoveXamlViewSuffix\n\n\nBoolean\n\n\nTrue\n\n\nShould MFractor remove the 'Page' or 'View' suffix from the view name before creating generating the new view model? Consider the view 'MainPage' with ViewModelSuffix set to 'ViewModel'; if set as true, the new view model would be named 'MainViewModel'. If false, the new view model would be named 'MainPageViewModel'\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate ICommand Implementation\n\n\nUsing Directive Generator\n\n\nCreate Class Declaration\n\n\nNamespace Declaration\n\n\nView Model Property Generator\n\n\nMVVM Resolution Settings\n\n\n\n\nGenerate Page And View Model\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nViewBaseClass\n\n\nSystem.String\n\n\nXamarin.Forms.ContentPage\n\n\nWhat is the default base class that should be used when creating the page and it's code behind?\n\n\n\n\n\n\nViewSuffix\n\n\nSystem.String\n\n\nPage\n\n\nWhat is the suffix to use when creating a new page?\n\n\n\n\n\n\nViewsFolder\n\n\nSystem.String\n\n\nPages\n\n\nWhere should new views be placed?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate View With XAML and Code-Behind Class\n\n\nGenerate New View Model\n\n\nUsing Directive Generator\n\n\nCreate Class Declaration\n\n\nNamespace Declaration\n\n\nMVVM Resolution Settings\n\n\n\n\nGenerate Platform Specific Effect\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIOSEffectsFolder\n\n\nSystem.String\n\n\nEffects\n\n\nWhat is the folder that iOS platform-specific effects should be placed into?\n\n\n\n\n\n\nAndroidEffectsFolder\n\n\nSystem.String\n\n\nEffects\n\n\nWhat is the folder that Android platform-specific effects should be placed into?\n\n\n\n\n\n\nEffectsFolder\n\n\nSystem.String\n\n\nEffects\n\n\nWhat is the folder that the effects declaration be placed into?\n\n\n\n\n\n\nResolutionGroupName\n\n\nSystem.String\n\n\nEffects\n\n\nWhat is the name of the resolution group?\n\n\n\n\n\n\nIOSEffectSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new effect.\ngroup_name\n: The resolution group name of the new effect.\nnamespace\n: The iOS projects default namespace.\nplatform\n: If you wish to shared the platform-specific effect template, this is the name of the effects platform.\n\n\nView Code Snippet\n\n\nWhat is the code snippet for the iOS platform-specific effect?\n\n\n\n\n\n\nAndroidEffectSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new effect.\ngroup_name\n: The resolution group name of the new effect.\nnamespace\n: The Android projects default namespace.\nplatform\n: If you wish to shared the platform-specific effect template, this is the name of the effects platform.\n\n\nView Code Snippet\n\n\nWhat is the code snippet for the Android platform-specific effect?\n\n\n\n\n\n\nGtkEffectSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new effect.\ngroup_name\n: The resolution group name of the new effect.\nnamespace\n: The GTK projects default namespace.\nplatform\n: If you wish to shared the platform-specific effect template, this is the name of the effects platform.\n\n\nView Code Snippet\n\n\nWhat is the code snippet for the GTK platform-specific effect?\n\n\n\n\n\n\nEffectSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new effect.\ngroup_name\n: The resolution group name of the new effect.\nnamespace\n: The common projects default namespace.\n\n\nView Code Snippet\n\n\nWhat is the code snippet for the effect?\n\n\n\n\n\n\n\n\nGenerate ResX Entry\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIncludeCommentWhenEmpty\n\n\nBoolean\n\n\nFalse\n\n\nWhen no comment for the new ResX entry has been provided, should an empty comment tag be included?\n\n\n\n\n\n\n\n\nGenerate ResX File\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nResXTemplate\n\n\nCode Snippet\nArguments\n:\nvalues\n: The values to insert\n\n\nView Code Snippet\n\n\nThe default .resx file template.\n\n\n\n\n\n\nResXDesignerTemplate\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The namespace of the \n\n\nView Code Snippet\n\n\nThe default designer file template for a .resx resource.\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate ResX Entry\n\n\n\n\nGenerate Value Conversion Attribute\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The namespace that the new value conversion attribute should be placed within.\n\n\nView Code Snippet\n\n\nWhat is the default code snippet to use when creating the value conversion attribute implementation?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nValue Conversion Settings\n\n\n\n\nGenerate View With XAML and Code-Behind Class\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultViewClass\n\n\nSystem.String\n\n\nXamarin.Forms.View\n\n\nWhat is the default class to use when creating new views?\n\n\n\n\n\n\nViewSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new class.\nnamespace\n: The namespace that the new class resides inside.\ntype\n: The base type of the new class.\n\n\n?xml version=\"1.0\" encoding=\"UTF-8\"?\n$type$ xmlns=\"http://xamarin.com/schemas/2014/forms\"\n  xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n  x:Class=\"$namespace$.$name$\"\n\n\nWhat is the default implementation of the new XAML control's XAML file?\n\n\n\n\n\n\nCodeBehindSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new class.\nnamespace\n: The namespace that the new class resides inside.\ntype\n: The base type of the new class.\n\n\nView Code Snippet\n\n\nWhat is the default implementation of the new XAML control's code behind class?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nUsing Directive Generator\n\n\nNamespace Declaration\n\n\n\n\nGenerates Xamarin.Forms Cascading Style Sheet\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol\n: The name of the control that this style sheet is for. EG: \nstackLayout\n, \nentry\n, \nview\n etc\n\n\n$control$  {\n    margin:10;\n}\n\n\nThe default cascading style sheet to use.\n\n\n\n\n\n\nStyleFolder\n\n\nSystem.String\n\n\nStyles\n\n\nWhat is the folder to place new style sheets into?\n\n\n\n\n\n\nDefaultControl\n\n\nSystem.String\n\n\nview\n\n\nWhat is the default control to use when generating new style sheets?\n\n\n\n\n\n\n\n\nGoogle Cloud Translation\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nApiKey\n\n\nSystem.String\n\n\nnull\n\n\nWhat is the API key for the Google Cloud Translation API?\n\n\n\n\n\n\n\n\nIOS Custom Renderer Code Snippets\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPageRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the page that this custom renderer is for.\ncontrol_name\n: The name of the page that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for customised pages.\n\n\n\n\n\n\nLayoutRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the layout that this custom renderer is for.\ncontrol_name\n: The name of the layou that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for customised layouts.\n\n\n\n\n\n\nViewRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the control that this custom renderer is for.\ncontrol_name\n: The name of the control that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for cu stomised controls.\n\n\n\n\n\n\nCellRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the control that this custom renderer is for.\ncontrol_name\n: The name of the control that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for customised cells in ListViews.\n\n\n\n\n\n\nRenderersFolder\n\n\nSystem.String\n\n\nRenderers\n\n\nWhat is the folder path that new renderers should be placed into?\n\n\n\n\n\n\nRenderersNamespace\n\n\nSystem.String\n\n\n.Renderers\n\n\nWhat is the fully qualifed namespace that new renderers should be placed into? Prepend the namespace name with a dot to make it relative to the projects default namespace.\n\n\n\n\n\n\n\n\nLinker File Generation\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultLinkerFileName\n\n\nSystem.String\n\n\nlinker.xml\n\n\nWhen creating a new linker file for iOS and Android projects, what is it's name?\n\n\n\n\n\n\nDefaultLinkerFileFolder\n\n\nSystem.String\n\n\nProperties\n\n\nWhen creating a new linker file for iOS and Android projects, which folder should it be placed within?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nLinker XML Generator\n\n\n\n\nMember Field Generator\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUnderscoreOnBackingField\n\n\nBoolean\n\n\nFalse\n\n\nWhen creating a backing field for a property, should the field have an underscore appended to the start of the field name?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Member Initialiser\n\n\n\n\nMVVM Resolution Settings\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nViewsProjectName\n\n\nSystem.String\n\n\nnull\n\n\nIf the apps XAML views and view models are in separate projects, what is the name of project that contains the XAML views?\n\n\n\n\n\n\nViewModelsProjectName\n\n\nSystem.String\n\n\nnull\n\n\nIf the apps XAML views and view models are in separate projects, what is the name of project that contains the ViewModels?\n\n\n\n\n\n\n\n\nRemove Unused Namespaces\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nShouldSort\n\n\nBoolean\n\n\nTrue\n\n\nIf the attributes for this node should be sorted when the unused namespaces are removed\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nSort Attributes\n\n\n\n\nString Localisation Generator\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nTranslateExtensionSymbol\n\n\nSystem.String\n\n\n.i18n.TranslateExtension\n\n\nWhat is the full sybol name (namespace + class name) of the translate markup extension? Prepend the symbol name with a dot to make it relative to the projects default namespace. For example, using \n.Localisation.TranslateExtension\n when the default namespace is \nMyApp\n would cause the full symbol name to become \nMyApp.Localisation.TranslateExtension\n.\n\n\n\n\n\n\nTranslationXamlNamespace\n\n\nSystem.String\n\n\ni18n\n\n\nWhen importing a XAML namespace reference to the translation extension, what is the default namespace name that should be used?\n\n\n\n\n\n\nXamlLocalisationExpression\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The xml namespace for the translate extension symbol when used in XAML.\ntranslate_extension\n: The name of the translation extension that's used to lookup a localised value for a given key.\nkey\n: The key that's used to lookup a localised value in this applications resources.\nresx_name\n: The name of the RESX file to look into for the given key, excluding the \n.resx\n file extension.\n\n\n{$namespace$:$translate_extension$ $key$}\n\n\nWhen importing a XAML namespace reference to the translation extension, what is the default namespace name that should be used?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate ResX Entry\n\n\nDefault Resource File\n\n\nResX Localisation Values Provider\n\n\n\n\nValue Conversion Settings\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nNamespace\n\n\nSystem.String\n\n\n.Converters\n\n\nThe namespace to place value conversion code inside. When empty, new value conversion code will be placed under the projects default namespace. Place a single '.' before the namespace name to make it relative to the projects default namespace.\n\n\n\n\n\n\nFolder\n\n\nSystem.String\n\n\nConverters\n\n\nThe folder to place value conversion code inside. When empty, new value conversion code will be placed inside the proejcts root folder.\n\n\n\n\n\n\nDefaultConverterXmlns\n\n\nSystem.String\n\n\nconverters\n\n\nThe namespace name of the xmlns import statement for the newly created value converter\n\n\n\n\n\n\n\n\nView Model Property Generator\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\ntype\n: The fully qualified type of the new property.\nname\n: The name of the new property.\n\n\npublic $type$ $name$\n{\n    get;\n    set;\n}\n\n\nWhat is the code snippet to use when creating the property declaration?\n\n\n\n\n\n\nValueSnippet\n\n\nCode Snippet\nArguments\n:\ntype\n: The fully qualified type of the new property.\nname\n: The name of the new property.\nvalue\n: The value to assign to the new property.\n\n\npublic $type$ $name$\n{\n    get;\n    set;\n} = $value$;\n\n\nWhat is the code snippet to use when creating a property declaration with a default value?\n\n\n\n\n\n\nDefaultEnumerableType\n\n\nSystem.String\n\n\nSystem.Collections.Generic.List\n\n\nWhen the new view model property is an \nIEnumerable\n, what is the default type that should be used instead of \nIEnumerable\n? To use the provided \nIEnumerable\n type, set this to an empty string.\n\n\n\n\n\n\n\n\nXAML Localisation Infrastructure Generation\n\n\nFull Documentation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLocalisationFolder\n\n\nSystem.String\n\n\ni18n\n\n\nWhat is the folder that the translation extension and localiser class should be placed into?\n\n\n\n\n\n\nLocaliserName\n\n\nSystem.String\n\n\nILocale\n\n\nWhat is the name of the class that provides the culture information for translation extension?\n\n\n\n\n\n\nILocaliserSnippet\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The projects namespace\nname\n: The name of the new localiser interface. Defaults to \nILocale\n\n\nView Code Snippet\n\n\nThe code snippet to use for the \nILocalise\n interface that each platform project should implement.\n\n\n\n\n\n\nTranslateExtensionSnippet\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The projects namespace\nname\n: The name of the translation extension class. This will be derived from the string localisation generations \nTranslateExtensionSymbol\n property.\nresource\n: The fully qualified type of the resource file that the translate extension should use when looking for localisation values. This will be provided by the apps default resource file config.\nlocaliser\n: The name of the localisation interface that provides the current culture.\n\n\nView Code Snippet\n\n\nThe code snippet to use for the translation extension.\n\n\n\n\n\n\nAndroidLocaliserClassName\n\n\nSystem.String\n\n\nLocale_Android\n\n\nWhat is the name of the Android localiser class?\n\n\n\n\n\n\nAndroidLocaliseSnippet\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The projects namespace\ni18n_namespace\n: The namespace that the translate extension and ILocale interface live within\nlocaliser\n: The name of the localisation interface that provides the current culture.\n\n\nView Code Snippet\n\n\nThe code snippet to use for the Android implementation of the localization interface to provide the current culture.\n\n\n\n\n\n\nIOSLocaliserClassName\n\n\nSystem.String\n\n\nLocale_iOS\n\n\nWhat is the name of the iOS localiser class?\n\n\n\n\n\n\nIOSLocaliseSnippet\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The projects namespace\ni18n_namespace\n: The namespace that the translate extension and ILocale interface live within\nlocaliser\n: The name of the localisation interface that provides the current culture.\n\n\nView Code Snippet\n\n\nThe code snippet to use for the iOS implementation of the localization interface to provide the current culture.\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nString Localisation Generator\n\n\nDefault Resource File\n\n\nGenerate ResX File", 
            "title": "Configurable Items"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-items", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "Configurable Items"
        }, 
        {
            "location": "/configuration/configurable-items/#android-custom-renderer-code-snippets", 
            "text": "Full Documentation", 
            "title": "Android Custom Renderer Code Snippets"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      PageRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the page that this custom renderer is for. control_name : The name of the page that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for customised pages.    LayoutRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the layout that this custom renderer is for. control_name : The name of the layout that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for customised layouts.    ViewRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the control that this custom renderer is for. control_name : The name of the control that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for customised controls.    CellRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the control that this custom renderer is for. control_name : The name of the control that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for customised cells in ListViews.    RenderersFolder  System.String  Renderers  What is the folder path that new renderers should be placed into?    RenderersNamespace  System.String  .Renderers  What is the fully qualifed namespace that new renderers should be placed into? Prepend the namespace name with a dot to make it relative to the projects default namespace.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#application-name-configuration", 
            "text": "Full Documentation", 
            "title": "Application Name Configuration"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_1", 
            "text": "Name  Type  Defaults To  Description      AppXamlFileName  System.String  App.xaml  The name of the App.xaml file for the project.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#behaviors-configuration", 
            "text": "Full Documentation", 
            "title": "Behaviors Configuration"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_2", 
            "text": "Name  Type  Defaults To  Description      BehaviorsFolder  System.String  Behaviors  The default folder to place new behaviors into.    BehaviorsNamespace  System.String  .Behaviors  The default names that new behaviors will be placed into. Prepending the namespace with a  .  will cause the namespace to be appended to the projects default namespace.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#create-class-declaration", 
            "text": "Full Documentation", 
            "title": "Create Class Declaration"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_3", 
            "text": "Name  Type  Defaults To  Description      ImplementBaseConstructors  Boolean  False  Should the base class constructors be automatically created?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses", 
            "text": "Member Field Generator  Generate Instance Property  Method Generator  Create Base Constructor  Generate Event Handler Declaration", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#create-constructor", 
            "text": "Full Documentation", 
            "title": "Create Constructor"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_4", 
            "text": "Name  Type  Defaults To  Description      ArgumentFirstLetterToLowerCase  Boolean  True  Should all constructor arguments have their first letter forced to lower case?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#create-missing-property-for-class", 
            "text": "Full Documentation", 
            "title": "Create Missing Property For Class"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_5", 
            "text": "Name  Type  Defaults To  Description      TryInferUnknownTypes  Boolean  True  Should MFractor attempt to guess the type for the new property based on it's value? EG: A value of  true  would cause the output type to be  bool  instead of  System.Object .    DefaultColorType  System.String  Xamarin.Forms.Color  When attempting to infer the property type based on its value and MFractor decides it's a color, what is the color type MFractor should use?    DefaultPropertyType  System.String  System.Object  What is the default type for the new property if MFractor can't figure it out based on the attribute value?    DefaultImageType  System.String  Xamarin.Forms.ImageSource  When attempting to infer the property type based on its value and MFractor decides it's an image, what is the CLR type MFractor should use?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_1", 
            "text": "Generate Bindable Property  View Model Property Generator  Generate Event Handler Declaration", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#create-staticresource-lookup-in-code-behind", 
            "text": "Full Documentation", 
            "title": "Create StaticResource Lookup In Code Behind"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_6", 
            "text": "Name  Type  Defaults To  Description      LookupSnippet  Code Snippet Arguments : name : The name of the resource to lookup type : The type of the resource to loooup  public $type$ $name$ =  ($type$)Resources[\"$name$\"];  The default code snippet to use when generating a resource lookup on a VisualElement.    ApplicationLookupSnippet  Code Snippet Arguments : name : The name of the resource to lookup type : The type of the resource to loooup  public static $type$ $name$ =  ($type$)Application.Current.Resources[\"$name$\"];  The default code snippet to use when generating a resource lookup on the apps Application class.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#custom-controls-configuration", 
            "text": "Full Documentation", 
            "title": "Custom Controls Configuration"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_7", 
            "text": "Name  Type  Defaults To  Description      ControlsFolder  System.String  Controls  What is the folder that new controls should be placed into?    ControlsNamespace  System.String  .Controls  What is the default namespace the new controls be placed into?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#data-template-selector-code-generator", 
            "text": "Full Documentation", 
            "title": "Data Template Selector Code Generator"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_8", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : namespace : The namespace that the new DataTemplateSelector should be placed within. name : The name of the new DataTemplateSelector  View Code Snippet  The code snippet for  to insert onto the code behind class to target a design time binding context.    Namespace  System.String  .DataTemplateSelectors  The", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#default-resource-file", 
            "text": "Full Documentation", 
            "title": "Default Resource File"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_9", 
            "text": "Name  Type  Defaults To  Description      ProjectFilePath  System.String  Resources/Resources.resx  What is the default resource file that string resources should be placed into?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#design-time-binding-context-attribute", 
            "text": "Full Documentation", 
            "title": "Design Time Binding Context Attribute"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_10", 
            "text": "Name  Type  Defaults To  Description      AnnotationSnippet  Code Snippet Arguments : namespace : The namespace that the design time binding context resides inside. type : The type to use as the design time binding context.  [$namespace$.DesignTimeBindingContext(typeof($type$))]  The annotation to insert onto the code behind class to target a design time binding context.    DesignTimeBindingContextAttributeFileName  System.String  DesignTimeBindingContextAttribute.cs  What is the filename to use when creating the design time binding context?    DesignTimeBindingContextAttributeFolderPath  System.String  Attributes  What is the project folder path to place the  to use when creating the default design time binding context?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#encapsulate-content-page-children-with-stacklayout", 
            "text": "Full Documentation", 
            "title": "Encapsulate Content Page Children With StackLayout"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_11", 
            "text": "Name  Type  Defaults To  Description      DefaultOrientation  System.String   What is the default orientation for the  StackLayout  that is created for this fix? If empty, an  Orientation  attribute is not inserted.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#encapsulate-content-view-children-with-stacklayout", 
            "text": "Full Documentation", 
            "title": "Encapsulate Content View Children With StackLayout"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_12", 
            "text": "Name  Type  Defaults To  Description      DefaultOrientation  System.String   What is the default orientation for the  StackLayout  that is created for this fix? If empty, an  Orientation  attribute is not inserted.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#encapsulate-scroll-view-children-with-stacklayout", 
            "text": "Full Documentation", 
            "title": "Encapsulate Scroll View Children With StackLayout"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_13", 
            "text": "Name  Type  Defaults To  Description      DefaultOrientation  System.String   What is the default orientation for the  StackLayout  that is created for this fix? If empty, an  Orientation  attribute is not inserted.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#event-to-command-behavior-configuration", 
            "text": "Full Documentation", 
            "title": "Event To Command Behavior Configuration"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_14", 
            "text": "Name  Type  Defaults To  Description      EventToCommandBehaviorSnippet  Code Snippet Arguments : name : The name of the event to command behaviour namespace : The namespace that encapsulates the event to command behaviour  View Code Snippet  The code snippet to use for the event to command behavior.    SelectedItemEventArgsToSelectedItemConverterSnippet  Code Snippet Arguments : name : The name of the converter. namespace : The namespace that encapsulates the converter  View Code Snippet  The code snippet to use for the  SelectedItemEventArgsToSelectedItemConverter .    EventToCommandBehaviorName  System.String  EventToCommandBehavior  The class name of the event to command behavior.    SelectedItemEventArgsToSelectedItemConverterName  System.String  SelectedItemEventArgsToSelectedItemConverter  The class name of the event to command behavior class.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#extract-resource-dictionary", 
            "text": "Full Documentation", 
            "title": "Extract Resource Dictionary"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_15", 
            "text": "Name  Type  Defaults To  Description      DefaultXamlNamespace  System.String  resources  What is the default name of the XAML namespace for the new control?    DefaultResourcesFolder  System.String  Resource Dictionaries  What is the default folder that the new  of the C# namespace for the new resource? If empty, the projects default namespace will be used.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_2", 
            "text": "Generate View With XAML and Code-Behind Class", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#extract-xaml-into-control", 
            "text": "Full Documentation", 
            "title": "Extract XAML Into Control"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_16", 
            "text": "Name  Type  Defaults To  Description      DefaultXamlNamespace  System.String  controls  What is the default name of the XAML namespace for the new control?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_3", 
            "text": "Generate View With XAML and Code-Behind Class  Custom Controls Configuration", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#format-xaml-document", 
            "text": "Full Documentation", 
            "title": "Format Xaml Document"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_17", 
            "text": "Name  Type  Defaults To  Description      AttributesOnSeparateLines  Boolean  False  Should attributes be placed onto separate lines?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_4", 
            "text": "Sort Attributes", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-assignment-expression", 
            "text": "Full Documentation", 
            "title": "Generate Assignment Expression"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_18", 
            "text": "Name  Type  Defaults To  Description      IncludeThisForMembers  Boolean  False  When assigning to a class member, should a  this.  be added to the variable being assigned?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-bindable-property", 
            "text": "Full Documentation", 
            "title": "Generate Bindable Property"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_19", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : name : The name of the new bindable property. type : The type of the new bindable property. control_type : The control type that the new bindable property has been created inside.  View Code Snippet  When creating the new bindable property, what is the default code snippet MFractor should use?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-event-handler-declaration", 
            "text": "Full Documentation", 
            "title": "Generate Event Handler Declaration"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_20", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : name : The name of the new event handler. event_type : The fully qualified type of the event handler. arguments_type : The fully qualified type of the event arguments.  public event $event_type$ $argument_type$  $name$;  What is the code snippet to use when creating a new event handler?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-event-handler-method", 
            "text": "Full Documentation", 
            "title": "Generate Event Handler Method"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_21", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : name : The name of the new method. type : The fully qualified type of the event arguments.  public void $name$(object sender, $type$ e) {     throw new System.NotImplementedException(); }  What is the code snippet to use when creating the new event handler method declaration?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-grid", 
            "text": "Full Documentation", 
            "title": "Generate Grid"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_22", 
            "text": "Name  Type  Defaults To  Description      IncludeColumnDefinitions  Boolean  True  Should the new grid include a  ColumnDefinitions  element by default?    IncludeRowDefinitions  Boolean  True  Should the new grid include a  RowDefinitions  element by default?    DefaultRowsCount  Integer  1  What is the default amount of rows that the new grid should have?    DefaultColumnsCount  Integer  1  What is the default amount of columns that the new grid should have?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_5", 
            "text": "Generate Grid Row Definition  Generate Grid Column Definition", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-grid-column-definition", 
            "text": "Full Documentation", 
            "title": "Generate Grid Column Definition"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_23", 
            "text": "Name  Type  Defaults To  Description      DefaultWidthValue  System.String  *  When creating a new  ColumnDefinition  for a grid, what is the default width value.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-grid-row-definition", 
            "text": "Full Documentation", 
            "title": "Generate Grid Row Definition"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_24", 
            "text": "Name  Type  Defaults To  Description      DefaultHeightValue  System.String  *  When creating a new  RowDefinition  for a grid, what is the default height of a newly created row?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-icommand-implementation", 
            "text": "Full Documentation", 
            "title": "Generate ICommand Implementation"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_25", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : name : The name of the new command. type : The fully qualified type of the new command  View Code Snippet  What is the code snippet to use when creating the command stub? If not set, this code generator will default to generating a stub  Xamarin.Forms.Command  implementation    CommandType  System.String  Xamarin.Forms.Command  The fully qualified type to use as the command implementation. For example, using  Xamarin.Forms.Command  would cause the new expression to be  new Xamarin.Forms.Command", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-instance-property", 
            "text": "Full Documentation", 
            "title": "Generate Instance Property"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_26", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : type : The fully qualified type of the new property. name : The name of the new propety. value : The value to assign to the new property.  public $type$ $name$ {     set; }  What is the code snippet to use when creating the property declaration?    ReadOnlySnippet  Code Snippet Arguments : type : The fully qualified type of the new property. name : The name of the new propety. value : The value to assign to the new property.  public $type$ $name$ {     get; }  What is the code snippet to use when creating a readonly property declaration?    WriteOnlySnippet  Code Snippet Arguments : type : The fully qualified type of the new property. name : The name of the new propety. value : The value to assign to the new property.  public $type$ $name$ {     get;     set; }  What is the code snippet to use when creating a write only property declaration?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-ivalueconverter-implementation", 
            "text": "Full Documentation", 
            "title": "Generate IValueConverter Implementation"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_27", 
            "text": "Name  Type  Defaults To  Description      CreateMissingValueConversionAttribute  Boolean  True  If an implementation of the ValueConversionAttribute class cannot be resolved within the project compilation, should MFractor automatically create the implementation?    Snippet  Code Snippet Arguments : name : The name of the new value converter. namespace : The namespace the new converter will be placed inside. value_conversion_attribute : The fully qualified type of the value conversion attribute (if available). input_type : The fully qualified type that the value converter should accept as it's input type. If unavailable, defaults to  System.Object . output_type : The fully qualified type that the value converter should accept as it's output type. If unavailable, defaults to  System.Object . parameter_type : The fully qualified type that the value converter should accept as it's parameter type. If unavailable, defaults to  System.Object .  View Code Snippet  What is the code snippet to use when generating the value converter class file?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_6", 
            "text": "Generate Value Conversion Attribute  Value Conversion Settings", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-member-initialiser", 
            "text": "Full Documentation", 
            "title": "Generate Member Initialiser"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_28", 
            "text": "Name  Type  Defaults To  Description      ForceStringLiteral  Boolean  False  Should the code generator always attempt to assign members with a string literal?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-new-value-converter-for-type-flow", 
            "text": "Full Documentation", 
            "title": "Generate New Value Converter For Type Flow"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_29", 
            "text": "Name  Type  Defaults To  Description      DefaultConverterNamespace  System.String  converters  The namespace name of the xmlns import statement for the newly created value converter", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_7", 
            "text": "Generate IValueConverter Implementation", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-new-view-model", 
            "text": "Full Documentation", 
            "title": "Generate New View Model"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_30", 
            "text": "Name  Type  Defaults To  Description      BaseClass  System.String  null  The fully qualified type to use as the base class for the view model. For example,  MvvmFramework.ViewModels.BaseViewModel .    ViewModelsFolder  System.String  ViewModels  The folder path relative to the project root to insert the newly created view model class into. For example  ViewModels/Cells .    ViewModelSuffix  System.String  ViewModel  The suffix to append to the end of the newly created view model. For example, setting this to  PageModel  would cause a page named  MainPage  to create a view model named  MainPageModel .    ShouldPlaceViewModelWithView  Boolean  False  When generating the new ViewModel, should it be placed in the same folder and namespace as the XAML view that is creating it? Setting this property to true will cause the ViewModelNamespace and ViewModelsFolderproperties to be ignored.    ViewModelNamespace  System.String  null  What is the default namespace that view models be included into? Use a '.' before the namespace to signify to MFractor that the new namespace is relative to the projects default namespace. If unset, the default project namespace is used.    ShouldRemoveXamlViewSuffix  Boolean  True  Should MFractor remove the 'Page' or 'View' suffix from the view name before creating generating the new view model? Consider the view 'MainPage' with ViewModelSuffix set to 'ViewModel'; if set as true, the new view model would be named 'MainViewModel'. If false, the new view model would be named 'MainPageViewModel'", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_8", 
            "text": "Generate ICommand Implementation  Using Directive Generator  Create Class Declaration  Namespace Declaration  View Model Property Generator  MVVM Resolution Settings", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-page-and-view-model", 
            "text": "Full Documentation", 
            "title": "Generate Page And View Model"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_31", 
            "text": "Name  Type  Defaults To  Description      ViewBaseClass  System.String  Xamarin.Forms.ContentPage  What is the default base class that should be used when creating the page and it's code behind?    ViewSuffix  System.String  Page  What is the suffix to use when creating a new page?    ViewsFolder  System.String  Pages  Where should new views be placed?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_9", 
            "text": "Generate View With XAML and Code-Behind Class  Generate New View Model  Using Directive Generator  Create Class Declaration  Namespace Declaration  MVVM Resolution Settings", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-platform-specific-effect", 
            "text": "Full Documentation", 
            "title": "Generate Platform Specific Effect"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_32", 
            "text": "Name  Type  Defaults To  Description      IOSEffectsFolder  System.String  Effects  What is the folder that iOS platform-specific effects should be placed into?    AndroidEffectsFolder  System.String  Effects  What is the folder that Android platform-specific effects should be placed into?    EffectsFolder  System.String  Effects  What is the folder that the effects declaration be placed into?    ResolutionGroupName  System.String  Effects  What is the name of the resolution group?    IOSEffectSnippet  Code Snippet Arguments : name : The name of the new effect. group_name : The resolution group name of the new effect. namespace : The iOS projects default namespace. platform : If you wish to shared the platform-specific effect template, this is the name of the effects platform.  View Code Snippet  What is the code snippet for the iOS platform-specific effect?    AndroidEffectSnippet  Code Snippet Arguments : name : The name of the new effect. group_name : The resolution group name of the new effect. namespace : The Android projects default namespace. platform : If you wish to shared the platform-specific effect template, this is the name of the effects platform.  View Code Snippet  What is the code snippet for the Android platform-specific effect?    GtkEffectSnippet  Code Snippet Arguments : name : The name of the new effect. group_name : The resolution group name of the new effect. namespace : The GTK projects default namespace. platform : If you wish to shared the platform-specific effect template, this is the name of the effects platform.  View Code Snippet  What is the code snippet for the GTK platform-specific effect?    EffectSnippet  Code Snippet Arguments : name : The name of the new effect. group_name : The resolution group name of the new effect. namespace : The common projects default namespace.  View Code Snippet  What is the code snippet for the effect?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-resx-entry", 
            "text": "Full Documentation", 
            "title": "Generate ResX Entry"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_33", 
            "text": "Name  Type  Defaults To  Description      IncludeCommentWhenEmpty  Boolean  False  When no comment for the new ResX entry has been provided, should an empty comment tag be included?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-resx-file", 
            "text": "Full Documentation", 
            "title": "Generate ResX File"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_34", 
            "text": "Name  Type  Defaults To  Description      ResXTemplate  Code Snippet Arguments : values : The values to insert  View Code Snippet  The default .resx file template.    ResXDesignerTemplate  Code Snippet Arguments : namespace : The namespace of the   View Code Snippet  The default designer file template for a .resx resource.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_10", 
            "text": "Generate ResX Entry", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-value-conversion-attribute", 
            "text": "Full Documentation", 
            "title": "Generate Value Conversion Attribute"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_35", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : namespace : The namespace that the new value conversion attribute should be placed within.  View Code Snippet  What is the default code snippet to use when creating the value conversion attribute implementation?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_11", 
            "text": "Value Conversion Settings", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#generate-view-with-xaml-and-code-behind-class", 
            "text": "Full Documentation", 
            "title": "Generate View With XAML and Code-Behind Class"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_36", 
            "text": "Name  Type  Defaults To  Description      DefaultViewClass  System.String  Xamarin.Forms.View  What is the default class to use when creating new views?    ViewSnippet  Code Snippet Arguments : name : The name of the new class. namespace : The namespace that the new class resides inside. type : The base type of the new class.  ?xml version=\"1.0\" encoding=\"UTF-8\"? $type$ xmlns=\"http://xamarin.com/schemas/2014/forms\"   xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"   x:Class=\"$namespace$.$name$\"  What is the default implementation of the new XAML control's XAML file?    CodeBehindSnippet  Code Snippet Arguments : name : The name of the new class. namespace : The namespace that the new class resides inside. type : The base type of the new class.  View Code Snippet  What is the default implementation of the new XAML control's code behind class?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_12", 
            "text": "Using Directive Generator  Namespace Declaration", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#generates-xamarinforms-cascading-style-sheet", 
            "text": "Full Documentation", 
            "title": "Generates Xamarin.Forms Cascading Style Sheet"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_37", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : control : The name of the control that this style sheet is for. EG:  stackLayout ,  entry ,  view  etc  $control$  {     margin:10; }  The default cascading style sheet to use.    StyleFolder  System.String  Styles  What is the folder to place new style sheets into?    DefaultControl  System.String  view  What is the default control to use when generating new style sheets?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#google-cloud-translation", 
            "text": "Full Documentation", 
            "title": "Google Cloud Translation"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_38", 
            "text": "Name  Type  Defaults To  Description      ApiKey  System.String  null  What is the API key for the Google Cloud Translation API?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#ios-custom-renderer-code-snippets", 
            "text": "Full Documentation", 
            "title": "IOS Custom Renderer Code Snippets"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_39", 
            "text": "Name  Type  Defaults To  Description      PageRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the page that this custom renderer is for. control_name : The name of the page that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for customised pages.    LayoutRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the layout that this custom renderer is for. control_name : The name of the layou that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for customised layouts.    ViewRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the control that this custom renderer is for. control_name : The name of the control that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for cu stomised controls.    CellRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the control that this custom renderer is for. control_name : The name of the control that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for customised cells in ListViews.    RenderersFolder  System.String  Renderers  What is the folder path that new renderers should be placed into?    RenderersNamespace  System.String  .Renderers  What is the fully qualifed namespace that new renderers should be placed into? Prepend the namespace name with a dot to make it relative to the projects default namespace.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#linker-file-generation", 
            "text": "Full Documentation", 
            "title": "Linker File Generation"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_40", 
            "text": "Name  Type  Defaults To  Description      DefaultLinkerFileName  System.String  linker.xml  When creating a new linker file for iOS and Android projects, what is it's name?    DefaultLinkerFileFolder  System.String  Properties  When creating a new linker file for iOS and Android projects, which folder should it be placed within?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_13", 
            "text": "Linker XML Generator", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#member-field-generator", 
            "text": "Full Documentation", 
            "title": "Member Field Generator"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_41", 
            "text": "Name  Type  Defaults To  Description      UnderscoreOnBackingField  Boolean  False  When creating a backing field for a property, should the field have an underscore appended to the start of the field name?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_14", 
            "text": "Generate Member Initialiser", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#mvvm-resolution-settings", 
            "text": "Full Documentation", 
            "title": "MVVM Resolution Settings"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_42", 
            "text": "Name  Type  Defaults To  Description      ViewsProjectName  System.String  null  If the apps XAML views and view models are in separate projects, what is the name of project that contains the XAML views?    ViewModelsProjectName  System.String  null  If the apps XAML views and view models are in separate projects, what is the name of project that contains the ViewModels?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#remove-unused-namespaces", 
            "text": "Full Documentation", 
            "title": "Remove Unused Namespaces"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_43", 
            "text": "Name  Type  Defaults To  Description      ShouldSort  Boolean  True  If the attributes for this node should be sorted when the unused namespaces are removed", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_15", 
            "text": "Sort Attributes", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#string-localisation-generator", 
            "text": "Full Documentation", 
            "title": "String Localisation Generator"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_44", 
            "text": "Name  Type  Defaults To  Description      TranslateExtensionSymbol  System.String  .i18n.TranslateExtension  What is the full sybol name (namespace + class name) of the translate markup extension? Prepend the symbol name with a dot to make it relative to the projects default namespace. For example, using  .Localisation.TranslateExtension  when the default namespace is  MyApp  would cause the full symbol name to become  MyApp.Localisation.TranslateExtension .    TranslationXamlNamespace  System.String  i18n  When importing a XAML namespace reference to the translation extension, what is the default namespace name that should be used?    XamlLocalisationExpression  Code Snippet Arguments : namespace : The xml namespace for the translate extension symbol when used in XAML. translate_extension : The name of the translation extension that's used to lookup a localised value for a given key. key : The key that's used to lookup a localised value in this applications resources. resx_name : The name of the RESX file to look into for the given key, excluding the  .resx  file extension.  {$namespace$:$translate_extension$ $key$}  When importing a XAML namespace reference to the translation extension, what is the default namespace name that should be used?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_16", 
            "text": "Generate ResX Entry  Default Resource File  ResX Localisation Values Provider", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/configurable-items/#value-conversion-settings", 
            "text": "Full Documentation", 
            "title": "Value Conversion Settings"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_45", 
            "text": "Name  Type  Defaults To  Description      Namespace  System.String  .Converters  The namespace to place value conversion code inside. When empty, new value conversion code will be placed under the projects default namespace. Place a single '.' before the namespace name to make it relative to the projects default namespace.    Folder  System.String  Converters  The folder to place value conversion code inside. When empty, new value conversion code will be placed inside the proejcts root folder.    DefaultConverterXmlns  System.String  converters  The namespace name of the xmlns import statement for the newly created value converter", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#view-model-property-generator", 
            "text": "Full Documentation", 
            "title": "View Model Property Generator"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_46", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : type : The fully qualified type of the new property. name : The name of the new property.  public $type$ $name$ {     get;     set; }  What is the code snippet to use when creating the property declaration?    ValueSnippet  Code Snippet Arguments : type : The fully qualified type of the new property. name : The name of the new property. value : The value to assign to the new property.  public $type$ $name$ {     get;     set; } = $value$;  What is the code snippet to use when creating a property declaration with a default value?    DefaultEnumerableType  System.String  System.Collections.Generic.List  When the new view model property is an  IEnumerable , what is the default type that should be used instead of  IEnumerable ? To use the provided  IEnumerable  type, set this to an empty string.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#xaml-localisation-infrastructure-generation", 
            "text": "Full Documentation", 
            "title": "XAML Localisation Infrastructure Generation"
        }, 
        {
            "location": "/configuration/configurable-items/#configurable-properties_47", 
            "text": "Name  Type  Defaults To  Description      LocalisationFolder  System.String  i18n  What is the folder that the translation extension and localiser class should be placed into?    LocaliserName  System.String  ILocale  What is the name of the class that provides the culture information for translation extension?    ILocaliserSnippet  Code Snippet Arguments : namespace : The projects namespace name : The name of the new localiser interface. Defaults to  ILocale  View Code Snippet  The code snippet to use for the  ILocalise  interface that each platform project should implement.    TranslateExtensionSnippet  Code Snippet Arguments : namespace : The projects namespace name : The name of the translation extension class. This will be derived from the string localisation generations  TranslateExtensionSymbol  property. resource : The fully qualified type of the resource file that the translate extension should use when looking for localisation values. This will be provided by the apps default resource file config. localiser : The name of the localisation interface that provides the current culture.  View Code Snippet  The code snippet to use for the translation extension.    AndroidLocaliserClassName  System.String  Locale_Android  What is the name of the Android localiser class?    AndroidLocaliseSnippet  Code Snippet Arguments : namespace : The projects namespace i18n_namespace : The namespace that the translate extension and ILocale interface live within localiser : The name of the localisation interface that provides the current culture.  View Code Snippet  The code snippet to use for the Android implementation of the localization interface to provide the current culture.    IOSLocaliserClassName  System.String  Locale_iOS  What is the name of the iOS localiser class?    IOSLocaliseSnippet  Code Snippet Arguments : namespace : The projects namespace i18n_namespace : The namespace that the translate extension and ILocale interface live within localiser : The name of the localisation interface that provides the current culture.  View Code Snippet  The code snippet to use for the iOS implementation of the localization interface to provide the current culture.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/configurable-items/#uses_17", 
            "text": "String Localisation Generator  Default Resource File  Generate ResX File", 
            "title": "Uses:"
        }, 
        {
            "location": "/configuration/code-snippets/", 
            "text": "Code Snippets\n\n\nUsing Code Snippets to completely customise the code that MFractor generates\n\n\nIntroduction\n\n\nAs a software developer and MFractor user you'll likely find that MFractor, by default, doesn't quite generate code that's suited to your projects conventions.\n\n\nLuckily, we can configure many of MFractor's code actions to use a custom code snippet when generating code!\n\n\nCode Snippet Basics\n\n\nMFractor uses the same conventions for code snippets as the Visual Studio family; you write a C# code block and replace areas that can be substituted with arguments enclosed in \n$\n.\n\n\nFor example, the following code snippet specifies the body for a property that calls the \nNotifyPropertyChanged\n method:\n\n\nprivate $type$ _$name$;\npublic $type$ $name$\n{\n    get\n    {\n        return _$name$;\n    }\n    set\n    {\n        _$name$ = value;\n        NotifyPropertyChanged(nameof($name$));\n    }\n}\n\n\n\n\nTo control the type of the new property, we've replaced each spot where the property type would be used with the code snippet argument \n$type$\n. Likewise, we've done the same with the \n$name$\n argument.\n\n\nIf the new property was a \nstring\n with the name \nMessage\n, MFractor would subsitute each occurance of \n$type$\n with \nstring\n and each occurance of \n$name$\n with \nMessage\n like so:\n\n\nprivate string _Message;\npublic string Message\n{\n    get\n    {\n        return _Message;\n    }\n    set\n    {\n        _Message = value;\n        NotifyPropertyChanged(nameof(Message));\n    }\n}\n\n\n\n\nWhen possible, MFractor's internal code generators use a code snippet to create code. These code snippets are exposed as configurable properties and are named \nSnippet\n.\n\n\nTo identify what you can\n\n\nWe can customise MFractor by providing code snippets through two sources: \nVisual Studio for Macs snippets\n and \ncode snippets included within your project\n.\n\n\nUsing Visual Studio Macs Code Snippets\n\n\nTo enable MFractor to use a code snippet from Visual Studio Mac, we need to create a code snippet inside Visual Studio Mac and then link it up through an MFractor config file.\n\n\nIn the top menu bar, click on \nVisual Studio\n and then \nPreferences\n:\n\n\n\n\nIn the preferences window that opens, browse to \nCode Snippets...\n and then select \nAdd\n:\n\n\n\n\nThis will open the \nNew template\n wizard. For this code snippet we'll create a template for a new property that triggers a property changed method.\n\n\nWe'll set our code snippets name to \nnotify_changed_property\n and enter the , define our code as below:\n\n\n\n\nLastly, we need to tell MFractor to use our code snippet when generating view model properties. We do this through an MFractor configuraiton file.\n\n\nCreate a file named \napp.mfc.xml\n in the root directory with the following content:\n\n\nmfractor\n\n  \nconfigure id=\ncom.mfractor.code_gen.forms.csharp.view_model_property\n\n    \nproperty name=\nSnippet\n source=\nide\n value=\nnotify_changed_property\n/\n\n  \n/configure\n\n\n/mfractor\n\n\n\n\n\nThis code connects the \nView Model Property Generator\n \nSnippet\n to the \nnotify_changed_property\n code snippet in Visual Studio for Mac.\n\n\nUsing Project Code Snippets\n\n\nMFractor can also use code snippets that are included within your project. This is useful as it allows you to include  code snippets amongst you team\n\n\nTo do this, create a new folder named \nSnippets\n in the root of your project:\n\n\n\n\nNext, create a new text file inside the \nSnippets\n folder named \nnotify_changed_property.txt\n and enter the following content:\n\n\nprivate $type$ _$name$;\npublic $type$ $name$\n{\n    get\n    {\n        return _$name$;\n    }\n    set\n    {\n        _$name$ = value;\n        NotifyPropertyChanged(nameof($name$));\n    }\n}\n\n\n\n\nLastly, we need to connect the \nView Model Property Generator\n \nSnippet\n to \nnotify_changed_property.txt\n code snippet included in our project.\n\n\nCreate a file named \napp.mfc.xml\n in the root directory with the following content:\n\n\nmfractor\n\n  \nconfigure id=\ncom.mfractor.code_gen.forms.csharp.view_model_property\n\n    \nproperty name=\nSnippet\n source=\nfile\n value=\nSnippets/notify_changed_property.txt\n/\n\n  \n/configure\n\n\n/mfractor", 
            "title": "Code Snippets"
        }, 
        {
            "location": "/configuration/code-snippets/#code-snippets", 
            "text": "Using Code Snippets to completely customise the code that MFractor generates", 
            "title": "Code Snippets"
        }, 
        {
            "location": "/configuration/code-snippets/#introduction", 
            "text": "As a software developer and MFractor user you'll likely find that MFractor, by default, doesn't quite generate code that's suited to your projects conventions.  Luckily, we can configure many of MFractor's code actions to use a custom code snippet when generating code!", 
            "title": "Introduction"
        }, 
        {
            "location": "/configuration/code-snippets/#code-snippet-basics", 
            "text": "MFractor uses the same conventions for code snippets as the Visual Studio family; you write a C# code block and replace areas that can be substituted with arguments enclosed in  $ .  For example, the following code snippet specifies the body for a property that calls the  NotifyPropertyChanged  method:  private $type$ _$name$;\npublic $type$ $name$\n{\n    get\n    {\n        return _$name$;\n    }\n    set\n    {\n        _$name$ = value;\n        NotifyPropertyChanged(nameof($name$));\n    }\n}  To control the type of the new property, we've replaced each spot where the property type would be used with the code snippet argument  $type$ . Likewise, we've done the same with the  $name$  argument.  If the new property was a  string  with the name  Message , MFractor would subsitute each occurance of  $type$  with  string  and each occurance of  $name$  with  Message  like so:  private string _Message;\npublic string Message\n{\n    get\n    {\n        return _Message;\n    }\n    set\n    {\n        _Message = value;\n        NotifyPropertyChanged(nameof(Message));\n    }\n}  When possible, MFractor's internal code generators use a code snippet to create code. These code snippets are exposed as configurable properties and are named  Snippet .  To identify what you can  We can customise MFractor by providing code snippets through two sources:  Visual Studio for Macs snippets  and  code snippets included within your project .", 
            "title": "Code Snippet Basics"
        }, 
        {
            "location": "/configuration/code-snippets/#using-visual-studio-macs-code-snippets", 
            "text": "To enable MFractor to use a code snippet from Visual Studio Mac, we need to create a code snippet inside Visual Studio Mac and then link it up through an MFractor config file.  In the top menu bar, click on  Visual Studio  and then  Preferences :   In the preferences window that opens, browse to  Code Snippets...  and then select  Add :   This will open the  New template  wizard. For this code snippet we'll create a template for a new property that triggers a property changed method.  We'll set our code snippets name to  notify_changed_property  and enter the , define our code as below:   Lastly, we need to tell MFractor to use our code snippet when generating view model properties. We do this through an MFractor configuraiton file.  Create a file named  app.mfc.xml  in the root directory with the following content:  mfractor \n   configure id= com.mfractor.code_gen.forms.csharp.view_model_property \n     property name= Snippet  source= ide  value= notify_changed_property / \n   /configure  /mfractor   This code connects the  View Model Property Generator   Snippet  to the  notify_changed_property  code snippet in Visual Studio for Mac.", 
            "title": "Using Visual Studio Macs Code Snippets"
        }, 
        {
            "location": "/configuration/code-snippets/#using-project-code-snippets", 
            "text": "MFractor can also use code snippets that are included within your project. This is useful as it allows you to include  code snippets amongst you team  To do this, create a new folder named  Snippets  in the root of your project:   Next, create a new text file inside the  Snippets  folder named  notify_changed_property.txt  and enter the following content:  private $type$ _$name$;\npublic $type$ $name$\n{\n    get\n    {\n        return _$name$;\n    }\n    set\n    {\n        _$name$ = value;\n        NotifyPropertyChanged(nameof($name$));\n    }\n}  Lastly, we need to connect the  View Model Property Generator   Snippet  to  notify_changed_property.txt  code snippet included in our project.  Create a file named  app.mfc.xml  in the root directory with the following content:  mfractor \n   configure id= com.mfractor.code_gen.forms.csharp.view_model_property \n     property name= Snippet  source= file  value= Snippets/notify_changed_property.txt / \n   /configure  /mfractor", 
            "title": "Using Project Code Snippets"
        }, 
        {
            "location": "/configuration/configuration-property-types/", 
            "text": "Configuration Types\n\n\nAutogenerated by MFractor v3.7.3\n\n\nCode Snippet\n\n\nCode snippets are source code samples that MFractor can use to generate arbitrary code.\n\n\nCode snippets are defined as C# code with named arguments (EG: \n$name$\n) that are replaced by the snippet engine when the code is being generated.\n\n\nMFractor supports code snippets from 3 sources:\n\n\n\n\nUsers can define snippets inside Visual Studio Macs snippets editor and then reference them in an MFractor config through the \nsource=\"ide\" value=\"snippet_name\"\n syntax.\n\n\nUsers can include snippets within their projects and then reference them in an MFractor config through the \nsource=\"file\" value=\"Snippets/MySnippet.txt\"\n syntax.\n\n\nPackage and framework authors can silently inject desired code snippets by including them inside the \n./b uild\n folder of their package and targetting them in the \n.mfc.xml\n config file through the \nvalue=\"Snippets/MySnippet.txt\"\n syntax.\n\n\n\n\nDouble\n\n\nWhen MFractor encounters a \ndouble\n property, it will parse the value in the \n\n\nEnum\n\n\nWhen an enum value is encountered in a confg file, MFractor will try to parse the value into the properties enum type, falling back to the properties default enum value.\n\n\nFile Path\n\n\nFile Paths refer to files either absolutely or relative to the current project.\n\n\nString\n\n\nString property types are parsed and converted into a string literal.\n\n\nSystem.Boolean\n\n\nBoolean properties support inputs of \ntrue\n or \nfalse\n.\n\n\nSystem.Int32\n\n\nWhen an integer value is encountered in a config file, MFractor will try to parse the value into a signed \nint\n. If the number fails to parse, MFractor falls back to the propeties default \ninteger\n value.", 
            "title": "Types"
        }, 
        {
            "location": "/configuration/configuration-property-types/#configuration-types", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "Configuration Types"
        }, 
        {
            "location": "/configuration/configuration-property-types/#code-snippet", 
            "text": "Code snippets are source code samples that MFractor can use to generate arbitrary code.  Code snippets are defined as C# code with named arguments (EG:  $name$ ) that are replaced by the snippet engine when the code is being generated.  MFractor supports code snippets from 3 sources:   Users can define snippets inside Visual Studio Macs snippets editor and then reference them in an MFractor config through the  source=\"ide\" value=\"snippet_name\"  syntax.  Users can include snippets within their projects and then reference them in an MFractor config through the  source=\"file\" value=\"Snippets/MySnippet.txt\"  syntax.  Package and framework authors can silently inject desired code snippets by including them inside the  ./b uild  folder of their package and targetting them in the  .mfc.xml  config file through the  value=\"Snippets/MySnippet.txt\"  syntax.", 
            "title": "Code Snippet"
        }, 
        {
            "location": "/configuration/configuration-property-types/#double", 
            "text": "When MFractor encounters a  double  property, it will parse the value in the", 
            "title": "Double"
        }, 
        {
            "location": "/configuration/configuration-property-types/#enum", 
            "text": "When an enum value is encountered in a confg file, MFractor will try to parse the value into the properties enum type, falling back to the properties default enum value.", 
            "title": "Enum"
        }, 
        {
            "location": "/configuration/configuration-property-types/#file-path", 
            "text": "File Paths refer to files either absolutely or relative to the current project.", 
            "title": "File Path"
        }, 
        {
            "location": "/configuration/configuration-property-types/#string", 
            "text": "String property types are parsed and converted into a string literal.", 
            "title": "String"
        }, 
        {
            "location": "/configuration/configuration-property-types/#systemboolean", 
            "text": "Boolean properties support inputs of  true  or  false .", 
            "title": "System.Boolean"
        }, 
        {
            "location": "/configuration/configuration-property-types/#systemint32", 
            "text": "When an integer value is encountered in a config file, MFractor will try to parse the value into a signed  int . If the number fails to parse, MFractor falls back to the propeties default  integer  value.", 
            "title": "System.Int32"
        }, 
        {
            "location": "/configuration/resx/", 
            "text": "ResX Feature Configuration\n\n\nAutogenerated by MFractor v3.7.3\n\n\nDefault Resource File\n\n\nConfiguration Id: com.mfractor.configuration.resx.default_resource_file\n\n\nA proxy configuration that allows code actions and code generators throughout MFractor to use the same default resource file\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nProjectFilePath\n\n\nSystem.String\n\n\nResources/Resources.resx\n\n\nWhat is the default resource file that string resources should be placed into?", 
            "title": "ResX"
        }, 
        {
            "location": "/configuration/resx/#resx-feature-configuration", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "ResX Feature Configuration"
        }, 
        {
            "location": "/configuration/resx/#default-resource-file", 
            "text": "Configuration Id: com.mfractor.configuration.resx.default_resource_file  A proxy configuration that allows code actions and code generators throughout MFractor to use the same default resource file", 
            "title": "Default Resource File"
        }, 
        {
            "location": "/configuration/resx/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      ProjectFilePath  System.String  Resources/Resources.resx  What is the default resource file that string resources should be placed into?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/xamarin-forms/", 
            "text": "Xamarin.Forms Feature Configuration\n\n\nAutogenerated by MFractor v3.7.3\n\n\nAndroid Custom Renderer Code Snippets\n\n\nConfiguration Id: com.mfractor.configuration.forms.android_custom_renderers\n\n\nGroups the Android specific custom renderer code snippets for pages, layouts, controls and view cells into a single configuration point. When customising the code snippets for Android, this configuration should be changed in the Android project rather than the PCL/Shared Project/netstandard library.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPageRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the page that this custom renderer is for.\ncontrol_name\n: The name of the page that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for customised pages.\n\n\n\n\n\n\nLayoutRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the layout that this custom renderer is for.\ncontrol_name\n: The name of the layout that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for customised layouts.\n\n\n\n\n\n\nViewRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the control that this custom renderer is for.\ncontrol_name\n: The name of the control that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for customised controls.\n\n\n\n\n\n\nCellRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the control that this custom renderer is for.\ncontrol_name\n: The name of the control that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for customised cells in ListViews.\n\n\n\n\n\n\nRenderersFolder\n\n\nSystem.String\n\n\nRenderers\n\n\nWhat is the folder path that new renderers should be placed into?\n\n\n\n\n\n\nRenderersNamespace\n\n\nSystem.String\n\n\n.Renderers\n\n\nWhat is the fully qualifed namespace that new renderers should be placed into? Prepend the namespace name with a dot to make it relative to the projects default namespace.\n\n\n\n\n\n\n\n\nApplication Name Configuration\n\n\nConfiguration Id: com.mfractor.configuration.forms.application_name\n\n\nEnables configuration of the name of the App.xaml filename, letting users specify their own\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAppXamlFileName\n\n\nSystem.String\n\n\nApp.xaml\n\n\nThe name of the App.xaml file for the project.\n\n\n\n\n\n\n\n\nBehaviors Configuration\n\n\nConfiguration Id: com.mfractor.configuration.forms.behaviors\n\n\nGroups all configuration settings related to Xamarin.Forms.Behavior's into a single place.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBehaviorsFolder\n\n\nSystem.String\n\n\nBehaviors\n\n\nThe default folder to place new behaviors into.\n\n\n\n\n\n\nBehaviorsNamespace\n\n\nSystem.String\n\n\n.Behaviors\n\n\nThe default names that new behaviors will be placed into. Prepending the namespace with a \n.\n will cause the namespace to be appended to the projects default namespace.\n\n\n\n\n\n\n\n\nCustom Controls Configuration\n\n\nConfiguration Id: com.mfractor.configuration.forms.custom_controls\n\n\nGroups all configuration settings related to custom controls into a single place.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nControlsFolder\n\n\nSystem.String\n\n\nControls\n\n\nWhat is the folder that new controls should be placed into?\n\n\n\n\n\n\nControlsNamespace\n\n\nSystem.String\n\n\n.Controls\n\n\nWhat is the default namespace the new controls be placed into?\n\n\n\n\n\n\n\n\nEvent To Command Behavior Configuration\n\n\nConfiguration Id: com.mfractor.configuration.forms.event_to_command_behavior\n\n\nGroups all configuration settings and code snippets for the Event to Command code generation feature suite.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nEventToCommandBehaviorSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the event to command behaviour\nnamespace\n: The namespace that encapsulates the event to command behaviour\n\n\nView Code Snippet\n\n\nThe code snippet to use for the event to command behavior.\n\n\n\n\n\n\nSelectedItemEventArgsToSelectedItemConverterSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the converter.\nnamespace\n: The namespace that encapsulates the converter\n\n\nView Code Snippet\n\n\nThe code snippet to use for the \nSelectedItemEventArgsToSelectedItemConverter\n.\n\n\n\n\n\n\nEventToCommandBehaviorName\n\n\nSystem.String\n\n\nEventToCommandBehavior\n\n\nThe class name of the event to command behavior.\n\n\n\n\n\n\nSelectedItemEventArgsToSelectedItemConverterName\n\n\nSystem.String\n\n\nSelectedItemEventArgsToSelectedItemConverter\n\n\nThe class name of the event to command behavior class.\n\n\n\n\n\n\n\n\nIOS Custom Renderer Code Snippets\n\n\nConfiguration Id: com.mfractor.configuration.forms.ios_custom_renderers\n\n\nGroups the iOS specific custom renderer code snippets for pages, layouts, controls and view cells into a single configuration point. When customising the code snippets for iOS, this configuration should be changed in the iOS project rather than the PCL/Shared Project/netstandard library.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPageRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the page that this custom renderer is for.\ncontrol_name\n: The name of the page that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for customised pages.\n\n\n\n\n\n\nLayoutRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the layout that this custom renderer is for.\ncontrol_name\n: The name of the layou that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for customised layouts.\n\n\n\n\n\n\nViewRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the control that this custom renderer is for.\ncontrol_name\n: The name of the control that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for cu stomised controls.\n\n\n\n\n\n\nCellRendererSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol_type\n: The fully qualified type of the control that this custom renderer is for.\ncontrol_name\n: The name of the control that this custom renderer is for.\nnamespace\n: The namespace that the custom renderer will be placed into.\nrenderer_name\n: The name of the new custom renderer.\nrenderer_control\n: The name of the base control type. For example, if your control is \nMyCustomLabel\n that extends a \nLabel\n, \nrenderer_control\n will be \nLabel\n.\nbase_type\n: The fully qualified type of the renderers base type.\n\n\nView Code Snippet\n\n\nThe code snippet to use for customised cells in ListViews.\n\n\n\n\n\n\nRenderersFolder\n\n\nSystem.String\n\n\nRenderers\n\n\nWhat is the folder path that new renderers should be placed into?\n\n\n\n\n\n\nRenderersNamespace\n\n\nSystem.String\n\n\n.Renderers\n\n\nWhat is the fully qualifed namespace that new renderers should be placed into? Prepend the namespace name with a dot to make it relative to the projects default namespace.\n\n\n\n\n\n\n\n\nMVVM Resolution Settings\n\n\nConfiguration Id: com.mfractor.configuration.forms.mvvm_resolution\n\n\nThe MVVM resolution settings can be used to specify the project that your views or view models sit within. If you prefer to separate your views and view models into separate projects, these settings enable MFractor to resolve the MVVM relationship across project boundaries.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nViewsProjectName\n\n\nSystem.String\n\n\nnull\n\n\nIf the apps XAML views and view models are in separate projects, what is the name of project that contains the XAML views?\n\n\n\n\n\n\nViewModelsProjectName\n\n\nSystem.String\n\n\nnull\n\n\nIf the apps XAML views and view models are in separate projects, what is the name of project that contains the ViewModels?\n\n\n\n\n\n\n\n\nValue Conversion Settings\n\n\nConfiguration Id: com.mfractor.configuration.forms.value_conversions\n\n\nA collection of common settings to use for value converters.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nNamespace\n\n\nSystem.String\n\n\n.Converters\n\n\nThe namespace to place value conversion code inside. When empty, new value conversion code will be placed under the projects default namespace. Place a single '.' before the namespace name to make it relative to the projects default namespace.\n\n\n\n\n\n\nFolder\n\n\nSystem.String\n\n\nConverters\n\n\nThe folder to place value conversion code inside. When empty, new value conversion code will be placed inside the proejcts root folder.\n\n\n\n\n\n\nDefaultConverterXmlns\n\n\nSystem.String\n\n\nconverters\n\n\nThe namespace name of the xmlns import statement for the newly created value converter", 
            "title": "Xamarin.Forms"
        }, 
        {
            "location": "/configuration/xamarin-forms/#xamarinforms-feature-configuration", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "Xamarin.Forms Feature Configuration"
        }, 
        {
            "location": "/configuration/xamarin-forms/#android-custom-renderer-code-snippets", 
            "text": "Configuration Id: com.mfractor.configuration.forms.android_custom_renderers  Groups the Android specific custom renderer code snippets for pages, layouts, controls and view cells into a single configuration point. When customising the code snippets for Android, this configuration should be changed in the Android project rather than the PCL/Shared Project/netstandard library.", 
            "title": "Android Custom Renderer Code Snippets"
        }, 
        {
            "location": "/configuration/xamarin-forms/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      PageRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the page that this custom renderer is for. control_name : The name of the page that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for customised pages.    LayoutRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the layout that this custom renderer is for. control_name : The name of the layout that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for customised layouts.    ViewRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the control that this custom renderer is for. control_name : The name of the control that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for customised controls.    CellRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the control that this custom renderer is for. control_name : The name of the control that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for customised cells in ListViews.    RenderersFolder  System.String  Renderers  What is the folder path that new renderers should be placed into?    RenderersNamespace  System.String  .Renderers  What is the fully qualifed namespace that new renderers should be placed into? Prepend the namespace name with a dot to make it relative to the projects default namespace.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/xamarin-forms/#application-name-configuration", 
            "text": "Configuration Id: com.mfractor.configuration.forms.application_name  Enables configuration of the name of the App.xaml filename, letting users specify their own", 
            "title": "Application Name Configuration"
        }, 
        {
            "location": "/configuration/xamarin-forms/#configurable-properties_1", 
            "text": "Name  Type  Defaults To  Description      AppXamlFileName  System.String  App.xaml  The name of the App.xaml file for the project.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/xamarin-forms/#behaviors-configuration", 
            "text": "Configuration Id: com.mfractor.configuration.forms.behaviors  Groups all configuration settings related to Xamarin.Forms.Behavior's into a single place.", 
            "title": "Behaviors Configuration"
        }, 
        {
            "location": "/configuration/xamarin-forms/#configurable-properties_2", 
            "text": "Name  Type  Defaults To  Description      BehaviorsFolder  System.String  Behaviors  The default folder to place new behaviors into.    BehaviorsNamespace  System.String  .Behaviors  The default names that new behaviors will be placed into. Prepending the namespace with a  .  will cause the namespace to be appended to the projects default namespace.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/xamarin-forms/#custom-controls-configuration", 
            "text": "Configuration Id: com.mfractor.configuration.forms.custom_controls  Groups all configuration settings related to custom controls into a single place.", 
            "title": "Custom Controls Configuration"
        }, 
        {
            "location": "/configuration/xamarin-forms/#configurable-properties_3", 
            "text": "Name  Type  Defaults To  Description      ControlsFolder  System.String  Controls  What is the folder that new controls should be placed into?    ControlsNamespace  System.String  .Controls  What is the default namespace the new controls be placed into?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/xamarin-forms/#event-to-command-behavior-configuration", 
            "text": "Configuration Id: com.mfractor.configuration.forms.event_to_command_behavior  Groups all configuration settings and code snippets for the Event to Command code generation feature suite.", 
            "title": "Event To Command Behavior Configuration"
        }, 
        {
            "location": "/configuration/xamarin-forms/#configurable-properties_4", 
            "text": "Name  Type  Defaults To  Description      EventToCommandBehaviorSnippet  Code Snippet Arguments : name : The name of the event to command behaviour namespace : The namespace that encapsulates the event to command behaviour  View Code Snippet  The code snippet to use for the event to command behavior.    SelectedItemEventArgsToSelectedItemConverterSnippet  Code Snippet Arguments : name : The name of the converter. namespace : The namespace that encapsulates the converter  View Code Snippet  The code snippet to use for the  SelectedItemEventArgsToSelectedItemConverter .    EventToCommandBehaviorName  System.String  EventToCommandBehavior  The class name of the event to command behavior.    SelectedItemEventArgsToSelectedItemConverterName  System.String  SelectedItemEventArgsToSelectedItemConverter  The class name of the event to command behavior class.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/xamarin-forms/#ios-custom-renderer-code-snippets", 
            "text": "Configuration Id: com.mfractor.configuration.forms.ios_custom_renderers  Groups the iOS specific custom renderer code snippets for pages, layouts, controls and view cells into a single configuration point. When customising the code snippets for iOS, this configuration should be changed in the iOS project rather than the PCL/Shared Project/netstandard library.", 
            "title": "IOS Custom Renderer Code Snippets"
        }, 
        {
            "location": "/configuration/xamarin-forms/#configurable-properties_5", 
            "text": "Name  Type  Defaults To  Description      PageRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the page that this custom renderer is for. control_name : The name of the page that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for customised pages.    LayoutRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the layout that this custom renderer is for. control_name : The name of the layou that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for customised layouts.    ViewRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the control that this custom renderer is for. control_name : The name of the control that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for cu stomised controls.    CellRendererSnippet  Code Snippet Arguments : control_type : The fully qualified type of the control that this custom renderer is for. control_name : The name of the control that this custom renderer is for. namespace : The namespace that the custom renderer will be placed into. renderer_name : The name of the new custom renderer. renderer_control : The name of the base control type. For example, if your control is  MyCustomLabel  that extends a  Label ,  renderer_control  will be  Label . base_type : The fully qualified type of the renderers base type.  View Code Snippet  The code snippet to use for customised cells in ListViews.    RenderersFolder  System.String  Renderers  What is the folder path that new renderers should be placed into?    RenderersNamespace  System.String  .Renderers  What is the fully qualifed namespace that new renderers should be placed into? Prepend the namespace name with a dot to make it relative to the projects default namespace.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/xamarin-forms/#mvvm-resolution-settings", 
            "text": "Configuration Id: com.mfractor.configuration.forms.mvvm_resolution  The MVVM resolution settings can be used to specify the project that your views or view models sit within. If you prefer to separate your views and view models into separate projects, these settings enable MFractor to resolve the MVVM relationship across project boundaries.", 
            "title": "MVVM Resolution Settings"
        }, 
        {
            "location": "/configuration/xamarin-forms/#configurable-properties_6", 
            "text": "Name  Type  Defaults To  Description      ViewsProjectName  System.String  null  If the apps XAML views and view models are in separate projects, what is the name of project that contains the XAML views?    ViewModelsProjectName  System.String  null  If the apps XAML views and view models are in separate projects, what is the name of project that contains the ViewModels?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/configuration/xamarin-forms/#value-conversion-settings", 
            "text": "Configuration Id: com.mfractor.configuration.forms.value_conversions  A collection of common settings to use for value converters.", 
            "title": "Value Conversion Settings"
        }, 
        {
            "location": "/configuration/xamarin-forms/#configurable-properties_7", 
            "text": "Name  Type  Defaults To  Description      Namespace  System.String  .Converters  The namespace to place value conversion code inside. When empty, new value conversion code will be placed under the projects default namespace. Place a single '.' before the namespace name to make it relative to the projects default namespace.    Folder  System.String  Converters  The folder to place value conversion code inside. When empty, new value conversion code will be placed inside the proejcts root folder.    DefaultConverterXmlns  System.String  converters  The namespace name of the xmlns import statement for the newly created value converter", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/", 
            "text": "Configuring A Binding Context\n\n\nPower the code action engine, code analysis and data-binding IntelliSense by targeting a binding context for your XAML\n\n\nIntroduction\n\n\nMFractor includes many features to make working with XAML and the MVVM pattern easier. To power these features, MFractor is capable of intelligently resolving a XAML files binding context (even when none is specified) and can also evaluate markup expressions (such as x:Static or Binding expressions) or can walk through the XAML hierarchy to evaulate the correct binding context for a given node.\n\n\nSo, what is a binding context?\n\n\nWhen using the Model-View-ViewModel architecture pattern, views use a \nBinding Context\n to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through \ndata binding\n; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts \nThe MVVM Pattern\n article.\n\n\nMFractor supports two methods of binding context resolution: we can specify a binding context \nexplicitly\n via in inline XAML expression or \nimplicitly\n through the use of common MVVM naming conventions.\n\n\nImplicit Binding Context Resolution\n\n\nMFractor uses \nimplicit binding context resolution\n to infer the relationship between your view models and XAML views. This is done by looking for classes and XAML views that follow industry standard naming convention.\n\n\nLet's consider the following files:\n\n\n\n\nLoginPage.xaml\n - The XAML view.\n\n\nLoginPage.xaml.cs\n - The code behind for the XAML view.\n\n\nLoginViewModel\n - The a C# class that is the view model for the LoginPage view.\n\n\n\n\n\n\nBecause these pages share the prefix \nLogin\n and each has a distinct file extension or suffix, MFractor assumes the following relationships:\n\n\n\n\nThe \n.xaml\n extension denotes that \nLoginPage.xaml\n is a xaml view.\n\n\nThe \n.xaml.cs\n extension and the \nLoginPage\n component denotes that \nLoginPage.xaml.cs\n is the code behind implementation \nLoginPage\n view.\n\n\nThe \nViewModel\n suffix implies that \nLoginViewModel\n is a view model. When \nViewModel\n is removed from \nLoginViewModel\n and \nPage\n is removed from \nLoginPage\n, the \nLogin\n component implies that the \nLoginViewModel\n is related to the \nLoginPage\n XAML view and it's code behind file.\n\n\n\n\nMFractor uses these common naming conventions of Page.xaml, Page.xaml.cs and ViewModel to decide that \nLoginViewModel\n will probably be the BindingContext for \nLoginPage\n. The \nPage\n \n-\n \nViewModel\n naming convention is used by several popular MVVM frameworks such as Prism and FreshMVVM.\n\n\nThe following suffixes are supported for XAML views:\n\n\n\n\nPage\n: EG LoginPage.xaml \n-\n LoginViewModel\n\n\nView\n: EG LoginView.xaml \n-\n LoginViewModel\n\n\n\n\nThe following suffixes are supported for View Models.\n\n\n\n\nViewModel\n: EG LoginPage.xaml \n-\n LoginViewModel\n\n\nPageModel\n: EG LoginView.xaml \n-\n LoginPageModel\n\n\nPageViewModel\n: EG LoginView.xaml \n-\n LoginPageViewModel\n\n\nModel\n: EG LoginView.xaml \n-\n LoginModel\n\n\nVM\n: EG LoginView.xaml \n-\n LoginVM\n\n\nPageVM\n: EG LoginView.xaml \n-\n LoginPageVM\n\n\n\n\nExplicit Binding Context Resolution\n\n\nIn Xamarin.Forms, all views have the property \nBindingContext\n; this specifies the object that a view should data-bind with. When coding with XAML, we can use the \nx:Static\n markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context:\n\n\n \nEntry BindingContext=\n{x:Static local:MyStaticClass.MyStaticProperty}\n/\n\n\n\n\n\nThis is known as the \nView Model Locator Pattern\n. We implement a static class named \nViewModelLocator\n and use a static, readonly property to return an instance of the object we want our XAML view to data-bind with. Historically the \nView Model Locator Pattern\n has been used to provide design time data to the Xamarin.Forms XAML previewer. For a deeper insight into this pattern, read James Montemagnos excellent \nView Model Locator\n article.\n\n\nFor example, given a XAML page named \nLoginPage\n, we can explicitly provide an instance of \nLoginViewModel\n as the binding context like so:\n\n\nViewModelLocator.cs\n\n\npublic namespace MyApp\n{\n  public static class ViewModelLocator\n  {\n      public static readonly LoginViewModel LoginViewModel = new LoginViewModel();\n  }\n}\n\n\n\n\nLoginPage.xaml\n\n\nContentPage\n  xmlns:local=\nclr-namespace:MyApp;assembly=MyApp\n\n  BindingContext=\n{x:Static local:ViewModelLocator.LoginViewModel}\n/\n\n\n\n\n\nWhen MFractor starts analysis on LoginPage.xaml, it will check if any \nBindingContext\n properties have been assigned to. As the root \nContentPage\n assigns a binding context, it will inspect the value component of the \nBindingContext\n attribute, check if it is a XAML expression and then evaluate it for the return type.\n\n\nFor the \n{x:Static local:ViewModelLocator.LoginViewModel}\n expression, MFractor will resolve the \nViewModelLocator\n class in the \nlocal\n namespace and then grab the C# type of the \nLoginViewModel\n property. This informs MFractor that the page will be bound to a \nLoginViewModel\n instance and therefore to analyse all \nBinding\n expressions against the \nLoginViewModel\n type.\n\n\nExplicit binding context resolution will also work when referencing another element using \nx:Reference\n expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so:\n\n\n  \nSwitch x:Name=\nmySwitch\n /\n\n  \nLabel BindingContext=\n{x:Reference mySwitch}\n IsVisible=\n{Binding IsToggled}\n/\n\n\n\n\n\nWhen MFractor analyses the \n{Binding IsToggled}\n expression, it will evaluate the \n{x:Reference mySwitch}\n expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch).\n\n\nExplicit binding context resolution will \nalways\n override implicit binding context resolution. If your XAML views are named using the conventions listed above but your page or a view explicitly assigns the \nBindingContext\n property then MFractor will use the \nBindingContext\n return type instead of the implicit Mvvm relationship.\n\n\nDesign Time Binding Contexts\n\n\nIt's also possible to explicitly specify a desired binding context by applying the \nDesignTimeBindingContext\n attribute to the code behind class.\n\n\nTo get started, add the following code file to your project:\n\n\nDesignTimeBindingContextAttribute.cs\n\n\nusing System;\n\nnamespace MyApp.Attributes\n{\n    /// \nsummary\n\n    /// Apply the design time binding context attribute to your code-behind class to inform tools of your intended runtime binding context.\n    /// \n/summary\n\n    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\n    public class DesignTimeBindingContextAttribute : Attribute\n    {\n        /// \nsummary\n\n        /// Specifies the design time binding context using a fully qualified type name.\n        ///\n        /// For example: MyApp.ViewModels.LoginViewModel.\n        /// \n/summary\n\n        /// \nparam name=\ntypeName\nThe fully qualified type name for the design time binding context.\n/param\n\n        public DesignTimeBindingContextAttribute(string typeName)\n        {\n        }\n\n        /// \nsummary\n\n        /// Specifies the design time binding context using typeof().\n        ///\n        /// For example: typeof(LoginViewModel)\n        /// \n/summary\n\n        /// \nparam name=\ntype\nThe \nsee cref=\nSystem.Type\n/\n for the design time binding context, using typeof().\n/param\n\n        public DesignTimeBindingContextAttribute(Type type)\n        {\n        }\n    }\n}\n\n\n\n\nNext, apply this attribute onto the code-behind class for your XAML file:\n\n\nApplying By Type\n\n\n[DesignTimeBindingContext(typeof(MyBindingContext))]\n\n\n\n\nApplying By String\n\n\n[DesignTimeBindingContext(\nMyApp.MyBindingContext\n)]\n\n\n\n\nApplying this attribute directs MFractor at your binding context to enable data-binding IntelliSense, code actions and code analysis for that XAML file.\n\n\nData Template Binding Context Resolution\n\n\nData templates are used to provide a nested XAML view to a view that displays many occurrences of that view. For example, a ListView uses a \nDataTemplate\n to specify the view appearance of each instance provided through the \nItemsSource\n property.\n\n\nMFractor will attempt to infer the BindingContext for a data templates view by resolving the \nItemsSource\n property on the wrapping view.\n\n\nConsider the following code:\n\n\n  \nListView ItemsSource=\n{Binding Contacts}\n\n      \nListView.ItemTemplate\n\n        \nDataTemplate\n\n          \nTextCell Text=\n{Binding DisplayName}\n /\n\n        \n/DataTemplate\n\n      \n/ListView.ItemTemplate\n\n  \n/ListView\n\n\n\n\n\nThe inner \nDataTemplate\n has a \nTextCell\n where the \nText\n property is provided by the binding expression \n{Binding DisplayName}\n. To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the \nItemsSource\n property and evaluate the expression.\n\n\nWhen the return type is an \nIEnumerable\n or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.\n\n\nCross Project Binding Context Resolution\n\n\nIf your views and view models are in separate projects and you'd like to use implicit MVVM resolution, you'll need to give MFractor a nudge in the right direction.\n\n\nUnfortunately, it is too expensive to scan the solution to match view models to pages; the scan takes anywhere between 10's to 100's of milliseconds in a moderately sized solution. Therefore, for efficiency reasons, you need to use an MFractor configuration to enable cross-project MVVM resolution.\n\n\nTo make MFractor use View Models in a project separate to your views, you'll need to create an MFractor config for each project.\n\n\nIn the project that contains your views, create a file named app.mfc.xml with the following content:\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n ?\n\n\nmfractor\n\n    \nconfigure id=\ncom.mfractor.configuration.forms.mvvm_resolution\n\n        \nproperty name=\nViewModelsProjectName\n value=\nTODO: Insert the name of your view models project as it appears in the solution explorer\n/\n\n    \n/configure\n\n\n/mfractor\n  \n\n\n\n\nIn the project that contains your view models, create a file named app.mfc.xml with the following content:\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n ?\n\n\nmfractor\n\n    \nconfigure id=\ncom.mfractor.configuration.forms.mvvm_resolution\n\n        \nproperty name=\nViewsProjectName\n value=\nTODO: Insert the name of your views project as it appears in the solution explorer\n/\n\n    \n/configure\n\n\n/mfractor\n\n\n\n\n\nSummary\n\n\nIn summary, we've learnt that MFractor will use the binding context to power the XAML analyser and navigation improvements.\n\n\n\n\nBinding expressions require a binding context to be analysed.\n\n\nWe can explicitly specify a binding context by assigning the \nBindingContext\n property of any XAML element.\n\n\nWhen we name our code files using the Page.xaml, Page.xaml.cs and ViewModel convention, MFractor will assume an implicit MVVM relationship.\n\n\nData templates use the return type of the wrapping views \nItemSource\n property.\n\n\nWe can setup a cross project  templates use the return type of the wrapping views \nItemSource\n property.", 
            "title": "Configuring A Binding Context"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#configuring-a-binding-context", 
            "text": "Power the code action engine, code analysis and data-binding IntelliSense by targeting a binding context for your XAML", 
            "title": "Configuring A Binding Context"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#introduction", 
            "text": "MFractor includes many features to make working with XAML and the MVVM pattern easier. To power these features, MFractor is capable of intelligently resolving a XAML files binding context (even when none is specified) and can also evaluate markup expressions (such as x:Static or Binding expressions) or can walk through the XAML hierarchy to evaulate the correct binding context for a given node.  So, what is a binding context?  When using the Model-View-ViewModel architecture pattern, views use a  Binding Context  to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through  data binding ; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts  The MVVM Pattern  article.  MFractor supports two methods of binding context resolution: we can specify a binding context  explicitly  via in inline XAML expression or  implicitly  through the use of common MVVM naming conventions.", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#implicit-binding-context-resolution", 
            "text": "MFractor uses  implicit binding context resolution  to infer the relationship between your view models and XAML views. This is done by looking for classes and XAML views that follow industry standard naming convention.  Let's consider the following files:   LoginPage.xaml  - The XAML view.  LoginPage.xaml.cs  - The code behind for the XAML view.  LoginViewModel  - The a C# class that is the view model for the LoginPage view.    Because these pages share the prefix  Login  and each has a distinct file extension or suffix, MFractor assumes the following relationships:   The  .xaml  extension denotes that  LoginPage.xaml  is a xaml view.  The  .xaml.cs  extension and the  LoginPage  component denotes that  LoginPage.xaml.cs  is the code behind implementation  LoginPage  view.  The  ViewModel  suffix implies that  LoginViewModel  is a view model. When  ViewModel  is removed from  LoginViewModel  and  Page  is removed from  LoginPage , the  Login  component implies that the  LoginViewModel  is related to the  LoginPage  XAML view and it's code behind file.   MFractor uses these common naming conventions of Page.xaml, Page.xaml.cs and ViewModel to decide that  LoginViewModel  will probably be the BindingContext for  LoginPage . The  Page   -   ViewModel  naming convention is used by several popular MVVM frameworks such as Prism and FreshMVVM.  The following suffixes are supported for XAML views:   Page : EG LoginPage.xaml  -  LoginViewModel  View : EG LoginView.xaml  -  LoginViewModel   The following suffixes are supported for View Models.   ViewModel : EG LoginPage.xaml  -  LoginViewModel  PageModel : EG LoginView.xaml  -  LoginPageModel  PageViewModel : EG LoginView.xaml  -  LoginPageViewModel  Model : EG LoginView.xaml  -  LoginModel  VM : EG LoginView.xaml  -  LoginVM  PageVM : EG LoginView.xaml  -  LoginPageVM", 
            "title": "Implicit Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#explicit-binding-context-resolution", 
            "text": "In Xamarin.Forms, all views have the property  BindingContext ; this specifies the object that a view should data-bind with. When coding with XAML, we can use the  x:Static  markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context:    Entry BindingContext= {x:Static local:MyStaticClass.MyStaticProperty} /   This is known as the  View Model Locator Pattern . We implement a static class named  ViewModelLocator  and use a static, readonly property to return an instance of the object we want our XAML view to data-bind with. Historically the  View Model Locator Pattern  has been used to provide design time data to the Xamarin.Forms XAML previewer. For a deeper insight into this pattern, read James Montemagnos excellent  View Model Locator  article.  For example, given a XAML page named  LoginPage , we can explicitly provide an instance of  LoginViewModel  as the binding context like so:  ViewModelLocator.cs  public namespace MyApp\n{\n  public static class ViewModelLocator\n  {\n      public static readonly LoginViewModel LoginViewModel = new LoginViewModel();\n  }\n}  LoginPage.xaml  ContentPage\n  xmlns:local= clr-namespace:MyApp;assembly=MyApp \n  BindingContext= {x:Static local:ViewModelLocator.LoginViewModel} /   When MFractor starts analysis on LoginPage.xaml, it will check if any  BindingContext  properties have been assigned to. As the root  ContentPage  assigns a binding context, it will inspect the value component of the  BindingContext  attribute, check if it is a XAML expression and then evaluate it for the return type.  For the  {x:Static local:ViewModelLocator.LoginViewModel}  expression, MFractor will resolve the  ViewModelLocator  class in the  local  namespace and then grab the C# type of the  LoginViewModel  property. This informs MFractor that the page will be bound to a  LoginViewModel  instance and therefore to analyse all  Binding  expressions against the  LoginViewModel  type.  Explicit binding context resolution will also work when referencing another element using  x:Reference  expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so:     Switch x:Name= mySwitch  / \n   Label BindingContext= {x:Reference mySwitch}  IsVisible= {Binding IsToggled} /   When MFractor analyses the  {Binding IsToggled}  expression, it will evaluate the  {x:Reference mySwitch}  expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch).  Explicit binding context resolution will  always  override implicit binding context resolution. If your XAML views are named using the conventions listed above but your page or a view explicitly assigns the  BindingContext  property then MFractor will use the  BindingContext  return type instead of the implicit Mvvm relationship.", 
            "title": "Explicit Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#design-time-binding-contexts", 
            "text": "It's also possible to explicitly specify a desired binding context by applying the  DesignTimeBindingContext  attribute to the code behind class.  To get started, add the following code file to your project:  DesignTimeBindingContextAttribute.cs  using System;\n\nnamespace MyApp.Attributes\n{\n    ///  summary \n    /// Apply the design time binding context attribute to your code-behind class to inform tools of your intended runtime binding context.\n    ///  /summary \n    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\n    public class DesignTimeBindingContextAttribute : Attribute\n    {\n        ///  summary \n        /// Specifies the design time binding context using a fully qualified type name.\n        ///\n        /// For example: MyApp.ViewModels.LoginViewModel.\n        ///  /summary \n        ///  param name= typeName The fully qualified type name for the design time binding context. /param \n        public DesignTimeBindingContextAttribute(string typeName)\n        {\n        }\n\n        ///  summary \n        /// Specifies the design time binding context using typeof().\n        ///\n        /// For example: typeof(LoginViewModel)\n        ///  /summary \n        ///  param name= type The  see cref= System.Type /  for the design time binding context, using typeof(). /param \n        public DesignTimeBindingContextAttribute(Type type)\n        {\n        }\n    }\n}  Next, apply this attribute onto the code-behind class for your XAML file:  Applying By Type  [DesignTimeBindingContext(typeof(MyBindingContext))]  Applying By String  [DesignTimeBindingContext( MyApp.MyBindingContext )]  Applying this attribute directs MFractor at your binding context to enable data-binding IntelliSense, code actions and code analysis for that XAML file.", 
            "title": "Design Time Binding Contexts"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#data-template-binding-context-resolution", 
            "text": "Data templates are used to provide a nested XAML view to a view that displays many occurrences of that view. For example, a ListView uses a  DataTemplate  to specify the view appearance of each instance provided through the  ItemsSource  property.  MFractor will attempt to infer the BindingContext for a data templates view by resolving the  ItemsSource  property on the wrapping view.  Consider the following code:     ListView ItemsSource= {Binding Contacts} \n       ListView.ItemTemplate \n         DataTemplate \n           TextCell Text= {Binding DisplayName}  / \n         /DataTemplate \n       /ListView.ItemTemplate \n   /ListView   The inner  DataTemplate  has a  TextCell  where the  Text  property is provided by the binding expression  {Binding DisplayName} . To analyse this expression, MFractor requires a binding context; MFractor will walk out to the encapsulating view (ListView), locate the  ItemsSource  property and evaluate the expression.  When the return type is an  IEnumerable  or array, MFractor unwraps the generic or array and grabs the inner type. This provides the binding context type for the binding expressions used within the data template.", 
            "title": "Data Template Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#cross-project-binding-context-resolution", 
            "text": "If your views and view models are in separate projects and you'd like to use implicit MVVM resolution, you'll need to give MFractor a nudge in the right direction.  Unfortunately, it is too expensive to scan the solution to match view models to pages; the scan takes anywhere between 10's to 100's of milliseconds in a moderately sized solution. Therefore, for efficiency reasons, you need to use an MFractor configuration to enable cross-project MVVM resolution.  To make MFractor use View Models in a project separate to your views, you'll need to create an MFractor config for each project.  In the project that contains your views, create a file named app.mfc.xml with the following content:  ?xml version= 1.0  encoding= UTF-8  ?  mfractor \n     configure id= com.mfractor.configuration.forms.mvvm_resolution \n         property name= ViewModelsProjectName  value= TODO: Insert the name of your view models project as it appears in the solution explorer / \n     /configure  /mfractor     In the project that contains your view models, create a file named app.mfc.xml with the following content:  ?xml version= 1.0  encoding= UTF-8  ?  mfractor \n     configure id= com.mfractor.configuration.forms.mvvm_resolution \n         property name= ViewsProjectName  value= TODO: Insert the name of your views project as it appears in the solution explorer / \n     /configure  /mfractor", 
            "title": "Cross Project Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#summary", 
            "text": "In summary, we've learnt that MFractor will use the binding context to power the XAML analyser and navigation improvements.   Binding expressions require a binding context to be analysed.  We can explicitly specify a binding context by assigning the  BindingContext  property of any XAML element.  When we name our code files using the Page.xaml, Page.xaml.cs and ViewModel convention, MFractor will assume an implicit MVVM relationship.  Data templates use the return type of the wrapping views  ItemSource  property.  We can setup a cross project  templates use the return type of the wrapping views  ItemSource  property.", 
            "title": "Summary"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/", 
            "text": "Implementing View Models\n\n\nGenerate properties and view models from XAML to C# using code fixes and the Implement View Model refactoring\n\n\nIntroduction\n\n\nIn Xamarin.Forms apps, we design our applications using the Model - View - ViewModel design pattern; relying on binding mechanisms to mirror data back and forth between the view and view model.\n\n\nWe accomplish this data-transfer behaviour through the \nBinding Markup Extension\n. This is a Xamarin.Forms API that implements the \nIMarkupExtension interface\n; it reflects changes from the binding context to the view and vice-versa.\n\n\nWe use the binding markup extension syntax in our XAML views:\n\n\nLoginPage.xaml.cs\n\n\nEntry Text=\n{Binding Username}\n/\n\n\n\n\n\nLoginViewModel.cs\n\n\npublic class LoginViewModel\n{\n  public string Username { get; set; }\n}\n\n\n\n\nIn the above example, \n{Binding Username}\n points to a public property on the \nLogingPage\ns binding context, the \nLoginViewModel\n. When the user enters text, changes are automatically applied into the \nUsername\n property.\n\n\nBut what if we introduced a new \nEntry\n bound to \nPassword\n, a property that doesn't exist on the \nLoginViewModel\n:\n\n\nLoginPage.xaml.cs\n\n\nEntry Text=\n{Binding Username}\n/\n\n\nEntry Text=\n{Binding Password}\n/\n\n\n\n\n\nProvided we have configured the views binding context correctly, the XAML analyser recognises this is a runtime bug and marks it:\n\n\n\n\nMFractor encourages a \nXAML first\n workflow; you write out bindings in XAML and then generate the implementation on the view model.\n\n\nThis is a big change to existing workflows. Previously, we coded these properties by hand and wire them up manually in the XAML; an approach both time-consuming and error prone. You have to remember property names, property types, control types and then you need to write this all out by hand!\n\n\nUsing binding generation we can \nliterally\n eliminate minutes of work and hundreds of keystrokes in a few clicks.\n\n\nMFractor provides the following shortcuts to implement our bound properties:\n\n\n\n\nFix Missing Binding\n: A code issue fix that generates a single binding property onto the view model.\n\n\nImplement View Model\n: A refactoring action that collects \nall\n missing bindings and generates them in bulk on the view model.\n\n\n\n\nLet's examine these two methods of implementing missing properties using MFractor.\n\n\nIssue Fixing on Missing Bindings\n\n\nWhen MFractor detects that a property in a binding expression doesn't exist on the binding context, it adds a code issue at the missing bindings location.\n\n\nTo action the code isxue fix, we right click on the issue (underlined in yellow), navigate to \nFix\n and then select \nGenerate a property...\n.\n\n\n\n\nWe have two options available when generating a property:\n\n\nGenerate a property named XXX in XXX\n creates a new public property with a public \nget\n and \nset\n accessor:\n\n\npublic string Password { get; set; }\n\n\n\n\nGenerate a property named XXX in XXX with backing fields\n creates a new public property with a public \nget\n and \nset\n accessor that sets or gets a backing field:\n\n\nprivate string _password;\npublic string Password\n{\n  get\n  {\n    return _password;\n  }\n  set\n  {\n    _password = value;\n  }\n}\n\n\n\n\nThe default getter / setter fix is most useful when:\n\n\n\n\nWe want a plain old property with no backing logic.\n\n\nWe are using Fody's \nImplementPropertyChanged\n attribute on our ViewModel to automatically add INotifyPropertyChanged behaviour.\n\n\n\n\nThe backing field fix is most useful when:\n\n\n\n\nWe want backing logic that occurs when our property changes.\n\n\nWe occasionally want to manipulate the properties backing field without changes propagating to the UI.\n\n\n\n\nThe Implement ViewModel Refactoring\n\n\nAnother way to generate properties for a view model is to use the \nImplement View Model\n refactoring. This shortcut collects \nall\n missing binding expressions (excluding bindings inside DataTemplates) and generates them in bulk onto the binding context.\n\n\nWe can access this short cut by right clicking anywhere in a XAML file, navigating to \nGenerate\n and then selecting the \nImplement View Model\n action:\n\n\n\n\nYou'll notice that there are 2 actions:\n\n\n\n\nImplement View Model\n gathers all missing bindings in the XAML document and implements them all as public properties with a public \nget\n and \nset\n accessor.\n\n\nImplement View Model (Use Backing Fields)\n gathers all missing bindings in the XAML document and implements them all as public properties with a public \nget\n and \nset\n accessor that sets or gets a backing field.\n\n\n\n\nThere are often cases when a binding context isn't specified \nexplicitly \n and can't be inferred \nimplicitly\n. A common example of this is that you have just started to build a XAML view and haven't yet got around to building the corresponding view model.\n\n\nThe \nImplement View Model\n action can also generate a view model class for the XAML view if one is not already defined. Using Mvvm naming conventions, MFractor generates a view model class for your XAML view under the \nMyDefaultNamespace.ViewModels\n namespace.\n\n\nFor example:\n\n\nLoginPage.xaml.cs\n\n\nEntry Text=\n{Binding Username}\n/\n\n\nEntry Text=\n{Binding Password}\n/\n\n\n\n\n\nWhen creating the view model class, MFractor removes the \nPage\n or \nView\n suffix from the view name and then attaches \nViewModel\n to the end of the resulting name.\n\n\n\n\n\n\n\n\nRemove the \nPage\n or \nView\n suffix: LoginPage -\n Login\n\n\n\n\n\n\n\n\n\n\nAttach the \nViewModel\n suffix: Login -\n LoginViewModel\n\n\n\n\n\n\n\n\n\n\nGenerate a new class named \nLoginViewModel\n under the namespace \nMyDefaultNamespace.ViewModels\n.\n\n\n\n\n\n\n\n\nThis would result in the following view model class file:\n\n\nLoginViewModel.cs\n\n\npublic namespace MyDefaultNamespace.ViewModels\n{\n  public class LoginViewModel\n  {\n    public string Username { get; set; }\n    public string Password { get; set; }\n  }\n}\n\n\n\n\nIf you project references Fody's \nImplementPropertyChanged\n extension, the default getter / setter implementation will also annotate the result with the \n[ImplementPropertyChanged.PropertyChanged]\n attribute:\n\n\nLoginViewModel.cs\n\n\n[ImplementPropertyChanged.PropertyChanged]\npublic class LoginViewModel\n{\n}\n\n\n\n\nGenerating Commands Implementations\n\n\nWhen MFractor encounters a property that expects the \nSystem.Windows.Input.ICommand\n interface, it will generate a property returning a empty command implementation.\n\n\nFor example, we bind our login button to a \nLoginCommand\n property on our view model:\n\n\nButton Command=\n{Binding LoginCommand}\n/\n\n\n\n\n\nWhen MFractor generates the property for \nLoginCommand\n, it creates an empty command implementation:\n\n\npublic System.Windows.Input.ICommand LoginCommand\n{\n    get\n    {\n        return new Xamarin.Forms.Command(() =\n\n        {\n            throw new NotImplementedException();\n        }\n\n        );\n    }\n}\n\n\n\n\nBinding Generation And Value Converters\n\n\nWhen a binding expression uses a \nConverter\n, MFractor will attempt to resolve the input type of the referenced value converter and use that as the property type. We must have a value conversion attribute on the \nIValueConverter\n for MFractor to resolve the input type. Please read the \nValue Conversion Type-Safety\n tutorial to learn more.\n\n\nFor example, we add a login button that is only enabled when the user has their password entered:\n\n\nResourceDictionary\n\n    \nlocal:StringToBoolConverter x:Key=\nstringToBoolConverter\n /\n\n\n/ResourceDictionary\n\n\n\nButton IsEnabled=\n{Binding Password, Converter={StaticResource stringToBoolConverter}}\n/\n\n\n\n\n\nProvided that \nstringToBoolConverter\n is annotated to accept string inputs and return a boolean output, MFractor can still generate \nPassword\n as a string even though \nIsEnabled\n is a boolean property.\n\n\nIf there is no value conversion information on the value converter, MFractor will default to \nSysten.Object\n as the type for our property:\n\n\npublic System.Object Password\n{\n  get; set;\n}\n\n\n\n\nSummary\n\n\nBy building our apps using the \nXAML first\n mindset, we can leverage MFractor's binding generation to implement our view models quickly.\n\n\nIn this tutorial we learnt:\n\n\n\n\nWe can generate entire view models using the \nImplement View Model\n refactoring action.\n\n\nWe can generate single properties using code issue fixing.\n\n\nWe need a binding context to activate binding expression analysis and issue fixing.\n\n\nWhen a binding uses a value converter, MFractor use the correct type when the converter has a value conversion attribute.", 
            "title": "Implementing View Models"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/#implementing-view-models", 
            "text": "Generate properties and view models from XAML to C# using code fixes and the Implement View Model refactoring", 
            "title": "Implementing View Models"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/#introduction", 
            "text": "In Xamarin.Forms apps, we design our applications using the Model - View - ViewModel design pattern; relying on binding mechanisms to mirror data back and forth between the view and view model.  We accomplish this data-transfer behaviour through the  Binding Markup Extension . This is a Xamarin.Forms API that implements the  IMarkupExtension interface ; it reflects changes from the binding context to the view and vice-versa.  We use the binding markup extension syntax in our XAML views:  LoginPage.xaml.cs  Entry Text= {Binding Username} /   LoginViewModel.cs  public class LoginViewModel\n{\n  public string Username { get; set; }\n}  In the above example,  {Binding Username}  points to a public property on the  LogingPage s binding context, the  LoginViewModel . When the user enters text, changes are automatically applied into the  Username  property.  But what if we introduced a new  Entry  bound to  Password , a property that doesn't exist on the  LoginViewModel :  LoginPage.xaml.cs  Entry Text= {Binding Username} /  Entry Text= {Binding Password} /   Provided we have configured the views binding context correctly, the XAML analyser recognises this is a runtime bug and marks it:   MFractor encourages a  XAML first  workflow; you write out bindings in XAML and then generate the implementation on the view model.  This is a big change to existing workflows. Previously, we coded these properties by hand and wire them up manually in the XAML; an approach both time-consuming and error prone. You have to remember property names, property types, control types and then you need to write this all out by hand!  Using binding generation we can  literally  eliminate minutes of work and hundreds of keystrokes in a few clicks.  MFractor provides the following shortcuts to implement our bound properties:   Fix Missing Binding : A code issue fix that generates a single binding property onto the view model.  Implement View Model : A refactoring action that collects  all  missing bindings and generates them in bulk on the view model.   Let's examine these two methods of implementing missing properties using MFractor.", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/#issue-fixing-on-missing-bindings", 
            "text": "When MFractor detects that a property in a binding expression doesn't exist on the binding context, it adds a code issue at the missing bindings location.  To action the code isxue fix, we right click on the issue (underlined in yellow), navigate to  Fix  and then select  Generate a property... .   We have two options available when generating a property:  Generate a property named XXX in XXX  creates a new public property with a public  get  and  set  accessor:  public string Password { get; set; }  Generate a property named XXX in XXX with backing fields  creates a new public property with a public  get  and  set  accessor that sets or gets a backing field:  private string _password;\npublic string Password\n{\n  get\n  {\n    return _password;\n  }\n  set\n  {\n    _password = value;\n  }\n}  The default getter / setter fix is most useful when:   We want a plain old property with no backing logic.  We are using Fody's  ImplementPropertyChanged  attribute on our ViewModel to automatically add INotifyPropertyChanged behaviour.   The backing field fix is most useful when:   We want backing logic that occurs when our property changes.  We occasionally want to manipulate the properties backing field without changes propagating to the UI.", 
            "title": "Issue Fixing on Missing Bindings"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/#the-implement-viewmodel-refactoring", 
            "text": "Another way to generate properties for a view model is to use the  Implement View Model  refactoring. This shortcut collects  all  missing binding expressions (excluding bindings inside DataTemplates) and generates them in bulk onto the binding context.  We can access this short cut by right clicking anywhere in a XAML file, navigating to  Generate  and then selecting the  Implement View Model  action:   You'll notice that there are 2 actions:   Implement View Model  gathers all missing bindings in the XAML document and implements them all as public properties with a public  get  and  set  accessor.  Implement View Model (Use Backing Fields)  gathers all missing bindings in the XAML document and implements them all as public properties with a public  get  and  set  accessor that sets or gets a backing field.   There are often cases when a binding context isn't specified  explicitly   and can't be inferred  implicitly . A common example of this is that you have just started to build a XAML view and haven't yet got around to building the corresponding view model.  The  Implement View Model  action can also generate a view model class for the XAML view if one is not already defined. Using Mvvm naming conventions, MFractor generates a view model class for your XAML view under the  MyDefaultNamespace.ViewModels  namespace.  For example:  LoginPage.xaml.cs  Entry Text= {Binding Username} /  Entry Text= {Binding Password} /   When creating the view model class, MFractor removes the  Page  or  View  suffix from the view name and then attaches  ViewModel  to the end of the resulting name.     Remove the  Page  or  View  suffix: LoginPage -  Login      Attach the  ViewModel  suffix: Login -  LoginViewModel      Generate a new class named  LoginViewModel  under the namespace  MyDefaultNamespace.ViewModels .     This would result in the following view model class file:  LoginViewModel.cs  public namespace MyDefaultNamespace.ViewModels\n{\n  public class LoginViewModel\n  {\n    public string Username { get; set; }\n    public string Password { get; set; }\n  }\n}  If you project references Fody's  ImplementPropertyChanged  extension, the default getter / setter implementation will also annotate the result with the  [ImplementPropertyChanged.PropertyChanged]  attribute:  LoginViewModel.cs  [ImplementPropertyChanged.PropertyChanged]\npublic class LoginViewModel\n{\n}", 
            "title": "The Implement ViewModel Refactoring"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/#generating-commands-implementations", 
            "text": "When MFractor encounters a property that expects the  System.Windows.Input.ICommand  interface, it will generate a property returning a empty command implementation.  For example, we bind our login button to a  LoginCommand  property on our view model:  Button Command= {Binding LoginCommand} /   When MFractor generates the property for  LoginCommand , it creates an empty command implementation:  public System.Windows.Input.ICommand LoginCommand\n{\n    get\n    {\n        return new Xamarin.Forms.Command(() = \n        {\n            throw new NotImplementedException();\n        }\n\n        );\n    }\n}", 
            "title": "Generating Commands Implementations"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/#binding-generation-and-value-converters", 
            "text": "When a binding expression uses a  Converter , MFractor will attempt to resolve the input type of the referenced value converter and use that as the property type. We must have a value conversion attribute on the  IValueConverter  for MFractor to resolve the input type. Please read the  Value Conversion Type-Safety  tutorial to learn more.  For example, we add a login button that is only enabled when the user has their password entered:  ResourceDictionary \n     local:StringToBoolConverter x:Key= stringToBoolConverter  /  /ResourceDictionary  Button IsEnabled= {Binding Password, Converter={StaticResource stringToBoolConverter}} /   Provided that  stringToBoolConverter  is annotated to accept string inputs and return a boolean output, MFractor can still generate  Password  as a string even though  IsEnabled  is a boolean property.  If there is no value conversion information on the value converter, MFractor will default to  Systen.Object  as the type for our property:  public System.Object Password\n{\n  get; set;\n}", 
            "title": "Binding Generation And Value Converters"
        }, 
        {
            "location": "/xamarin-forms/implementing-view-models/#summary", 
            "text": "By building our apps using the  XAML first  mindset, we can leverage MFractor's binding generation to implement our view models quickly.  In this tutorial we learnt:   We can generate entire view models using the  Implement View Model  refactoring action.  We can generate single properties using code issue fixing.  We need a binding context to activate binding expression analysis and issue fixing.  When a binding uses a value converter, MFractor use the correct type when the converter has a value conversion attribute.", 
            "title": "Summary"
        }, 
        {
            "location": "/xamarin-forms/value-converter-type-safety/", 
            "text": "Value Converter Type Safety\n\n\nProvide Xaml type-safety by annotating IValueConverter's with the ValueConversion attribute\n\n\nIntroduction\n\n\nIn Xamarin.Forms developers data bind properties in a control to properties on a binding context using the \nBinding\n markup extension.\n\n\nTypically, the type on the control's property matches the type on the binding context property. But what if we had a screen with an email entry that needs to change color when the user enters a valid email?\n\n\nEnter the \nIValueConverter interface\n; value converters transform one data type to another.\n\n\nWe can expose a boolean \nIsEmailValid\n on our binding context, bind the \nTextColor\n field of the entry to the \nIsEmailValid\n property and use an \nIValueConverter\n that converts a \nTrue\n value to black and a \nFalse\n value to red.\n\n\nOur converter would look like this:\n\n\npublic class BoolToTextColorConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        return (bool)value ? Color.Black : Color.Red;\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        throw new NotImplementedException();\n    }\n}\n\n\n\n\nAnd when used in our xaml:\n\n\nLoginPage.xaml\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nContentPage\n        xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n        xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n        x:Class=\nMyApp.LoginPage\n\n        xmlns:converters=\nclr-namespace:MyApp.Converters;assembly=MyApp\n\n    \nContentPage.Resources\n\n        \nResourceDictionary\n\n            \nconverters:BoolToTextColorConverter x:Key=\nboolToTextColorConverter\n /\n\n        \n/ResourceDictionary\n\n    \n/ContentPage.Resources\n\n    \nEntry TextColor=\n{Binding IsEmailValid, Converter={StaticResource boolToTextColorConverter}}\n/\n\n\n/ContentPage\n\n\n\n\n\nNow when the user enters an invalid email, the value converter will translate the \nIsEmailValid\n boolean property in a \nXamarin.Forms.Color\n!\n\n\nBut what if we accidentally provided a \nstring\n to the \nBoolToTextColorConverter\n:\n\n\nEntry TextColor=\n{Binding Email, Converter={StaticResource boolToTextColorConverter}}\n/\n\n\n\n\n\nThis creates a runtime bug we won't discover until we build, deploy and navigate to the \nLoginPage\n; we'll see a type cast exception without a clear indication of the problem.\n\n\nWe can completely avoid this problem by declaring a value converters intent with an \nValueConversionAttribute\n to hint to MFractor's Xaml analyser it's expected behaviour.\n\n\nThe ValueConversion Attribute\n\n\nIn WPF, Microsoft provides the \nValueConversionAttribute\n that developers can use to describe the input, output and parameter type that an \nIValueConverter\n expects. This class level annotation declares the intent of a value converter to tools and to other developers using a converter.\n\n\nUnfortunately this attribute is in the \nPresentationFramework\n assembly, which we can't reference in a Xamarin.Forms PCL or shared project.\n\n\nAs the \nValueConversionAttribute\n is simple in implementation, we can easily make our own:\n\n\n[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]\npublic class ValueConversionAttribute : Attribute\n{\n  public ValueConversionAttribute(Type input, Type output)\n  {\n  }\n\n  public Type ParameterType { get; set; }\n}\n\n\n\n\nLet's examine this attribute in detail:\n\n\n\n\nThe constructor \nValueConversionAttribute(Type input, Type output)\n declares the expected input and output types for a converter.\n\n\nType input\n is the expected \ninput\n type for the value converter. This is the argument \nobject value\n for the \nConvert\n method and the return type for the \nConvertBack\n method.\n\n\nType output\n is the expected \noutput\n type for the value converter. This is the return type for the \nConvert\n method and the argument \nobject value\n for the \nConvertBack\n method.\n\n\nThe property \nType ParameterType\n is the expected \nparamter\n type for the value converter. This is the argument \nobject parameter\n for the \nConvert\n and \nConvertBack\n methods.\n\n\n\n\nTo use the \nValueConversionAttribute\n in our source code, we annotate a value converter at the class level and use the \ntypeof\n operator to provide input, output and parameter types:\n\n\n[ValueConversion(typeof(bool), typeof(Xamarin.Forms.Color))]\npublic class BoolToTextColorConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        return (bool)value ? Color.Black : Color.Red;\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        throw new NotImplementedException();\n    }\n}\n\n\n\n\nThe \nBoolToTextColorConverter\n now declares it's intent when converting values to both tooling and other developers; it \nmust\n have a \nbool\n as an input and it \nmust\n return into a \nXamarin.Forms.Color\n type.\n\n\nTo include the \nValueConversionAttribute\n we can simply copy-paste the code into our code base. Alternatively, add a third party library like \nFormsCommunityToolkit.Converters\n that has the \nValueConversionAttribute\n defined.\n\n\nConverter Type-Safety in Xaml\n\n\nWhen an \nIValueConverter\n is annotated with the \nValueConversion\n attribute, we declare to MFractor that our value converter wishes to enforce \ntype safety\n.\n\n\nThis has a few benefits:\n\n\n\n\nMFractor can now verify the types passed into and returned by a \nConverter\n expression are correct in the given context.\n\n\nWhen MFractor is generating a property from a binding expression, it can now extract the type information for a converter and generate that property with the correct type information.\n\n\n\n\nLet's consider our previous example of a provided a string as the input to the \nBoolToTextColorConverter\n:\n\n\nEntry TextColor=\n{Binding Email, Converter={StaticResource boolToTextColorConverter}}\n/\n\n\n\n\n\nWhen analysing the \nBinding\n expression, MFractor will inspect for \nConverter\n expressions and then evaluate the inner converter for it's expected input and output type.\n\n\nAs we have provided a \nstring\n but \nBoolToTextColorConverter\n expects a \nbool\n, MFractor will mark this as an error within the Xaml editor:\n\n\n\n\nVoila! We now have type-safety in our Xaml when using value converters! \u2728\u2728\n\n\nAnnotated value converters also allow the refactoring engine to correctly generate properties.\n\n\nFor example, if the our binding context is missing the \nEmail\n property, MFractor will extract the input type from the value converter and use that to generate the binding property:\n\n\n\n\nInstead of using the type of the \nTextColor\n property, MFractor could see that \nBoolToTextColorConverter\n expected a \nbool\n value and then generated the \nEmail\n property with a \nbool\n.\n\n\nSummary\n\n\nIn this tutorial we learnt:\n\n\n\n\nWe can annotate implementations of \nIValueConverter\n with a \nValueConversionAttribute\n to declare it's value conversion intent.\n\n\nAnnotated value converters enable MFractor's Xaml analyser to provide type-safety in the Xaml editor.\n\n\nAnnotated value converters enable MFractor's refactoring engine to generate properties with the correct type information.", 
            "title": "Value Converter Type Safety"
        }, 
        {
            "location": "/xamarin-forms/value-converter-type-safety/#value-converter-type-safety", 
            "text": "Provide Xaml type-safety by annotating IValueConverter's with the ValueConversion attribute", 
            "title": "Value Converter Type Safety"
        }, 
        {
            "location": "/xamarin-forms/value-converter-type-safety/#introduction", 
            "text": "In Xamarin.Forms developers data bind properties in a control to properties on a binding context using the  Binding  markup extension.  Typically, the type on the control's property matches the type on the binding context property. But what if we had a screen with an email entry that needs to change color when the user enters a valid email?  Enter the  IValueConverter interface ; value converters transform one data type to another.  We can expose a boolean  IsEmailValid  on our binding context, bind the  TextColor  field of the entry to the  IsEmailValid  property and use an  IValueConverter  that converts a  True  value to black and a  False  value to red.  Our converter would look like this:  public class BoolToTextColorConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        return (bool)value ? Color.Black : Color.Red;\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        throw new NotImplementedException();\n    }\n}  And when used in our xaml:  LoginPage.xaml  ?xml version= 1.0  encoding= UTF-8 ?  ContentPage\n        xmlns= http://xamarin.com/schemas/2014/forms \n        xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n        x:Class= MyApp.LoginPage \n        xmlns:converters= clr-namespace:MyApp.Converters;assembly=MyApp \n     ContentPage.Resources \n         ResourceDictionary \n             converters:BoolToTextColorConverter x:Key= boolToTextColorConverter  / \n         /ResourceDictionary \n     /ContentPage.Resources \n     Entry TextColor= {Binding IsEmailValid, Converter={StaticResource boolToTextColorConverter}} /  /ContentPage   Now when the user enters an invalid email, the value converter will translate the  IsEmailValid  boolean property in a  Xamarin.Forms.Color !  But what if we accidentally provided a  string  to the  BoolToTextColorConverter :  Entry TextColor= {Binding Email, Converter={StaticResource boolToTextColorConverter}} /   This creates a runtime bug we won't discover until we build, deploy and navigate to the  LoginPage ; we'll see a type cast exception without a clear indication of the problem.  We can completely avoid this problem by declaring a value converters intent with an  ValueConversionAttribute  to hint to MFractor's Xaml analyser it's expected behaviour.", 
            "title": "Introduction"
        }, 
        {
            "location": "/xamarin-forms/value-converter-type-safety/#the-valueconversion-attribute", 
            "text": "In WPF, Microsoft provides the  ValueConversionAttribute  that developers can use to describe the input, output and parameter type that an  IValueConverter  expects. This class level annotation declares the intent of a value converter to tools and to other developers using a converter.  Unfortunately this attribute is in the  PresentationFramework  assembly, which we can't reference in a Xamarin.Forms PCL or shared project.  As the  ValueConversionAttribute  is simple in implementation, we can easily make our own:  [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]\npublic class ValueConversionAttribute : Attribute\n{\n  public ValueConversionAttribute(Type input, Type output)\n  {\n  }\n\n  public Type ParameterType { get; set; }\n}  Let's examine this attribute in detail:   The constructor  ValueConversionAttribute(Type input, Type output)  declares the expected input and output types for a converter.  Type input  is the expected  input  type for the value converter. This is the argument  object value  for the  Convert  method and the return type for the  ConvertBack  method.  Type output  is the expected  output  type for the value converter. This is the return type for the  Convert  method and the argument  object value  for the  ConvertBack  method.  The property  Type ParameterType  is the expected  paramter  type for the value converter. This is the argument  object parameter  for the  Convert  and  ConvertBack  methods.   To use the  ValueConversionAttribute  in our source code, we annotate a value converter at the class level and use the  typeof  operator to provide input, output and parameter types:  [ValueConversion(typeof(bool), typeof(Xamarin.Forms.Color))]\npublic class BoolToTextColorConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        return (bool)value ? Color.Black : Color.Red;\n    }\n\n    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n    {\n        throw new NotImplementedException();\n    }\n}  The  BoolToTextColorConverter  now declares it's intent when converting values to both tooling and other developers; it  must  have a  bool  as an input and it  must  return into a  Xamarin.Forms.Color  type.  To include the  ValueConversionAttribute  we can simply copy-paste the code into our code base. Alternatively, add a third party library like  FormsCommunityToolkit.Converters  that has the  ValueConversionAttribute  defined.", 
            "title": "The ValueConversion Attribute"
        }, 
        {
            "location": "/xamarin-forms/value-converter-type-safety/#converter-type-safety-in-xaml", 
            "text": "When an  IValueConverter  is annotated with the  ValueConversion  attribute, we declare to MFractor that our value converter wishes to enforce  type safety .  This has a few benefits:   MFractor can now verify the types passed into and returned by a  Converter  expression are correct in the given context.  When MFractor is generating a property from a binding expression, it can now extract the type information for a converter and generate that property with the correct type information.   Let's consider our previous example of a provided a string as the input to the  BoolToTextColorConverter :  Entry TextColor= {Binding Email, Converter={StaticResource boolToTextColorConverter}} /   When analysing the  Binding  expression, MFractor will inspect for  Converter  expressions and then evaluate the inner converter for it's expected input and output type.  As we have provided a  string  but  BoolToTextColorConverter  expects a  bool , MFractor will mark this as an error within the Xaml editor:   Voila! We now have type-safety in our Xaml when using value converters! \u2728\u2728  Annotated value converters also allow the refactoring engine to correctly generate properties.  For example, if the our binding context is missing the  Email  property, MFractor will extract the input type from the value converter and use that to generate the binding property:   Instead of using the type of the  TextColor  property, MFractor could see that  BoolToTextColorConverter  expected a  bool  value and then generated the  Email  property with a  bool .", 
            "title": "Converter Type-Safety in Xaml"
        }, 
        {
            "location": "/xamarin-forms/value-converter-type-safety/#summary", 
            "text": "In this tutorial we learnt:   We can annotate implementations of  IValueConverter  with a  ValueConversionAttribute  to declare it's value conversion intent.  Annotated value converters enable MFractor's Xaml analyser to provide type-safety in the Xaml editor.  Annotated value converters enable MFractor's refactoring engine to generate properties with the correct type information.", 
            "title": "Summary"
        }, 
        {
            "location": "/code-actions/csharp/", 
            "text": "C# Code Actions\n\n\nAutogenerated by MFractor v3.7.3\n\n\nAlign Namespace To Folder Path\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.csharp_align_namespace_to_folder_path\n\n\n\n\nFor the namespace under the users cursor, this will make the namespace declaration align to the projects default namespace plus the virtual folder path this file is under.\n\n\nUses:\n\n\n\n\nNamespace Declaration\n\n\n\n\nCopy Var Type To Clipboard\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.csharp.misc.copy_var_type_to_clipboard\n\n\nFor the given \nvar\n variable declaration under the cursor, copies the fully qualified name of the symbol.\n\n\nCreate Immutable Constructor\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.csharp.create_immutable_constuctor\n\n\n\n\nThis code action creates a constructor that assigns all of a classes readonly fields from constructor arguments\n\n\nThe \nCreate Immutable Constructor\n code action is useful when building readonly class implementations.\n\n\nWhen triggered, the code action collects all readonly fields in a class and builds a constructor that has a parameter that assigns to each readonly field.\n\n\nBefore\n\n\npublic class MyImmutableClass\n{\n    public readonly string MyString;\n    public readonly int MyInt;\n}\n\n\n\n\nAfter\n\n\npublic class MyImmutableClass\n{\n    public readonly string MyString;\n    public readonly int MyInt;\n\n    public MyImmutableClass(string myString, myInt)\n    {\n        MyString = myString;\n        MyInt = myInt;\n    }\n}\n\n\n\n\nUses:\n\n\n\n\nGenerate Assignment Expression\n\n\nCreate Constructor\n\n\n\n\nExclude Symbol From Linker\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.linker.exclude_symbol_from_linking\n\n\n\n\nWhen creating Android and iOS applications, the Xamarin toolchain uses the Linker to remove unused symbols from the final application build. The \nExclude Symbol From Linker\n code action generates a linker.xml entry for the symbol that is selected.\n\n\nUses:\n\n\n\n\nLinker File Generation\n\n\nLinker XML Generator\n\n\n\n\nGenerate Interface Implementation\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.csharp.generate_interface_implementation\n\n\n\n\nCreates a new implementation of the selected interface.\n\n\nUses:\n\n\n\n\nCreate Class Declaration\n\n\nNamespace Declaration\n\n\nUsing Directive Generator\n\n\n\n\nGo To Implementation\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.csharp.go_to_interface_implementation\n\n\n\n\nShortcut:\n \nOption + D\n\n\nNavigates to the implementation of an interface, abstract class or any members of that interface/abstract class. If there are multiple implementations of this interface/class/member, shows a list of everywhere it is declared.\n\n\nImplement Base Class Constructors\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.csharp.implement_base_class_constructors\n\n\nWhen a C# class inherits from a base type that does only has parameterised constructors, this code action will generate each of the base classes parametered constructors.\n\n\nFor example, say a developer wanted to inherit \nMyCustomView\n from \nAndroid.Views.View\n to create a custom view in Xamarin.Android; the \nView\n class does not have any paramterless contructors.\n\n\n\npublic class MyCustomView : Android.Views.View // Generates a compiler error as View has no parameterless constructors. \n{\n}\n\n\n\n\n\nUsing the \nImplement Base Class Constructors\n code action against the \nMyCustomView\n class would generate the following code.\n\n\n\npublic class MyClass : View\n{\n    public MyClass(System.IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer) : base(javaReference, transfer)\n    {\n    }\n\n    public MyClass(Android.Content.Context context) : base(context)\n    {\n    }\n\n    public MyClass(Android.Content.Context context, Android.Util.IAttributeSet attrs) : base(context, attrs)\n    {\n    }\n\n    public MyClass(Android.Content.Context context, Android.Util.IAttributeSet attrs, int defStyleAttr) : base(context, attrs, defStyleAttr)\n    {\n    }\n\n    public MyClass(Android.Content.Context context, Android.Util.IAttributeSet attrs, int defStyleAttr, int defStyleRes) : base(context, attrs, defStyleAttr, defStyleRes)\n    {\n    }\n}\n\n\n\n\n\nUses:\n\n\n\n\nCreate Base Constructor\n\n\n\n\nImplement Interface Member In Children\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.csharp.implement_interface_member_in_children\n\n\nThis code action detects when classes implemening an interface do not have an implementation for the member under the cursor and generates a stub for it in all classes where it's missing.'\n\n\nUses:\n\n\n\n\nMember Field Generator\n\n\nGenerate Instance Property\n\n\nMethod Generator\n\n\nCreate Base Constructor\n\n\nGenerate Event Handler Declaration\n\n\n\n\nReplace String With Resource Lookup\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.resx.replace_csharp_string_with_resource_lookup\n\n\n\n\nThis code refactoring will open the localisation wizard, allowing you to walk through all strings in a C# code file and replace inline strings with resource lookups.\n\n\nUses:\n\n\n\n\nGenerate ResX Entry\n\n\nGenerate C# ResX Resource Lookup\n\n\nDefault Resource File\n\n\n\n\nSimplify Qualified Type\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.csharp.simplify_qualified\n\n\n\n\nWhen a type reference is qualified with either a full or partial namespace, this refactoring inserts a using statement for the types namespace and removes the namespace component of the type.", 
            "title": "C# Code Actions"
        }, 
        {
            "location": "/code-actions/csharp/#c-code-actions", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "C# Code Actions"
        }, 
        {
            "location": "/code-actions/csharp/#align-namespace-to-folder-path", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.csharp_align_namespace_to_folder_path   For the namespace under the users cursor, this will make the namespace declaration align to the projects default namespace plus the virtual folder path this file is under.", 
            "title": "Align Namespace To Folder Path"
        }, 
        {
            "location": "/code-actions/csharp/#uses", 
            "text": "Namespace Declaration", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/csharp/#copy-var-type-to-clipboard", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.csharp.misc.copy_var_type_to_clipboard  For the given  var  variable declaration under the cursor, copies the fully qualified name of the symbol.", 
            "title": "Copy Var Type To Clipboard"
        }, 
        {
            "location": "/code-actions/csharp/#create-immutable-constructor", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.csharp.create_immutable_constuctor   This code action creates a constructor that assigns all of a classes readonly fields from constructor arguments  The  Create Immutable Constructor  code action is useful when building readonly class implementations.  When triggered, the code action collects all readonly fields in a class and builds a constructor that has a parameter that assigns to each readonly field.  Before  public class MyImmutableClass\n{\n    public readonly string MyString;\n    public readonly int MyInt;\n}  After  public class MyImmutableClass\n{\n    public readonly string MyString;\n    public readonly int MyInt;\n\n    public MyImmutableClass(string myString, myInt)\n    {\n        MyString = myString;\n        MyInt = myInt;\n    }\n}", 
            "title": "Create Immutable Constructor"
        }, 
        {
            "location": "/code-actions/csharp/#uses_1", 
            "text": "Generate Assignment Expression  Create Constructor", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/csharp/#exclude-symbol-from-linker", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.linker.exclude_symbol_from_linking   When creating Android and iOS applications, the Xamarin toolchain uses the Linker to remove unused symbols from the final application build. The  Exclude Symbol From Linker  code action generates a linker.xml entry for the symbol that is selected.", 
            "title": "Exclude Symbol From Linker"
        }, 
        {
            "location": "/code-actions/csharp/#uses_2", 
            "text": "Linker File Generation  Linker XML Generator", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/csharp/#generate-interface-implementation", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.csharp.generate_interface_implementation   Creates a new implementation of the selected interface.", 
            "title": "Generate Interface Implementation"
        }, 
        {
            "location": "/code-actions/csharp/#uses_3", 
            "text": "Create Class Declaration  Namespace Declaration  Using Directive Generator", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/csharp/#go-to-implementation", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.csharp.go_to_interface_implementation   Shortcut:   Option + D  Navigates to the implementation of an interface, abstract class or any members of that interface/abstract class. If there are multiple implementations of this interface/class/member, shows a list of everywhere it is declared.", 
            "title": "Go To Implementation"
        }, 
        {
            "location": "/code-actions/csharp/#implement-base-class-constructors", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.csharp.implement_base_class_constructors  When a C# class inherits from a base type that does only has parameterised constructors, this code action will generate each of the base classes parametered constructors.  For example, say a developer wanted to inherit  MyCustomView  from  Android.Views.View  to create a custom view in Xamarin.Android; the  View  class does not have any paramterless contructors.  \npublic class MyCustomView : Android.Views.View // Generates a compiler error as View has no parameterless constructors. \n{\n}  Using the  Implement Base Class Constructors  code action against the  MyCustomView  class would generate the following code.  \npublic class MyClass : View\n{\n    public MyClass(System.IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer) : base(javaReference, transfer)\n    {\n    }\n\n    public MyClass(Android.Content.Context context) : base(context)\n    {\n    }\n\n    public MyClass(Android.Content.Context context, Android.Util.IAttributeSet attrs) : base(context, attrs)\n    {\n    }\n\n    public MyClass(Android.Content.Context context, Android.Util.IAttributeSet attrs, int defStyleAttr) : base(context, attrs, defStyleAttr)\n    {\n    }\n\n    public MyClass(Android.Content.Context context, Android.Util.IAttributeSet attrs, int defStyleAttr, int defStyleRes) : base(context, attrs, defStyleAttr, defStyleRes)\n    {\n    }\n}", 
            "title": "Implement Base Class Constructors"
        }, 
        {
            "location": "/code-actions/csharp/#uses_4", 
            "text": "Create Base Constructor", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/csharp/#implement-interface-member-in-children", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.csharp.implement_interface_member_in_children  This code action detects when classes implemening an interface do not have an implementation for the member under the cursor and generates a stub for it in all classes where it's missing.'", 
            "title": "Implement Interface Member In Children"
        }, 
        {
            "location": "/code-actions/csharp/#uses_5", 
            "text": "Member Field Generator  Generate Instance Property  Method Generator  Create Base Constructor  Generate Event Handler Declaration", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/csharp/#replace-string-with-resource-lookup", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.resx.replace_csharp_string_with_resource_lookup   This code refactoring will open the localisation wizard, allowing you to walk through all strings in a C# code file and replace inline strings with resource lookups.", 
            "title": "Replace String With Resource Lookup"
        }, 
        {
            "location": "/code-actions/csharp/#uses_6", 
            "text": "Generate ResX Entry  Generate C# ResX Resource Lookup  Default Resource File", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/csharp/#simplify-qualified-type", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.csharp.simplify_qualified   When a type reference is qualified with either a full or partial namespace, this refactoring inserts a using statement for the types namespace and removes the namespace component of the type.", 
            "title": "Simplify Qualified Type"
        }, 
        {
            "location": "/code-actions/csharp/android/", 
            "text": "Android C# Code Actions\n\n\nAutogenerated by MFractor v3.5.13\n\n\nAdd UsesLayout Annotation To Class\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.android.add_uses_layout_annotation\n\n\nWhen triggered on a \nResource.Layout.myLayout\n expression in C#, this code refactoring adds an MFractor \nUsesLayout\n annotation to provide layout safety for that class.\n\n\nUses:\n\n\n\n\nGenerate UsesLayout Attribute Annotation", 
            "title": "Android"
        }, 
        {
            "location": "/code-actions/csharp/android/#android-c-code-actions", 
            "text": "Autogenerated by MFractor v3.5.13", 
            "title": "Android C# Code Actions"
        }, 
        {
            "location": "/code-actions/csharp/android/#add-useslayout-annotation-to-class", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.android.add_uses_layout_annotation  When triggered on a  Resource.Layout.myLayout  expression in C#, this code refactoring adds an MFractor  UsesLayout  annotation to provide layout safety for that class.", 
            "title": "Add UsesLayout Annotation To Class"
        }, 
        {
            "location": "/code-actions/csharp/android/#uses", 
            "text": "Generate UsesLayout Attribute Annotation", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/csharp/forms/", 
            "text": "Xamarin.Forms C# Code Actions\n\n\nAutogenerated by MFractor v3.7.3\n\n\nCreate Bindable Property\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.forms.insert_bindable_property\n\n\n\n\nWhen inside a Visual Element, this code action generates a new bindable property declaration.\n\n\nUses:\n\n\n\n\nGenerate Bindable Property\n\n\n\n\nGenerate Custom Renderers\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.forms.generate_custom_renderers\n\n\n\n\nGenerates a platform specific custom renderer for a control. This code action will resolve the correct control baseclass on each platform and then create a custom render in each iOS or Android project.\n\n\nUses:\n\n\n\n\nGenerate Custom Renderer For Xamarin.Forms Control\n\n\n\n\nInsert ViewModel Command\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.forms.insert_view_model_command\n\n\n\n\nWhen inside a View Model, this code action generates a new command implementation.\n\n\nUses:\n\n\n\n\nGenerate ICommand Implementation", 
            "title": "Xamarin.Forms"
        }, 
        {
            "location": "/code-actions/csharp/forms/#xamarinforms-c-code-actions", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "Xamarin.Forms C# Code Actions"
        }, 
        {
            "location": "/code-actions/csharp/forms/#create-bindable-property", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.forms.insert_bindable_property   When inside a Visual Element, this code action generates a new bindable property declaration.", 
            "title": "Create Bindable Property"
        }, 
        {
            "location": "/code-actions/csharp/forms/#uses", 
            "text": "Generate Bindable Property", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/csharp/forms/#generate-custom-renderers", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.forms.generate_custom_renderers   Generates a platform specific custom renderer for a control. This code action will resolve the correct control baseclass on each platform and then create a custom render in each iOS or Android project.", 
            "title": "Generate Custom Renderers"
        }, 
        {
            "location": "/code-actions/csharp/forms/#uses_1", 
            "text": "Generate Custom Renderer For Xamarin.Forms Control", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/csharp/forms/#insert-viewmodel-command", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.forms.insert_view_model_command   When inside a View Model, this code action generates a new command implementation.", 
            "title": "Insert ViewModel Command"
        }, 
        {
            "location": "/code-actions/csharp/forms/#uses_2", 
            "text": "Generate ICommand Implementation", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/", 
            "text": "XAML Code Fixes\n\n\nAutogenerated by MFractor v3.7.3\n\n\nAdd Missing Target Type Attribute\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.style_is_missing_target_type\n\n\nFixes Code Issue:\n \nStyle Is Missing TargetType\n\n\nWhen a style is missing a \nTargetType\n attribute or property setter node, this fix will insert an empty target type attribute.\n\n\nAutocorrect Invalid FontSize\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.autocorrect_invalid_font_size\n\n\nFixes Code Issue:\n \nInvalid Named Font Size\n\n\nWhen a developer accidentally mispells a named FontSize value, this fix will auto-correct it to a valid font size name.\n\n\nAutocorrect Symbol In Markup Expression\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.autocorrect_csharp_symbol\n\n\nFixes Code Issue:\n \nUnresolved .NET Symbols Within Xaml Expression\n\n\nWhen a .NET symbol referenced inside a XAML markup extension does not exist but a closely named symbol can be found within the current solution, this code fix will replace the bad symbol reference with a reference the closely named symbol.\n\n\nThis code fix works on both class references and property references.\n\n\nCorrect Member Name\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.autocorrect_member\n\n\nFixes Code Issue:\n \nReferenced Attribute Member Exists In Parent Type\n\n\nLooks for members on a C# class that are named closely to an unresolved xml attribute and then suggest near matches.\n\n\nCorrect Property Binding Name\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.correct_property_binding_name\n\n\nFixes Code Issue:\n \nBinding Expressions Resolve\n\n\nCreate Missing Property For Class\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_property\n\n\nFixes Code Issue:\n \nReferenced Attribute Member Exists In Parent Type\n\n\nThis fix let's you create a public property onto a writable class referenced in your XAML.\n\n\nFor this fix to activate, the following conditions must be fulfilled:\n\n\n\n\nThe attribute used on a XAML node does not exist on the .NET class for that node.\n\n\nThe class referenced by the XAML node is within the users source code.\n\n\n\n\nConsider the following code example:\n\n\nMyCustomControl.cs\n\n\npublic class MyCustomControl : Xamarin.Forms.View\n{\n}\n\n\n\n\nMyPage.xaml\n\n\nContentPage xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n    xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n    x:Class=\nMyApp.MainPage\n\n    \nMyCustomControl OnTappedMessage=\nThe custom control was tapped!\n/\n\n\n/ContentPage\n\n\n\n\n\nThe attribute \nOnTappedMessage\n is attempting to reference a member that does not exist inside \nMyCustomControl\n; a developer can use this code action to generate that missing member:\n\n\nMyCustomControl.cs\n\n\npublic class MyCustomControl : Xamarin.Forms.View\n{\n    public string OnTappedMessage { get; set; }\n}\n\n\n\n\nWhen the class derives from \nXamarin.Forms.View\n, this code action can be used to generate a bindable property implementation.\n\n\nThe code action will attempt to resolve the new properties type by inspecting the value of the source attribute. If the value is an expression, MFractor will evaluate the expression and use the return type as the new properties type.\n\n\nIf the attributes value isn't an expression, MFractor will attempt to infer type based on the literal input. For example, an attribute value of \ntrue\n would trigger MFractor to output a boolean typed property. This behaviour can be disabled by configuring the \nTryInferUnknownTypes\n to false.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nTryInferUnknownTypes\n\n\nBoolean\n\n\nTrue\n\n\nShould MFractor attempt to guess the type for the new property based on it's value? EG: A value of \ntrue\n would cause the output type to be \nbool\n instead of \nSystem.Object\n.\n\n\n\n\n\n\nDefaultColorType\n\n\nSystem.String\n\n\nXamarin.Forms.Color\n\n\nWhen attempting to infer the property type based on its value and MFractor decides it's a color, what is the color type MFractor should use?\n\n\n\n\n\n\nDefaultPropertyType\n\n\nSystem.String\n\n\nSystem.Object\n\n\nWhat is the default type for the new property if MFractor can't figure it out based on the attribute value?\n\n\n\n\n\n\nDefaultImageType\n\n\nSystem.String\n\n\nXamarin.Forms.ImageSource\n\n\nWhen attempting to infer the property type based on its value and MFractor decides it's an image, what is the CLR type MFractor should use?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Bindable Property\n\n\nView Model Property Generator\n\n\nGenerate Event Handler Declaration\n\n\n\n\nCreate Value Converter To Resolve Type Flow\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.create_resolving_value_converter\n\n\nFixes Code Issue:\n \nBinding Expression Return Type Mismatch\n\n\n\n\nUsing the input and output type for a value conversion path, this code fix creates a new value converter implementation for the input and output type and imports it into the views resource dictionary.\n\n\nUses:\n\n\n\n\nGenerate IValueConverter Implementation\n\n\nValue Conversion Settings\n\n\n\n\nCreate x:TypeArguments Attribute\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.create_type_arguments_attribute\n\n\nFixes Code Issue:\n \nGeneric Usage Is Missing x:TypeArguments\n\n\nGenerates an x:TypeArguments attribute, resolving the potential argument types if possible.\n\n\nCreate Xml Namespace For Symbol\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.create_xml_namespace\n\n\nFixes Code Issue:\n \nXaml Node Resolves\n\n\nThe Create Xml Namespace For Symbol let's you import a new XML namespace for a XAML symbol.\n\n\nEncapsulate Content Page Children With Grid\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.encapsulate_content_page_children_with_grid\n\n\nFixes Code Issue:\n \nContentPage Has Multiple Direct Children\n\n\nWhen a content page has multiple direct children, this fix merges them into a stacklayou.\n\n\nUses:\n\n\n\n\nGenerate Grid\n\n\n\n\nEncapsulate Content Page Children With StackLayout\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.encapsulate_content_page_children_with_stack_layout\n\n\nFixes Code Issue:\n \nContentPage Has Multiple Direct Children\n\n\nWhen a content page has multiple direct children, this fix merges them into a grid.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultOrientation\n\n\nSystem.String\n\n\n\n\nWhat is the default orientation for the \nStackLayout\n that is created for this fix? If empty, an \nOrientation\n attribute is not inserted.\n\n\n\n\n\n\n\n\nEncapsulate Content View Children With Grid\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.encapsulate_content_view_children_with_grid\n\n\nFixes Code Issue:\n \nContentView Has Multiple Direct Children\n\n\nWhen a content view has multiple direct children, this fix merges them into a grid.\n\n\nUses:\n\n\n\n\nGenerate Grid\n\n\n\n\nEncapsulate Content View Children With StackLayout\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.encapsulate_content_view_children_with_stack_layout\n\n\nFixes Code Issue:\n \nContentView Has Multiple Direct Children\n\n\nWhen a content view has multiple direct children, this fix merges them into a stack layout.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultOrientation\n\n\nSystem.String\n\n\n\n\nWhat is the default orientation for the \nStackLayout\n that is created for this fix? If empty, an \nOrientation\n attribute is not inserted.\n\n\n\n\n\n\n\n\nEncapsulate Scroll View Children With Grid\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.encapsulate_scroll_view_children_with_grid\n\n\nFixes Code Issue:\n \nScrollView Has Multiple Direct Children\n\n\nWhen a scroll view has multiple direct children, this fix merges them into a grid.\n\n\nUses:\n\n\n\n\nGenerate Grid\n\n\n\n\nEncapsulate Scroll View Children With StackLayout\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.encapsulate_scroll_view_children_with_stack_layout\n\n\nFixes Code Issue:\n \nScrollView Has Multiple Direct Children\n\n\nWhen a scroll view has multiple direct children, this fix merges them into a stack layout.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultOrientation\n\n\nSystem.String\n\n\n\n\nWhat is the default orientation for the \nStackLayout\n that is created for this fix? If empty, an \nOrientation\n attribute is not inserted.\n\n\n\n\n\n\n\n\nGenerate .NET View From XAML Node\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_missing_class_as_csharp_view\n\n\nFixes Code Issue:\n \nXaml Node Resolves\n\n\nWhen a Xaml node cannot be resolved, this fix will create a new view declared in C#.\n\n\nUses:\n\n\n\n\nCreate Class Declaration\n\n\nUsing Directive Generator\n\n\nNamespace Declaration\n\n\n\n\nGenerate Binding Expression Property\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_binding_property\n\n\nFixes Code Issue:\n \nBinding Expressions Resolve\n\n\nGenerates the missing property binding onto the binding context for this \n\n\nUses:\n\n\n\n\nView Model Property Generator\n\n\n\n\nGenerate Class From XAML Node\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_missing_class\n\n\nFixes Code Issue:\n \nXaml Node Resolves\n\n\nWhen a Xaml node cannot be resolved, this fix will create a new implementation of that class.\n\n\nUses:\n\n\n\n\nUsing Directive Generator\n\n\nCreate Class Declaration\n\n\nNamespace Declaration\n\n\n\n\nGenerate Class From XAML Symbol\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_csharp_class\n\n\nFixes Code Issue:\n \nUnresolved .NET Symbols Within Xaml Expression\n\n\nWhen a c# symbol reference expression does not resolve, this fix generates an implementation for the missing class.\n\n\nUses:\n\n\n\n\nUsing Directive Generator\n\n\nCreate Class Declaration\n\n\nNamespace Declaration\n\n\n\n\nGenerate Class With Static Property\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_class_and_member\n\n\nFixes Code Issue:\n \nUnresolved .NET Symbols Within Xaml Expression\n\n\n\n\nWhen a c# symbol referenced by an \nx:Static\n expression does not resolve, this fix generates a stub class declaration with a default, readonly static member.\n\n\nConsider the following code:\n\n\nMainPage.xaml\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nContentPage xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n    xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n    x:Class=\nMyApp.MainPage\n\n    xmlns:local=\nclr-namespace:MyApp\n\n    \nLabel\n        TextColor=\n{x:Static local:AppSettings.TextColor}\n\n        Text=\nHello Xamarin.Forms!\n/\n\n\n/ContentPage\n\n\n\n\n\nIn the above example, the expression \n{x:Static local:AppSettings.TextColor}\n points to a class (\nAppSettings\n) and member (\nTextColor\n) that do not exist in the \nMyApp\n namespace in the current project.\n\n\nGenerate Event Handler\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_event_handler\n\n\nFixes Code Issue:\n \nEvent Handler Exists In Code Behind Class\n\n\n\n\nWhen an event handler Xaml attribute references a method that does not exist on the code behind class, the \nGenerate Missing Event Handler\n code fix will generate a method on the code behind class.\n\n\nConsider the following code:\n\n\nView: MainPage.xaml\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nContentPage xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n    xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n    x:Class=\nMyApp.MainPage\n\n    \nButton Clicked=\nOnButtonClicked\n/\n\n\n/ContentPage\n\n\n\n\n\nCode Behind: MainPage.xaml.cs\n\n\npublic partial class MainPage : ContentPage\n{\n    public LoginPage()\n    {\n        InitializeComponent();\n    }\n}\n\n\n\n\nThe referenced method \nOnButtonClicked\n does not exist in the views code behind class, \nMainPage\n. The corresponding \nanalyser\n will detect this issue and annotate it in your source code.\n\n\nFrom here, we can action the code fix to generate a method stub in \nMainPage.xaml.cs\n:\n\n\nUses:\n\n\n\n\nGenerate Event Handler Method\n\n\n\n\nGenerate Missing Binding Command Stub\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_binding_command_stub\n\n\nFixes Code Issue:\n \nBinding Expressions Resolve\n\n\nWhen the symbol referenced inside a binding expression is unresolved, this fix can generates an ICommand implementation onto the views BindingContext\n\n\nUses:\n\n\n\n\nGenerate ICommand Implementation\n\n\n\n\nGenerate Property\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_csharp_member\n\n\nFixes Code Issue:\n \nUnresolved .NET Symbols Within Xaml Expression\n\n\nGenerate a static or constant variable onto the targetted class\n\n\nGenerate Resource Dictionary Key\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.missing_resource_key\n\n\nFixes Code Issue:\n \nResource Entry Does Not Define Key\n\n\nWhen a Xaml node that is declared within a \nResourceDictionary\n is missing the \nx:Key\n attribute, this fix will automatically create a new \nx:Key\n attribute for the node.\n\n\nGenerate Value Converter From XAML Node\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_missing_class_as_value_converter\n\n\nFixes Code Issue:\n \nXaml Node Resolves\n\n\nWhen a Xaml node cannot be resolved and it ends with '[cC]onverter', this fix will create a new implemenation of IValueConverter.\n\n\nUses:\n\n\n\n\nGenerate IValueConverter Implementation\n\n\n\n\nGenerate XAML View From XAML Node\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.generate_missing_class_as_xaml_view\n\n\nFixes Code Issue:\n \nXaml Node Resolves\n\n\n\n\nWhen a Xaml node cannot be resolved, this fix will create a new view that uses XAML and a code-behind class.\n\n\nUses:\n\n\n\n\nGenerate View With XAML and Code-Behind Class\n\n\nCustom Controls Configuration\n\n\n\n\nImport Missing Image Resource\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.import_missing_image_resource\n\n\nFixes Code Issue:\n \nDetect Missing Image In Linked Projects\n\n\n\n\nThis code fix will open the \nImage Wizard\n from a missing image reference, allowing you to quickly import a new image resource into all projects that are missing that image resource.\n\n\nImport Namespace And Assembly For Unresolved Expression Symbol\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.resolve_expression_csharp_symbol\n\n\nFixes Code Issue:\n \nUnresolved Namespace Within Xaml Expression\n\n\nWhen the namespace inside c# symbol reference expression can be resolved to a .NET symbol in the project or its references this fix generates an 'xmlns' import statement in the root xaml element.\n\n\nImport Namespace And Assembly For Unresolved XAML Node\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.import_reference\n\n\nFixes Code Issue:\n \nUnresolved Xml Namespace\n\n\n\n\nWhen building XAML documents, developers frequently use 3rd party or custom controls to build great UIs for their app.\n\n\nThis comes with one little quirk, each time a custom control is used in XAML, the .NET namespace and assembly needs to be imported as a custom XAML namespace.\n\n\nFor example, consider we wanted to use FFImageLoadings \nCachedImage\n control like so:\n\n\n    \nffimage:CachedImage/\n\n\n\n\n\nThis control lives inside the \nFFImageLoading.Forms\n namespace in the \nFFImageLoading.Forms\n assembly. To include this control into our XAML, we need to add the following code into the root XAML node:\n\n\nxmlns:ffimage=\nclr-namespace:FFImageLoading.Forms;assembly=FFImageLoading.Forms\n\n\n\n\n\nThere's a few issues with this workflow:\n\n\n\n\nRemembering the \nclr-namespace: ... ;assembly= ...\n syntax is hard!\n\n\nRemembering what namespace and assembly a control is in is hard!\n\n\n\n\nTherefore the \nImport Namespace And Assembly For Unresolved XAML Node\n code fix is very useful because it resolves these for you!\n\n\nThe code action will search all assemblies that the project references for classes that match the name of the XAML node. It will then suggest the creation of an \nxmlns=...\n import statement to resovle that missing class:\n\n\nBefore\n\n \n?xml version=\"1.0\" encoding=\"utf-8\"?\n\n\nContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n    x:Class=\"MyXamarinFormsApp.MainPage\" \n\n    \nffimage:CachedImage/\n \n-- The ffimage namespace doesn't exist!\n\n/ContentPage\n\n\nAfter\n\n \n?xml version=\"1.0\" encoding=\"utf-8\"?\n\n\nContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n    x:Class=\"MyXamarinFormsApp.MainPage\"\n    xmlns:ffimage=\"clr-namespace:FFImageLoading.Forms;assembly=FFImageLoading.Forms\" \n \n-- The ffimage is now resolved\n    \nffimage:CachedImage/\n\n\n/ContentPage\n\n\nImport Value Converter For Binding Type Flow\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.import_resolving_value_converter\n\n\nFixes Code Issue:\n \nBinding Expression Return Type Mismatch\n\n\nInspects for IValueConverter implementations within the project and it's references that match the value conversion flow for this binding type mismatch. IValueConverter implementations must be annotated with the \nValueConversionAttribute\n to be detected by this fix.\n\n\nRemove Unused XML Namespace\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.xml_namespace_is_unused\n\n\nFixes Code Issue:\n \nUnused Xml Namespace\n\n\nRemoves the unused xmlns declaration from the root XAML element\n\n\nRename Duplicate Namespace References\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.multiple_namespace_assembly_references\n\n\nFixes Code Issue:\n \nDuplicate Namespace Declaration\n\n\nWhen multiple namespaces reference the same .NET namespace and assembly, this code fix will remove duplicates by replace all occurances of a particular namespace another namespace name to make sure only one XML namespace references an assembly and namespace.\n\n\nUses:\n\n\n\n\nRename Xaml Namespace Generator\n\n\n\n\nReplace Field Or Method Reference With Property\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.binding_expression_does_not_return_property\n\n\nFixes Code Issue:\n \nValidate Binding Expressions Return A Property\n\n\nReplaces a field or method symbol within a binding expression with a suggested property name.\n\n\nReplace Node With Auto-Correction\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.autocorrect_unresolved_reference\n\n\nFixes Code Issue:\n \nXaml Node Resolves\n\n\nThis fix action replaces a mispelt xaml node that can be resolved in an assembly with its correct .NET symbol name.\n\n\nReplace Style Setter Property With Autocorrection\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.style_property_setter_does_not_exist\n\n\nFixes Code Issue:\n \nProperty Setter Does Not Exist In Style TargetType\n\n\nWhen a style setter tries to use a property that doesn't exist on the styles \nTargetType\n but the name closely matches an existing member on that type, this code fix will replace the incorrect value with a suggested correction.\n\n\nReplace Unknown Property Value With Autocorrection\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.unknown_static_property_value\n\n\nFixes Code Issue:\n \nUnknown Static Property Value\n\n\nWhen a xaml element property attempts to reference a static field (for instance LayoutOptions.Center), this fix finds the nearest named member and replaces the incorrect value with an auto-correction.\n\n\nReplace with correct attached property name\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.no_attached_property\n\n\nFixes Code Issue:\n \nClass Does Not Have Attached Property\n\n\nReplaces an incorrect attached property with an auto-corrected value.\n\n\nReplace x:Name Reference With Autocorrection\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.xreference_does_not_exist\n\n\nFixes Code Issue:\n \nReferenced Code Behind Field Exists\n\n\nReplaces an invalid x:Name reference with a similiarly named x:Name declared in the current document.\n\n\nReplace XML Namespace With Autocorrection\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.xaml.xml_namespace_does_not_exist\n\n\nFixes Code Issue:\n \nUnresolved Xml Namespace\n\n\nReplaces an xml namespace prefix with the auto-corrected xml namespace.", 
            "title": "Issue Fixing"
        }, 
        {
            "location": "/code-actions/xaml/fix/#xaml-code-fixes", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "XAML Code Fixes"
        }, 
        {
            "location": "/code-actions/xaml/fix/#add-missing-target-type-attribute", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.style_is_missing_target_type  Fixes Code Issue:   Style Is Missing TargetType  When a style is missing a  TargetType  attribute or property setter node, this fix will insert an empty target type attribute.", 
            "title": "Add Missing Target Type Attribute"
        }, 
        {
            "location": "/code-actions/xaml/fix/#autocorrect-invalid-fontsize", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.autocorrect_invalid_font_size  Fixes Code Issue:   Invalid Named Font Size  When a developer accidentally mispells a named FontSize value, this fix will auto-correct it to a valid font size name.", 
            "title": "Autocorrect Invalid FontSize"
        }, 
        {
            "location": "/code-actions/xaml/fix/#autocorrect-symbol-in-markup-expression", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.autocorrect_csharp_symbol  Fixes Code Issue:   Unresolved .NET Symbols Within Xaml Expression  When a .NET symbol referenced inside a XAML markup extension does not exist but a closely named symbol can be found within the current solution, this code fix will replace the bad symbol reference with a reference the closely named symbol.  This code fix works on both class references and property references.", 
            "title": "Autocorrect Symbol In Markup Expression"
        }, 
        {
            "location": "/code-actions/xaml/fix/#correct-member-name", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.autocorrect_member  Fixes Code Issue:   Referenced Attribute Member Exists In Parent Type  Looks for members on a C# class that are named closely to an unresolved xml attribute and then suggest near matches.", 
            "title": "Correct Member Name"
        }, 
        {
            "location": "/code-actions/xaml/fix/#correct-property-binding-name", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.correct_property_binding_name  Fixes Code Issue:   Binding Expressions Resolve", 
            "title": "Correct Property Binding Name"
        }, 
        {
            "location": "/code-actions/xaml/fix/#create-missing-property-for-class", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.generate_property  Fixes Code Issue:   Referenced Attribute Member Exists In Parent Type  This fix let's you create a public property onto a writable class referenced in your XAML.  For this fix to activate, the following conditions must be fulfilled:   The attribute used on a XAML node does not exist on the .NET class for that node.  The class referenced by the XAML node is within the users source code.   Consider the following code example:  MyCustomControl.cs  public class MyCustomControl : Xamarin.Forms.View\n{\n}  MyPage.xaml  ContentPage xmlns= http://xamarin.com/schemas/2014/forms \n    xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n    x:Class= MyApp.MainPage \n     MyCustomControl OnTappedMessage= The custom control was tapped! /  /ContentPage   The attribute  OnTappedMessage  is attempting to reference a member that does not exist inside  MyCustomControl ; a developer can use this code action to generate that missing member:  MyCustomControl.cs  public class MyCustomControl : Xamarin.Forms.View\n{\n    public string OnTappedMessage { get; set; }\n}  When the class derives from  Xamarin.Forms.View , this code action can be used to generate a bindable property implementation.  The code action will attempt to resolve the new properties type by inspecting the value of the source attribute. If the value is an expression, MFractor will evaluate the expression and use the return type as the new properties type.  If the attributes value isn't an expression, MFractor will attempt to infer type based on the literal input. For example, an attribute value of  true  would trigger MFractor to output a boolean typed property. This behaviour can be disabled by configuring the  TryInferUnknownTypes  to false.", 
            "title": "Create Missing Property For Class"
        }, 
        {
            "location": "/code-actions/xaml/fix/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      TryInferUnknownTypes  Boolean  True  Should MFractor attempt to guess the type for the new property based on it's value? EG: A value of  true  would cause the output type to be  bool  instead of  System.Object .    DefaultColorType  System.String  Xamarin.Forms.Color  When attempting to infer the property type based on its value and MFractor decides it's a color, what is the color type MFractor should use?    DefaultPropertyType  System.String  System.Object  What is the default type for the new property if MFractor can't figure it out based on the attribute value?    DefaultImageType  System.String  Xamarin.Forms.ImageSource  When attempting to infer the property type based on its value and MFractor decides it's an image, what is the CLR type MFractor should use?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses", 
            "text": "Generate Bindable Property  View Model Property Generator  Generate Event Handler Declaration", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#create-value-converter-to-resolve-type-flow", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.create_resolving_value_converter  Fixes Code Issue:   Binding Expression Return Type Mismatch   Using the input and output type for a value conversion path, this code fix creates a new value converter implementation for the input and output type and imports it into the views resource dictionary.", 
            "title": "Create Value Converter To Resolve Type Flow"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_1", 
            "text": "Generate IValueConverter Implementation  Value Conversion Settings", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#create-xtypearguments-attribute", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.create_type_arguments_attribute  Fixes Code Issue:   Generic Usage Is Missing x:TypeArguments  Generates an x:TypeArguments attribute, resolving the potential argument types if possible.", 
            "title": "Create x:TypeArguments Attribute"
        }, 
        {
            "location": "/code-actions/xaml/fix/#create-xml-namespace-for-symbol", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.create_xml_namespace  Fixes Code Issue:   Xaml Node Resolves  The Create Xml Namespace For Symbol let's you import a new XML namespace for a XAML symbol.", 
            "title": "Create Xml Namespace For Symbol"
        }, 
        {
            "location": "/code-actions/xaml/fix/#encapsulate-content-page-children-with-grid", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.encapsulate_content_page_children_with_grid  Fixes Code Issue:   ContentPage Has Multiple Direct Children  When a content page has multiple direct children, this fix merges them into a stacklayou.", 
            "title": "Encapsulate Content Page Children With Grid"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_2", 
            "text": "Generate Grid", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#encapsulate-content-page-children-with-stacklayout", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.encapsulate_content_page_children_with_stack_layout  Fixes Code Issue:   ContentPage Has Multiple Direct Children  When a content page has multiple direct children, this fix merges them into a grid.", 
            "title": "Encapsulate Content Page Children With StackLayout"
        }, 
        {
            "location": "/code-actions/xaml/fix/#configurable-properties_1", 
            "text": "Name  Type  Defaults To  Description      DefaultOrientation  System.String   What is the default orientation for the  StackLayout  that is created for this fix? If empty, an  Orientation  attribute is not inserted.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-actions/xaml/fix/#encapsulate-content-view-children-with-grid", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.encapsulate_content_view_children_with_grid  Fixes Code Issue:   ContentView Has Multiple Direct Children  When a content view has multiple direct children, this fix merges them into a grid.", 
            "title": "Encapsulate Content View Children With Grid"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_3", 
            "text": "Generate Grid", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#encapsulate-content-view-children-with-stacklayout", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.encapsulate_content_view_children_with_stack_layout  Fixes Code Issue:   ContentView Has Multiple Direct Children  When a content view has multiple direct children, this fix merges them into a stack layout.", 
            "title": "Encapsulate Content View Children With StackLayout"
        }, 
        {
            "location": "/code-actions/xaml/fix/#configurable-properties_2", 
            "text": "Name  Type  Defaults To  Description      DefaultOrientation  System.String   What is the default orientation for the  StackLayout  that is created for this fix? If empty, an  Orientation  attribute is not inserted.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-actions/xaml/fix/#encapsulate-scroll-view-children-with-grid", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.encapsulate_scroll_view_children_with_grid  Fixes Code Issue:   ScrollView Has Multiple Direct Children  When a scroll view has multiple direct children, this fix merges them into a grid.", 
            "title": "Encapsulate Scroll View Children With Grid"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_4", 
            "text": "Generate Grid", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#encapsulate-scroll-view-children-with-stacklayout", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.encapsulate_scroll_view_children_with_stack_layout  Fixes Code Issue:   ScrollView Has Multiple Direct Children  When a scroll view has multiple direct children, this fix merges them into a stack layout.", 
            "title": "Encapsulate Scroll View Children With StackLayout"
        }, 
        {
            "location": "/code-actions/xaml/fix/#configurable-properties_3", 
            "text": "Name  Type  Defaults To  Description      DefaultOrientation  System.String   What is the default orientation for the  StackLayout  that is created for this fix? If empty, an  Orientation  attribute is not inserted.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-net-view-from-xaml-node", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.generate_missing_class_as_csharp_view  Fixes Code Issue:   Xaml Node Resolves  When a Xaml node cannot be resolved, this fix will create a new view declared in C#.", 
            "title": "Generate .NET View From XAML Node"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_5", 
            "text": "Create Class Declaration  Using Directive Generator  Namespace Declaration", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-binding-expression-property", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.generate_binding_property  Fixes Code Issue:   Binding Expressions Resolve  Generates the missing property binding onto the binding context for this", 
            "title": "Generate Binding Expression Property"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_6", 
            "text": "View Model Property Generator", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-class-from-xaml-node", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.generate_missing_class  Fixes Code Issue:   Xaml Node Resolves  When a Xaml node cannot be resolved, this fix will create a new implementation of that class.", 
            "title": "Generate Class From XAML Node"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_7", 
            "text": "Using Directive Generator  Create Class Declaration  Namespace Declaration", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-class-from-xaml-symbol", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.generate_csharp_class  Fixes Code Issue:   Unresolved .NET Symbols Within Xaml Expression  When a c# symbol reference expression does not resolve, this fix generates an implementation for the missing class.", 
            "title": "Generate Class From XAML Symbol"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_8", 
            "text": "Using Directive Generator  Create Class Declaration  Namespace Declaration", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-class-with-static-property", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.generate_class_and_member  Fixes Code Issue:   Unresolved .NET Symbols Within Xaml Expression   When a c# symbol referenced by an  x:Static  expression does not resolve, this fix generates a stub class declaration with a default, readonly static member.  Consider the following code:  MainPage.xaml  ?xml version= 1.0  encoding= utf-8 ?  ContentPage xmlns= http://xamarin.com/schemas/2014/forms \n    xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n    x:Class= MyApp.MainPage \n    xmlns:local= clr-namespace:MyApp \n     Label\n        TextColor= {x:Static local:AppSettings.TextColor} \n        Text= Hello Xamarin.Forms! /  /ContentPage   In the above example, the expression  {x:Static local:AppSettings.TextColor}  points to a class ( AppSettings ) and member ( TextColor ) that do not exist in the  MyApp  namespace in the current project.", 
            "title": "Generate Class With Static Property"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-event-handler", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.generate_event_handler  Fixes Code Issue:   Event Handler Exists In Code Behind Class   When an event handler Xaml attribute references a method that does not exist on the code behind class, the  Generate Missing Event Handler  code fix will generate a method on the code behind class.  Consider the following code:  View: MainPage.xaml  ?xml version= 1.0  encoding= utf-8 ?  ContentPage xmlns= http://xamarin.com/schemas/2014/forms \n    xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n    x:Class= MyApp.MainPage \n     Button Clicked= OnButtonClicked /  /ContentPage   Code Behind: MainPage.xaml.cs  public partial class MainPage : ContentPage\n{\n    public LoginPage()\n    {\n        InitializeComponent();\n    }\n}  The referenced method  OnButtonClicked  does not exist in the views code behind class,  MainPage . The corresponding  analyser  will detect this issue and annotate it in your source code.  From here, we can action the code fix to generate a method stub in  MainPage.xaml.cs :", 
            "title": "Generate Event Handler"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_9", 
            "text": "Generate Event Handler Method", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-missing-binding-command-stub", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.generate_binding_command_stub  Fixes Code Issue:   Binding Expressions Resolve  When the symbol referenced inside a binding expression is unresolved, this fix can generates an ICommand implementation onto the views BindingContext", 
            "title": "Generate Missing Binding Command Stub"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_10", 
            "text": "Generate ICommand Implementation", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-property", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.generate_csharp_member  Fixes Code Issue:   Unresolved .NET Symbols Within Xaml Expression  Generate a static or constant variable onto the targetted class", 
            "title": "Generate Property"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-resource-dictionary-key", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.missing_resource_key  Fixes Code Issue:   Resource Entry Does Not Define Key  When a Xaml node that is declared within a  ResourceDictionary  is missing the  x:Key  attribute, this fix will automatically create a new  x:Key  attribute for the node.", 
            "title": "Generate Resource Dictionary Key"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-value-converter-from-xaml-node", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.generate_missing_class_as_value_converter  Fixes Code Issue:   Xaml Node Resolves  When a Xaml node cannot be resolved and it ends with '[cC]onverter', this fix will create a new implemenation of IValueConverter.", 
            "title": "Generate Value Converter From XAML Node"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_11", 
            "text": "Generate IValueConverter Implementation", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#generate-xaml-view-from-xaml-node", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.generate_missing_class_as_xaml_view  Fixes Code Issue:   Xaml Node Resolves   When a Xaml node cannot be resolved, this fix will create a new view that uses XAML and a code-behind class.", 
            "title": "Generate XAML View From XAML Node"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_12", 
            "text": "Generate View With XAML and Code-Behind Class  Custom Controls Configuration", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#import-missing-image-resource", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.import_missing_image_resource  Fixes Code Issue:   Detect Missing Image In Linked Projects   This code fix will open the  Image Wizard  from a missing image reference, allowing you to quickly import a new image resource into all projects that are missing that image resource.", 
            "title": "Import Missing Image Resource"
        }, 
        {
            "location": "/code-actions/xaml/fix/#import-namespace-and-assembly-for-unresolved-expression-symbol", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.resolve_expression_csharp_symbol  Fixes Code Issue:   Unresolved Namespace Within Xaml Expression  When the namespace inside c# symbol reference expression can be resolved to a .NET symbol in the project or its references this fix generates an 'xmlns' import statement in the root xaml element.", 
            "title": "Import Namespace And Assembly For Unresolved Expression Symbol"
        }, 
        {
            "location": "/code-actions/xaml/fix/#import-namespace-and-assembly-for-unresolved-xaml-node", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.import_reference  Fixes Code Issue:   Unresolved Xml Namespace   When building XAML documents, developers frequently use 3rd party or custom controls to build great UIs for their app.  This comes with one little quirk, each time a custom control is used in XAML, the .NET namespace and assembly needs to be imported as a custom XAML namespace.  For example, consider we wanted to use FFImageLoadings  CachedImage  control like so:       ffimage:CachedImage/   This control lives inside the  FFImageLoading.Forms  namespace in the  FFImageLoading.Forms  assembly. To include this control into our XAML, we need to add the following code into the root XAML node:  xmlns:ffimage= clr-namespace:FFImageLoading.Forms;assembly=FFImageLoading.Forms   There's a few issues with this workflow:   Remembering the  clr-namespace: ... ;assembly= ...  syntax is hard!  Remembering what namespace and assembly a control is in is hard!   Therefore the  Import Namespace And Assembly For Unresolved XAML Node  code fix is very useful because it resolves these for you!  The code action will search all assemblies that the project references for classes that match the name of the XAML node. It will then suggest the creation of an  xmlns=...  import statement to resovle that missing class:  Before \n  ?xml version=\"1.0\" encoding=\"utf-8\"?  ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n    x:Class=\"MyXamarinFormsApp.MainPage\"  \n     ffimage:CachedImage/   -- The ffimage namespace doesn't exist! /ContentPage  After \n  ?xml version=\"1.0\" encoding=\"utf-8\"?  ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n    x:Class=\"MyXamarinFormsApp.MainPage\"\n    xmlns:ffimage=\"clr-namespace:FFImageLoading.Forms;assembly=FFImageLoading.Forms\"    -- The ffimage is now resolved\n     ffimage:CachedImage/  /ContentPage", 
            "title": "Import Namespace And Assembly For Unresolved XAML Node"
        }, 
        {
            "location": "/code-actions/xaml/fix/#import-value-converter-for-binding-type-flow", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.import_resolving_value_converter  Fixes Code Issue:   Binding Expression Return Type Mismatch  Inspects for IValueConverter implementations within the project and it's references that match the value conversion flow for this binding type mismatch. IValueConverter implementations must be annotated with the  ValueConversionAttribute  to be detected by this fix.", 
            "title": "Import Value Converter For Binding Type Flow"
        }, 
        {
            "location": "/code-actions/xaml/fix/#remove-unused-xml-namespace", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.xml_namespace_is_unused  Fixes Code Issue:   Unused Xml Namespace  Removes the unused xmlns declaration from the root XAML element", 
            "title": "Remove Unused XML Namespace"
        }, 
        {
            "location": "/code-actions/xaml/fix/#rename-duplicate-namespace-references", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.multiple_namespace_assembly_references  Fixes Code Issue:   Duplicate Namespace Declaration  When multiple namespaces reference the same .NET namespace and assembly, this code fix will remove duplicates by replace all occurances of a particular namespace another namespace name to make sure only one XML namespace references an assembly and namespace.", 
            "title": "Rename Duplicate Namespace References"
        }, 
        {
            "location": "/code-actions/xaml/fix/#uses_13", 
            "text": "Rename Xaml Namespace Generator", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/fix/#replace-field-or-method-reference-with-property", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.binding_expression_does_not_return_property  Fixes Code Issue:   Validate Binding Expressions Return A Property  Replaces a field or method symbol within a binding expression with a suggested property name.", 
            "title": "Replace Field Or Method Reference With Property"
        }, 
        {
            "location": "/code-actions/xaml/fix/#replace-node-with-auto-correction", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.autocorrect_unresolved_reference  Fixes Code Issue:   Xaml Node Resolves  This fix action replaces a mispelt xaml node that can be resolved in an assembly with its correct .NET symbol name.", 
            "title": "Replace Node With Auto-Correction"
        }, 
        {
            "location": "/code-actions/xaml/fix/#replace-style-setter-property-with-autocorrection", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.style_property_setter_does_not_exist  Fixes Code Issue:   Property Setter Does Not Exist In Style TargetType  When a style setter tries to use a property that doesn't exist on the styles  TargetType  but the name closely matches an existing member on that type, this code fix will replace the incorrect value with a suggested correction.", 
            "title": "Replace Style Setter Property With Autocorrection"
        }, 
        {
            "location": "/code-actions/xaml/fix/#replace-unknown-property-value-with-autocorrection", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.unknown_static_property_value  Fixes Code Issue:   Unknown Static Property Value  When a xaml element property attempts to reference a static field (for instance LayoutOptions.Center), this fix finds the nearest named member and replaces the incorrect value with an auto-correction.", 
            "title": "Replace Unknown Property Value With Autocorrection"
        }, 
        {
            "location": "/code-actions/xaml/fix/#replace-with-correct-attached-property-name", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.no_attached_property  Fixes Code Issue:   Class Does Not Have Attached Property  Replaces an incorrect attached property with an auto-corrected value.", 
            "title": "Replace with correct attached property name"
        }, 
        {
            "location": "/code-actions/xaml/fix/#replace-xname-reference-with-autocorrection", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.xreference_does_not_exist  Fixes Code Issue:   Referenced Code Behind Field Exists  Replaces an invalid x:Name reference with a similiarly named x:Name declared in the current document.", 
            "title": "Replace x:Name Reference With Autocorrection"
        }, 
        {
            "location": "/code-actions/xaml/fix/#replace-xml-namespace-with-autocorrection", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.xaml.xml_namespace_does_not_exist  Fixes Code Issue:   Unresolved Xml Namespace  Replaces an xml namespace prefix with the auto-corrected xml namespace.", 
            "title": "Replace XML Namespace With Autocorrection"
        }, 
        {
            "location": "/code-actions/xaml/generate/", 
            "text": "XAML Code Generation\n\n\nAutogenerated by MFractor v3.7.3\n\n\nCreate StaticResource Lookup In Code Behind\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.create_static_resource_lookup_in_code_behind\n\n\nGiven a static resource declaration in a XAML file, this code action creates a lookup function in the files code-behind file.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLookupSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the resource to lookup\ntype\n: The type of the resource to loooup\n\n\npublic $type$ $name$ =\n ($type$)Resources[\"$name$\"];\n\n\nThe default code snippet to use when generating a resource lookup on a VisualElement.\n\n\n\n\n\n\nApplicationLookupSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the resource to lookup\ntype\n: The type of the resource to loooup\n\n\npublic static $type$ $name$ =\n ($type$)Application.Current.Resources[\"$name$\"];\n\n\nThe default code snippet to use when generating a resource lookup on the apps Application class.\n\n\n\n\n\n\n\n\nGenerate Effect From XAML Declaration\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.generate_platform_effect\n\n\n\n\nWhen a Xaml node cannot be resolved and it's name ends with effect, this fix will create a new routing effect and an iOS and Android implemenation in any referenced projects.\n\n\nUses:\n\n\n\n\nGenerate Platform Specific Effect\n\n\n\n\nGenerate Grid Column Definition\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.generate_column_definition\n\n\nAdds a single \nColumnDefinition Width=\\\"*\\\"/\n element to the \nGrid.ColumnDefinitions\n node.\n\n\nUses:\n\n\n\n\nGenerate Grid Column Definition\n\n\n\n\nGenerate Grid ColumnDefinitions\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.generate_grid_column_definitions\n\n\nThis code generation action adds column definition setter to a Xamarin.Forms.Grid Xaml node with a single \nColumnDefinition Width=\\\"*\\\"/\n element; this allows you to quickly setup a boilerplate grid.\nWhen this refactoring is used, the \nGrid\n node will have the following code injected:\n\n\nGrid\n\n\\t\nGrid.ColumnDefinitions\n\n\\t\nColumnDefinition Width=\\\n*\\\n\n\\t\n/Grid.ColumnDefinitions\n\n\n/Grid\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Grid Column Definition\n\n\n\n\nGenerate Grid Row And Column Definitions\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.generate_grid_row_and_column_definitions\n\n\nThis code action inserts a Grid.ColumnDefinitions and Grid.RowDefinitions into a Grid element.\n\n\nUses:\n\n\n\n\nGenerate Grid Row Definition\n\n\nGenerate Grid Column Definition\n\n\n\n\nGenerate Grid Row Definition\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.generate_row_definition\n\n\nAdds a single \nRowDefinition Height=\\\"*\\\"/\n element to the \nGrid.RowDefinitions\n node.\n\n\nUses:\n\n\n\n\nGenerate Grid Row Definition\n\n\n\n\nGenerate Grid RowDefinitions\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.generate_grid_row_definitions\n\n\nThis code generation action adds row definition setter to a Xamarin.Forms.Grid Xaml node with a single \nRowDefinition Height=\"*\"/\n element; this allows you to quickly setup a boilerplate grid.\n\n\nWhen this refactoring is used, the \nGrid\n node will have the following code injected:\n\n\n\n\nGrid\n\n\n    \nGrid.RowDefinitions\n\n\n    \nRowDefinition Height=\n*\n\n\n    \n/Grid.RowDefinitions\n\n\n\n/Grid\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Grid Row Definition\n\n\n\n\nGenerate New Value Converter For Type Flow\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_fixes.code_actions.generate_value_converter_for_type_flow\n\n\nGenerates a value converter to convert the return type of a binding expression into the input type of the property.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultConverterNamespace\n\n\nSystem.String\n\n\nconverters\n\n\nThe namespace name of the xmlns import statement for the newly created value converter\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate IValueConverter Implementation\n\n\n\n\nGenerate New View Model\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.implement_view_model\n\n\n\n\nThe \nImplement View Model\n code action detects when a xaml document has unimplemented bindings, gathers them all and then implements them in bulk into a new or existing view model.\n\n\nConsider the following Xaml code:\n\n\nLoginPage.xaml\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nContentPage xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n    xmlns:local=\nclr-namespace:HelloXamarinForms\n\n    xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n    x:Class=\nHelloXamarinForms.HelloXamarinFormsPage\n\n    \nStackLayout\n\n        \nLabel Text=\n{Binding Message}\n\n            TextColor=\n{Binding Color}\n\n          FontSize=\n{Binding Size}\n/\n\n    \n/StackLayout\n\n\n/ContentPage\n\n\n\n\n\nWhen used, the implement view model code action will gather all missing bindings, resolving the name and type:\n\n\n\n\nText=\"{Binding Message}\"\n: A property named \nMessage\n of type \nstring\n.\n\n\nTextColor=\"{Binding Color}\"\n: A property named \nColor\n of type \nXamarin.Forms.Color\n.\n\n\nFontSize=\"{Binding Size}\"\n: A property named \nMessage\n of type \ndouble\n.\n\n\n\n\nThen it generates the property declarations using those names and types, creates a new class named \nLoginViewModel\n and then writes a new file named \nLoginViewModel.cs\n containing the new class definition.\n\n\nThe generated code would be:\n\n\nusing System;\nnamespace MyApp.ViewModels\n{\n    public class LoginViewModel\n    {\n        public string Message { get; set; }\n        public Xamarin.Forms.Color Color { get; set; }\n        public double Size { get; set; }\n    }\n}\n\n\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBaseClass\n\n\nSystem.String\n\n\nnull\n\n\nThe fully qualified type to use as the base class for the view model. For example, \nMvvmFramework.ViewModels.BaseViewModel\n.\n\n\n\n\n\n\nViewModelsFolder\n\n\nSystem.String\n\n\nViewModels\n\n\nThe folder path relative to the project root to insert the newly created view model class into. For example \nViewModels/Cells\n.\n\n\n\n\n\n\nViewModelSuffix\n\n\nSystem.String\n\n\nViewModel\n\n\nThe suffix to append to the end of the newly created view model. For example, setting this to \nPageModel\n would cause a page named \nMainPage\n to create a view model named \nMainPageModel\n.\n\n\n\n\n\n\nShouldPlaceViewModelWithView\n\n\nBoolean\n\n\nFalse\n\n\nWhen generating the new ViewModel, should it be placed in the same folder and namespace as the XAML view that is creating it? Setting this property to true will cause the ViewModelNamespace and ViewModelsFolderproperties to be ignored.\n\n\n\n\n\n\nViewModelNamespace\n\n\nSystem.String\n\n\nnull\n\n\nWhat is the default namespace that view models be included into? Use a '.' before the namespace to signify to MFractor that the new namespace is relative to the projects default namespace. If unset, the default project namespace is used.\n\n\n\n\n\n\nShouldRemoveXamlViewSuffix\n\n\nBoolean\n\n\nTrue\n\n\nShould MFractor remove the 'Page' or 'View' suffix from the view name before creating generating the new view model? Consider the view 'MainPage' with ViewModelSuffix set to 'ViewModel'; if set as true, the new view model would be named 'MainViewModel'. If false, the new view model would be named 'MainPageViewModel'\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate ICommand Implementation\n\n\nUsing Directive Generator\n\n\nCreate Class Declaration\n\n\nNamespace Declaration\n\n\nView Model Property Generator\n\n\nMVVM Resolution Settings\n\n\n\n\nGenerate Resource Dictionary\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.generate_resource_dictionary\n\n\n\n\nThe \nGenerate Resource Dictionary\n code action adds a \nMyView.ResourceDictionary\n property with a nested resource dictionary to any Xaml node that derives from \nXamarin.Forms.VisualElement\n or is the root application class. Developers can quickly add a resource dictionary in just a few keystrokes; this is especially useful when you need to add a resource dictionary to the root xaml node on a control or page.\n\n\nGenerate Xaml Localisation Infrastructure\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.generate_xaml_localisation_infrastructure\n\n\n\n\nBuilds the necessary infrustructure needed for XAML localisation using the best practice outlined in \nLocalizing Xamarin.Forms Apps with RESX Resource Files\n.\n\n\nThis code action will create the following:\n\n\nMyApp.Core\n\n\n\n\ni18n/TranslateExtension.cs\n: The markup extension that provides the translation values.\n\n\ni18n/ILocalise.cs\n: The interface that provides the current culture on each platform.\n\n\n\n\nMyApp.iOS\n\n - \nLocalize.cs\n: The iOS implementation of \nILocalise\n to provide iOS's current culture.\n\n\nMyApp.Android\n\n - \nLocalize.cs\n: The Android implementation of \nILocalise\n to provide iOS's current culture.\n\n\nBefore creating the localisation infrastructure, MFractor will confirm that you wish to proceed. This action generates a lot of code and can potentially overwrite existing code.\n\n\nAfter creating the localisation infrastructure, MFractor will launch the localization wizard so that you can start localizing the current XAML document.\n\n\nUses:\n\n\n\n\nXAML Localisation Infrastructure Generation\n\n\nString Localisation Generator\n\n\n\n\nImplement Missing Members\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.implement_missing_members\n\n\n\n\nWhen a control uses undefined members/properties in a Xaml view, this refactoring collects all missing properties, attempts to resolve their types and then generates them onto the control/class.\n\n\nThe following \nmust\n be satisfied for this refactoring to trigger:\n\n\n\n\nOne or more undefined members/properties must be in use.\n\n\nThe referenced class must exist.\n\n\nThe referenced class must be writeable; aka it must be in the users source code.\n\n\nWhen the referenced class derives from \nXamarin.Forms.BindableObject\n, this refactoring will allow the generation of bindable properties.\n\n\n\n\nLet's examine the following code:\n\n\nMyCustomSlider.cs\n\n\n\npublic class MyCustomSlider : Xamarin.Forms.Slider\n{\n}\n\n\n\n\n\nMyXamlView.xaml\n\n\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nContentPage xmlns=\nhttp://xamarin.com/schemas/2014/forms\n\n    xmlns:local=\nclr-namespace:HelloMFractor\n\n    xmlns:x=\nhttp://schemas.microsoft.com/winfx/2009/xaml\n\n    \nlocal:MyCustomSlider \n        MinRangeColor=\n{Binding MinColor}\n\n    x:Class=\nHelloMFractor.HelloMFractorPage\n\n        MaxRangeColor=\n{Binding MaxColor}\n/\n\n\n/ContentPage\n\n\n\n\n\n\n\nWhen \nImplement Missing Members\n is actioned MFractor can generate the members/properties as plain old properties (EG: \nget; set;\n) or as a bindable property implementation.\n\n\nFor example, when actioned to generate bindable properties, \nMyCustomSlider\n would become:\n\n\n\npublic class MyCustomSlider : Slider\n{\n    public static readonly BindableProperty MaxRangeColorProperty = BindableProperty.Create(nameof(MaxRangeColor), typeof(Color), typeof(HelloMFractor.MyCustomSlider), default(Color));\n    public Color MaxRangeColor\n    {\n        get\n        {\n            return (Xamarin.Forms.Color)GetValue(MaxRangeColorProperty);\n        }\n\n        set\n        {\n            SetValue(MaxRangeColorProperty, value);\n        }\n    }\n\n    public static readonly BindableProperty MinRangeColorProperty = BindableProperty.Create(nameof(MinRangeColor), typeof(object), typeof(HelloMFractor.MyCustomSlider), default(Color));\n    public Color MinRangeColor\n    {\n        get\n        {\n            return (Xamarin.Forms.Color)GetValue(MinRangeColorProperty);\n        }\n\n        set\n        {\n            SetValue(MinRangeColorProperty, value);\n        }\n    }\n}\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Event Handler Declaration\n\n\nCreate Missing Property For Class", 
            "title": "Code Generation"
        }, 
        {
            "location": "/code-actions/xaml/generate/#xaml-code-generation", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "XAML Code Generation"
        }, 
        {
            "location": "/code-actions/xaml/generate/#create-staticresource-lookup-in-code-behind", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.create_static_resource_lookup_in_code_behind  Given a static resource declaration in a XAML file, this code action creates a lookup function in the files code-behind file.", 
            "title": "Create StaticResource Lookup In Code Behind"
        }, 
        {
            "location": "/code-actions/xaml/generate/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      LookupSnippet  Code Snippet Arguments : name : The name of the resource to lookup type : The type of the resource to loooup  public $type$ $name$ =  ($type$)Resources[\"$name$\"];  The default code snippet to use when generating a resource lookup on a VisualElement.    ApplicationLookupSnippet  Code Snippet Arguments : name : The name of the resource to lookup type : The type of the resource to loooup  public static $type$ $name$ =  ($type$)Application.Current.Resources[\"$name$\"];  The default code snippet to use when generating a resource lookup on the apps Application class.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-actions/xaml/generate/#generate-effect-from-xaml-declaration", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.generate_platform_effect   When a Xaml node cannot be resolved and it's name ends with effect, this fix will create a new routing effect and an iOS and Android implemenation in any referenced projects.", 
            "title": "Generate Effect From XAML Declaration"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses", 
            "text": "Generate Platform Specific Effect", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/generate/#generate-grid-column-definition", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.generate_column_definition  Adds a single  ColumnDefinition Width=\\\"*\\\"/  element to the  Grid.ColumnDefinitions  node.", 
            "title": "Generate Grid Column Definition"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses_1", 
            "text": "Generate Grid Column Definition", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/generate/#generate-grid-columndefinitions", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.generate_grid_column_definitions  This code generation action adds column definition setter to a Xamarin.Forms.Grid Xaml node with a single  ColumnDefinition Width=\\\"*\\\"/  element; this allows you to quickly setup a boilerplate grid.\nWhen this refactoring is used, the  Grid  node will have the following code injected:  Grid \n\\t Grid.ColumnDefinitions \n\\t ColumnDefinition Width=\\ *\\ \n\\t /Grid.ColumnDefinitions  /Grid", 
            "title": "Generate Grid ColumnDefinitions"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses_2", 
            "text": "Generate Grid Column Definition", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/generate/#generate-grid-row-and-column-definitions", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.generate_grid_row_and_column_definitions  This code action inserts a Grid.ColumnDefinitions and Grid.RowDefinitions into a Grid element.", 
            "title": "Generate Grid Row And Column Definitions"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses_3", 
            "text": "Generate Grid Row Definition  Generate Grid Column Definition", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/generate/#generate-grid-row-definition", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.generate_row_definition  Adds a single  RowDefinition Height=\\\"*\\\"/  element to the  Grid.RowDefinitions  node.", 
            "title": "Generate Grid Row Definition"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses_4", 
            "text": "Generate Grid Row Definition", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/generate/#generate-grid-rowdefinitions", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.generate_grid_row_definitions  This code generation action adds row definition setter to a Xamarin.Forms.Grid Xaml node with a single  RowDefinition Height=\"*\"/  element; this allows you to quickly setup a boilerplate grid.  When this refactoring is used, the  Grid  node will have the following code injected:   Grid \n\n     Grid.RowDefinitions \n\n     RowDefinition Height= * \n\n     /Grid.RowDefinitions  /Grid", 
            "title": "Generate Grid RowDefinitions"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses_5", 
            "text": "Generate Grid Row Definition", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/generate/#generate-new-value-converter-for-type-flow", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_fixes.code_actions.generate_value_converter_for_type_flow  Generates a value converter to convert the return type of a binding expression into the input type of the property.", 
            "title": "Generate New Value Converter For Type Flow"
        }, 
        {
            "location": "/code-actions/xaml/generate/#configurable-properties_1", 
            "text": "Name  Type  Defaults To  Description      DefaultConverterNamespace  System.String  converters  The namespace name of the xmlns import statement for the newly created value converter", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses_6", 
            "text": "Generate IValueConverter Implementation", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/generate/#generate-new-view-model", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.implement_view_model   The  Implement View Model  code action detects when a xaml document has unimplemented bindings, gathers them all and then implements them in bulk into a new or existing view model.  Consider the following Xaml code:  LoginPage.xaml  ?xml version= 1.0  encoding= utf-8 ?  ContentPage xmlns= http://xamarin.com/schemas/2014/forms \n    xmlns:local= clr-namespace:HelloXamarinForms \n    xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n    x:Class= HelloXamarinForms.HelloXamarinFormsPage \n     StackLayout \n         Label Text= {Binding Message} \n            TextColor= {Binding Color} \n          FontSize= {Binding Size} / \n     /StackLayout  /ContentPage   When used, the implement view model code action will gather all missing bindings, resolving the name and type:   Text=\"{Binding Message}\" : A property named  Message  of type  string .  TextColor=\"{Binding Color}\" : A property named  Color  of type  Xamarin.Forms.Color .  FontSize=\"{Binding Size}\" : A property named  Message  of type  double .   Then it generates the property declarations using those names and types, creates a new class named  LoginViewModel  and then writes a new file named  LoginViewModel.cs  containing the new class definition.  The generated code would be:  using System;\nnamespace MyApp.ViewModels\n{\n    public class LoginViewModel\n    {\n        public string Message { get; set; }\n        public Xamarin.Forms.Color Color { get; set; }\n        public double Size { get; set; }\n    }\n}", 
            "title": "Generate New View Model"
        }, 
        {
            "location": "/code-actions/xaml/generate/#configurable-properties_2", 
            "text": "Name  Type  Defaults To  Description      BaseClass  System.String  null  The fully qualified type to use as the base class for the view model. For example,  MvvmFramework.ViewModels.BaseViewModel .    ViewModelsFolder  System.String  ViewModels  The folder path relative to the project root to insert the newly created view model class into. For example  ViewModels/Cells .    ViewModelSuffix  System.String  ViewModel  The suffix to append to the end of the newly created view model. For example, setting this to  PageModel  would cause a page named  MainPage  to create a view model named  MainPageModel .    ShouldPlaceViewModelWithView  Boolean  False  When generating the new ViewModel, should it be placed in the same folder and namespace as the XAML view that is creating it? Setting this property to true will cause the ViewModelNamespace and ViewModelsFolderproperties to be ignored.    ViewModelNamespace  System.String  null  What is the default namespace that view models be included into? Use a '.' before the namespace to signify to MFractor that the new namespace is relative to the projects default namespace. If unset, the default project namespace is used.    ShouldRemoveXamlViewSuffix  Boolean  True  Should MFractor remove the 'Page' or 'View' suffix from the view name before creating generating the new view model? Consider the view 'MainPage' with ViewModelSuffix set to 'ViewModel'; if set as true, the new view model would be named 'MainViewModel'. If false, the new view model would be named 'MainPageViewModel'", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses_7", 
            "text": "Generate ICommand Implementation  Using Directive Generator  Create Class Declaration  Namespace Declaration  View Model Property Generator  MVVM Resolution Settings", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/generate/#generate-resource-dictionary", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.generate_resource_dictionary   The  Generate Resource Dictionary  code action adds a  MyView.ResourceDictionary  property with a nested resource dictionary to any Xaml node that derives from  Xamarin.Forms.VisualElement  or is the root application class. Developers can quickly add a resource dictionary in just a few keystrokes; this is especially useful when you need to add a resource dictionary to the root xaml node on a control or page.", 
            "title": "Generate Resource Dictionary"
        }, 
        {
            "location": "/code-actions/xaml/generate/#generate-xaml-localisation-infrastructure", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.generate_xaml_localisation_infrastructure   Builds the necessary infrustructure needed for XAML localisation using the best practice outlined in  Localizing Xamarin.Forms Apps with RESX Resource Files .  This code action will create the following:  MyApp.Core   i18n/TranslateExtension.cs : The markup extension that provides the translation values.  i18n/ILocalise.cs : The interface that provides the current culture on each platform.   MyApp.iOS \n -  Localize.cs : The iOS implementation of  ILocalise  to provide iOS's current culture.  MyApp.Android \n -  Localize.cs : The Android implementation of  ILocalise  to provide iOS's current culture.  Before creating the localisation infrastructure, MFractor will confirm that you wish to proceed. This action generates a lot of code and can potentially overwrite existing code.  After creating the localisation infrastructure, MFractor will launch the localization wizard so that you can start localizing the current XAML document.", 
            "title": "Generate Xaml Localisation Infrastructure"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses_8", 
            "text": "XAML Localisation Infrastructure Generation  String Localisation Generator", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/generate/#implement-missing-members", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.implement_missing_members   When a control uses undefined members/properties in a Xaml view, this refactoring collects all missing properties, attempts to resolve their types and then generates them onto the control/class.  The following  must  be satisfied for this refactoring to trigger:   One or more undefined members/properties must be in use.  The referenced class must exist.  The referenced class must be writeable; aka it must be in the users source code.  When the referenced class derives from  Xamarin.Forms.BindableObject , this refactoring will allow the generation of bindable properties.   Let's examine the following code:  MyCustomSlider.cs  \npublic class MyCustomSlider : Xamarin.Forms.Slider\n{\n}  MyXamlView.xaml   ?xml version= 1.0  encoding= utf-8 ?  ContentPage xmlns= http://xamarin.com/schemas/2014/forms \n    xmlns:local= clr-namespace:HelloMFractor \n    xmlns:x= http://schemas.microsoft.com/winfx/2009/xaml \n     local:MyCustomSlider \n        MinRangeColor= {Binding MinColor} \n    x:Class= HelloMFractor.HelloMFractorPage \n        MaxRangeColor= {Binding MaxColor} /  /ContentPage   When  Implement Missing Members  is actioned MFractor can generate the members/properties as plain old properties (EG:  get; set; ) or as a bindable property implementation.  For example, when actioned to generate bindable properties,  MyCustomSlider  would become:  \npublic class MyCustomSlider : Slider\n{\n    public static readonly BindableProperty MaxRangeColorProperty = BindableProperty.Create(nameof(MaxRangeColor), typeof(Color), typeof(HelloMFractor.MyCustomSlider), default(Color));\n    public Color MaxRangeColor\n    {\n        get\n        {\n            return (Xamarin.Forms.Color)GetValue(MaxRangeColorProperty);\n        }\n\n        set\n        {\n            SetValue(MaxRangeColorProperty, value);\n        }\n    }\n\n    public static readonly BindableProperty MinRangeColorProperty = BindableProperty.Create(nameof(MinRangeColor), typeof(object), typeof(HelloMFractor.MyCustomSlider), default(Color));\n    public Color MinRangeColor\n    {\n        get\n        {\n            return (Xamarin.Forms.Color)GetValue(MinRangeColorProperty);\n        }\n\n        set\n        {\n            SetValue(MinRangeColorProperty, value);\n        }\n    }\n}", 
            "title": "Implement Missing Members"
        }, 
        {
            "location": "/code-actions/xaml/generate/#uses_9", 
            "text": "Generate Event Handler Declaration  Create Missing Property For Class", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/organise/", 
            "text": "XAML Organisation\n\n\nAutogenerated by MFractor v3.7.3\n\n\nRemove Unused Namespaces\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.remove_unused_namespaces\n\n\nWhen a xaml node has unused xml namespace declarations, this code action will remove all unused namespaces.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nShouldSort\n\n\nBoolean\n\n\nTrue\n\n\nIf the attributes for this node should be sorted when the unused namespaces are removed\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nSort Attributes", 
            "title": "Xaml Organisation"
        }, 
        {
            "location": "/code-actions/xaml/organise/#xaml-organisation", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "XAML Organisation"
        }, 
        {
            "location": "/code-actions/xaml/organise/#remove-unused-namespaces", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.remove_unused_namespaces  When a xaml node has unused xml namespace declarations, this code action will remove all unused namespaces.", 
            "title": "Remove Unused Namespaces"
        }, 
        {
            "location": "/code-actions/xaml/organise/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      ShouldSort  Boolean  True  If the attributes for this node should be sorted when the unused namespaces are removed", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-actions/xaml/organise/#uses", 
            "text": "Sort Attributes", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/refactor/", 
            "text": "XAML Refactoring\n\n\nAutogenerated by MFractor v3.7.3\n\n\nAdd Transparency Channel To Color\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.add_transparency_to_color\n\n\nGiven a color literal defined by a hex value, this code action adds a transparency channel to that color.\n\n\nConvert Named Color To Hexadecimal\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.convert_named_color_to_hexadecimal\n\n\nGiven a color that is defined by a named color literal (such as Red, Green etc), this code action converts that \n\n\nConvert StackLayout To Grid\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.convert_stacklayout_to_grid\n\n\n\n\nGiven a StackLayout in XAML, this code action converts it to a vertically or horizontally aligned grid.\n\n\nUses:\n\n\n\n\nGenerate Grid Column Definition\n\n\nGenerate Grid Row Definition\n\n\nRename XAML Node\n\n\n\n\nEdit Color Declaration\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.edit_color\n\n\n\n\nThe \nEdit Color Declaration\n code actions allows visual editing of colors from your Xaml.\n\n\nSimply right click on a Xaml node that is a \nSystem.Drawing.Color\n or \nXamarin.Forms.Color\n and select \nEdit Color\n. Then you can use the color picker dialog to select a new color value:\n\n\nExtract Attribute Value Into Property Binding\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.extract_into_property_binding\n\n\n\n\nWhen a Xaml attribute is initialised by a literal value (rather than an expression), this refactoring action allows a developer to extract that literal value as a property into the binding context and replace the attribute initialiser with a binding expression.\n\n\nFor example, given the attribute initialiser \nText=\\\"Hello Xamarin.Forms!\\\"\n, this refactoring would generate a user named property (EG: Message) in the binding context, initiliase it with the string literal \n\\\"Message\\\"\n and replace the attribute value with the binding expresion \n{Binding Message}\n.\";\n\n\nUses:\n\n\n\n\nView Model Property Generator\n\n\n\n\nExtract Resource Dictionary\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.extract_resource_dictionary\n\n\n\n\nExtracts the current resource dictionary into it's own XAML file with code behind.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultXamlNamespace\n\n\nSystem.String\n\n\nresources\n\n\nWhat is the default name of the XAML namespace for the new control?\n\n\n\n\n\n\nDefaultResourcesFolder\n\n\nSystem.String\n\n\nResource Dictionaries\n\n\nWhat is the default folder that the new  of the C# namespace for the new resource? If empty, the projects default namespace will be used.\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate View With XAML and Code-Behind Class\n\n\n\n\nExtract XAML Into Control\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.extract_xaml_into_control\n\n\n\n\nExtracts a XAML layout container that derives from \nXamarin.Forms.Layout\n into a new XAML control.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultXamlNamespace\n\n\nSystem.String\n\n\ncontrols\n\n\nWhat is the default name of the XAML namespace for the new control?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate View With XAML and Code-Behind Class\n\n\nCustom Controls Configuration\n\n\n\n\nFix Node Closing Tag And Children\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.refactor.fix_node_closing_tag_and_childrem\n\n\n\n\nOften when we are refactoring XAML code we will change the type of a XAML node. When we do this, we end up with the start and end tags being different. This code action let's you correct the end tag and property setters so that they match the opening tag.\n\n\nUses:\n\n\n\n\nRename XAML Node\n\n\n\n\nMigrate OnPlatform Usage\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.migrate_on_platform_usage\n\n\n\n\nIn Xamarin.Forms 2.3.4, there were changes made to the \nOnPlatform\n class to enable greater platform-specifics flexibility in the future. These changes deprecated the \nOnPlatform.iOS\n, \nOnPlatform.Android\n and \nOnPlatform.WinPhone\n properties in favour of a generic \nOn\n element to control the platform specifics.\n\n\nThe \nMigrate OnPlatform Usage\n code action is a refactoring that converts a pre-2.3.4 Xamarin.Forms \nOnPlatform\n usage to the new methodology using the nested \nOn\n element.\n\n\nFor example, given the following \nOnPlatform\n:\n\n\nOnPlatform x:TypeArguments=\nThickness\n \n            Android=\n0, 0, 0, 0\n \n            iOS=\n0, 20, 0, 0\n\n    \nOnPlatform.WinPhone\n\n        0, 0, 0, 0\n    \n/OnPlatform.WinPhone\n\n\n/OnPlatform\n\n\n\n\n\nMFractor would migrate the code to use the \nOn\n element:\n\n\nOnPlatform x:TypeArguments=\nThickness\n\n    \nOn Platform=\nAndroid\n0, 0, 0, 0\n/On\n\n    \nOn Platform=\niOS\n0, 20, 0, 0\n/On\n\n    \nOn Platform=\nWinPhone\n0, 0, 0, 0\n/On\n\n\n/OnPlatform\n\n\n\n\n\nRename Xaml Namespace\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.rename_xaml_namespace\n\n\n\n\nThe \nRename Xaml Namespace\n code action will perform a symbolic rename-refactor on a particular Xaml within your document.\n\n\nThis is handy as you can then rename namespaces in a document without using a Find+Replace action; the rename xaml namespace action works against symbols so it will always rename only the namespace symbols.\n\n\nTo action this refactoring:\n\n\n\n\nWithin a Xaml document right click or \nAlt+Return\n on an \nxmlns\n attribute (EG: \nxmlns:local=\"clr-namespace:myApp\"\n)\n\n\nSelect \nRefactor\n.\n\n\nThen \nRename Namespace\n.\n\n\nEnter a new namespace name when prompted and then click enter.\n\n\n\n\nYour new namespace will be applied across the document:\n\n\n\n\nUses:\n\n\n\n\nRename Xaml Namespace Generator\n\n\n\n\nReplace String With Localisation Lookup\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xaml.replace_with_localisation_lookup\n\n\n\n\nThis refactoring action will open the document localisation wizard, a dialog that walks through all strings in the current document and lets you easily replace them with a localised value lookup.\n\n\nWhen localising XAML files, MFractor assumes you are adhering to the best practices as outlined in \nLocalizing Xamarin.Forms Apps with RESX Resource Files\n.\n\n\nUses:\n\n\n\n\nString Localisation Generator", 
            "title": "Refactoring"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#xaml-refactoring", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "XAML Refactoring"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#add-transparency-channel-to-color", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.add_transparency_to_color  Given a color literal defined by a hex value, this code action adds a transparency channel to that color.", 
            "title": "Add Transparency Channel To Color"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#convert-named-color-to-hexadecimal", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.convert_named_color_to_hexadecimal  Given a color that is defined by a named color literal (such as Red, Green etc), this code action converts that", 
            "title": "Convert Named Color To Hexadecimal"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#convert-stacklayout-to-grid", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.convert_stacklayout_to_grid   Given a StackLayout in XAML, this code action converts it to a vertically or horizontally aligned grid.", 
            "title": "Convert StackLayout To Grid"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#uses", 
            "text": "Generate Grid Column Definition  Generate Grid Row Definition  Rename XAML Node", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#edit-color-declaration", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.edit_color   The  Edit Color Declaration  code actions allows visual editing of colors from your Xaml.  Simply right click on a Xaml node that is a  System.Drawing.Color  or  Xamarin.Forms.Color  and select  Edit Color . Then you can use the color picker dialog to select a new color value:", 
            "title": "Edit Color Declaration"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#extract-attribute-value-into-property-binding", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.extract_into_property_binding   When a Xaml attribute is initialised by a literal value (rather than an expression), this refactoring action allows a developer to extract that literal value as a property into the binding context and replace the attribute initialiser with a binding expression.  For example, given the attribute initialiser  Text=\\\"Hello Xamarin.Forms!\\\" , this refactoring would generate a user named property (EG: Message) in the binding context, initiliase it with the string literal  \\\"Message\\\"  and replace the attribute value with the binding expresion  {Binding Message} .\";", 
            "title": "Extract Attribute Value Into Property Binding"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#uses_1", 
            "text": "View Model Property Generator", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#extract-resource-dictionary", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.extract_resource_dictionary   Extracts the current resource dictionary into it's own XAML file with code behind.", 
            "title": "Extract Resource Dictionary"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      DefaultXamlNamespace  System.String  resources  What is the default name of the XAML namespace for the new control?    DefaultResourcesFolder  System.String  Resource Dictionaries  What is the default folder that the new  of the C# namespace for the new resource? If empty, the projects default namespace will be used.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#uses_2", 
            "text": "Generate View With XAML and Code-Behind Class", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#extract-xaml-into-control", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.extract_xaml_into_control   Extracts a XAML layout container that derives from  Xamarin.Forms.Layout  into a new XAML control.", 
            "title": "Extract XAML Into Control"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#configurable-properties_1", 
            "text": "Name  Type  Defaults To  Description      DefaultXamlNamespace  System.String  controls  What is the default name of the XAML namespace for the new control?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#uses_3", 
            "text": "Generate View With XAML and Code-Behind Class  Custom Controls Configuration", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#fix-node-closing-tag-and-children", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.refactor.fix_node_closing_tag_and_childrem   Often when we are refactoring XAML code we will change the type of a XAML node. When we do this, we end up with the start and end tags being different. This code action let's you correct the end tag and property setters so that they match the opening tag.", 
            "title": "Fix Node Closing Tag And Children"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#uses_4", 
            "text": "Rename XAML Node", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#migrate-onplatform-usage", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.migrate_on_platform_usage   In Xamarin.Forms 2.3.4, there were changes made to the  OnPlatform  class to enable greater platform-specifics flexibility in the future. These changes deprecated the  OnPlatform.iOS ,  OnPlatform.Android  and  OnPlatform.WinPhone  properties in favour of a generic  On  element to control the platform specifics.  The  Migrate OnPlatform Usage  code action is a refactoring that converts a pre-2.3.4 Xamarin.Forms  OnPlatform  usage to the new methodology using the nested  On  element.  For example, given the following  OnPlatform :  OnPlatform x:TypeArguments= Thickness  \n            Android= 0, 0, 0, 0  \n            iOS= 0, 20, 0, 0 \n     OnPlatform.WinPhone \n        0, 0, 0, 0\n     /OnPlatform.WinPhone  /OnPlatform   MFractor would migrate the code to use the  On  element:  OnPlatform x:TypeArguments= Thickness \n     On Platform= Android 0, 0, 0, 0 /On \n     On Platform= iOS 0, 20, 0, 0 /On \n     On Platform= WinPhone 0, 0, 0, 0 /On  /OnPlatform", 
            "title": "Migrate OnPlatform Usage"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#rename-xaml-namespace", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.rename_xaml_namespace   The  Rename Xaml Namespace  code action will perform a symbolic rename-refactor on a particular Xaml within your document.  This is handy as you can then rename namespaces in a document without using a Find+Replace action; the rename xaml namespace action works against symbols so it will always rename only the namespace symbols.  To action this refactoring:   Within a Xaml document right click or  Alt+Return  on an  xmlns  attribute (EG:  xmlns:local=\"clr-namespace:myApp\" )  Select  Refactor .  Then  Rename Namespace .  Enter a new namespace name when prompted and then click enter.   Your new namespace will be applied across the document:", 
            "title": "Rename Xaml Namespace"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#uses_5", 
            "text": "Rename Xaml Namespace Generator", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#replace-string-with-localisation-lookup", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xaml.replace_with_localisation_lookup   This refactoring action will open the document localisation wizard, a dialog that walks through all strings in the current document and lets you easily replace them with a localised value lookup.  When localising XAML files, MFractor assumes you are adhering to the best practices as outlined in  Localizing Xamarin.Forms Apps with RESX Resource Files .", 
            "title": "Replace String With Localisation Lookup"
        }, 
        {
            "location": "/code-actions/xaml/refactor/#uses_6", 
            "text": "String Localisation Generator", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xaml/navigate/", 
            "text": "XAML Navigation\n\n\nAutogenerated by MFractor v3.7.3\n\n\nGo To Code Behind Class\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.navigation.forms.go_to_code_behind\n\n\n\n\nWhen you are in a ViewModel or XAML file, the Go-To Code Behind code action will navigate you to it's code behind class\n\n\nGo To View Model\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.navigation.forms.go_to_view_model\n\n\n\n\nWhen you are in a XAML file or it's code behind, the Go-To ViewModel code action will infer your view model and navigate to it.\n\n\nSupported View Model Suffixes:\n\n\n* ViewModel\n\n* PageModel\n\n* PageViewModel\n\n* Model\n\n* VM\n\n* PageVM\n\n\n\nGo To XAML Symbol\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.navigation.forms.go_to_declaration\n\n\nJumps to the location of XAML symbol in either source code or the assembly browser.\n\n\nGo To XAML View\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.navigation.forms.go_to_view\n\n\n\n\nJumps to the XAML view for a code behind or view model.\n\n\nSupported View Suffixes:\n\n\n* .xaml\n\n* Page.xaml\n\n* View.xaml\n\n* Template.xaml", 
            "title": "Navigation"
        }, 
        {
            "location": "/code-actions/xaml/navigate/#xaml-navigation", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "XAML Navigation"
        }, 
        {
            "location": "/code-actions/xaml/navigate/#go-to-code-behind-class", 
            "text": "Professional Only  Configuration Id: com.mfractor.navigation.forms.go_to_code_behind   When you are in a ViewModel or XAML file, the Go-To Code Behind code action will navigate you to it's code behind class", 
            "title": "Go To Code Behind Class"
        }, 
        {
            "location": "/code-actions/xaml/navigate/#go-to-view-model", 
            "text": "Professional Only  Configuration Id: com.mfractor.navigation.forms.go_to_view_model   When you are in a XAML file or it's code behind, the Go-To ViewModel code action will infer your view model and navigate to it.  Supported View Model Suffixes:  * ViewModel\n\n* PageModel\n\n* PageViewModel\n\n* Model\n\n* VM\n\n* PageVM", 
            "title": "Go To View Model"
        }, 
        {
            "location": "/code-actions/xaml/navigate/#go-to-xaml-symbol", 
            "text": "Professional Only  Configuration Id: com.mfractor.navigation.forms.go_to_declaration  Jumps to the location of XAML symbol in either source code or the assembly browser.", 
            "title": "Go To XAML Symbol"
        }, 
        {
            "location": "/code-actions/xaml/navigate/#go-to-xaml-view", 
            "text": "Professional Only  Configuration Id: com.mfractor.navigation.forms.go_to_view   Jumps to the XAML view for a code behind or view model.  Supported View Suffixes:  * .xaml\n\n* Page.xaml\n\n* View.xaml\n\n* Template.xaml", 
            "title": "Go To XAML View"
        }, 
        {
            "location": "/code-actions/xml/", 
            "text": "XML Code Actions\n\n\nAutogenerated by MFractor v3.7.3\n\n\nCollapse Attributes Onto Same Line\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xml.collapse_attributes_onto_same_line\n\n\nThe \nCollapse Attributes\n code action will fold all attributes onto the same line for the XAML node under the cursor.\n\n\n\n\nCollapse Node\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xml.collapse_node_closing_tag\n\n\nWhen a Xaml node has a closing tag and no children (eg: \nMyNode\n \n/MyNode\n), this refactoring allows the developer to remove the closing tag to make the node self-closing. For example, when applied to the node \nMyNode\n ... \n/MyNode\n, the closing tag \n/MyNode\n is removed and the element becomes self closing like so: \nMyNode/\n.\n\n\nExpand Attributes Onto Separate Lines\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xml.expand_attributes_onto_new_lines\n\n\nThe \nExpand Attributes\n code action move all attributes onto seperate lines for the XAML node under the cursor.\n\n\n\n\nExpand Node\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xml.expand_node_with_closing_tag\n\n\nWhen a Xaml node is self-closing (EG \nMyNode/\n), this organise refactoring allows a developer to generate a closing tag for the node. For example, the node \nMyNode/\n would become \nMyNode\n ... \n/MyNode\n after applying this refactoring.\n\n\nFormat Xaml Document\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xml.format_document\n\n\nApplies the xml formatting policy to the entire document. It will correctly indent nodes, sort attributes, align attributes under the parent node.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAttributesOnSeparateLines\n\n\nBoolean\n\n\nFalse\n\n\nShould attributes be placed onto separate lines?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nSort Attributes\n\n\n\n\nSort Xaml Attributes\n\n\nProfessional Only\n\n\nConfiguration Id: com.mfractor.code_actions.xml.sort_attributes\n\n\nThis \nSort Attribute\n code actions sorts the attributes for a Xaml node and then recreates the xaml node based on the IDE's xml formatting policy.\n\n\n\n\nMFractor uses the following rules when sorting:\n\n\n\n\nAttributes that declare an xml namespace are ordered first, sorted alphabetically ascending. For example \nxmlns:forms=\\\"http://xamarin.com/schemas/2014/forms\\\"\n will appear before \nxmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\"\n.\n\n\nAttributes that belong to the Microsoft Xaml schema \nhttp://schemas.microsoft.com/winfx/2009/xaml\n are ordered next. For example, the \nx:Class\n or \nx:Name\n declaration.\n\n\nAttributes belonging to the default namespace are ordered next, sorted alphabetically ascending.\n\n\nAttributes belonging to the other namespaces are then ordered next, sorted by namespace ascending and then by attribute name ascending.\n\n\n\n\nUses:\n\n\n\n\nSort Attributes", 
            "title": "XML Code Actions"
        }, 
        {
            "location": "/code-actions/xml/#xml-code-actions", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "XML Code Actions"
        }, 
        {
            "location": "/code-actions/xml/#collapse-attributes-onto-same-line", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xml.collapse_attributes_onto_same_line  The  Collapse Attributes  code action will fold all attributes onto the same line for the XAML node under the cursor.", 
            "title": "Collapse Attributes Onto Same Line"
        }, 
        {
            "location": "/code-actions/xml/#collapse-node", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xml.collapse_node_closing_tag  When a Xaml node has a closing tag and no children (eg:  MyNode   /MyNode ), this refactoring allows the developer to remove the closing tag to make the node self-closing. For example, when applied to the node  MyNode  ...  /MyNode , the closing tag  /MyNode  is removed and the element becomes self closing like so:  MyNode/ .", 
            "title": "Collapse Node"
        }, 
        {
            "location": "/code-actions/xml/#expand-attributes-onto-separate-lines", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xml.expand_attributes_onto_new_lines  The  Expand Attributes  code action move all attributes onto seperate lines for the XAML node under the cursor.", 
            "title": "Expand Attributes Onto Separate Lines"
        }, 
        {
            "location": "/code-actions/xml/#expand-node", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xml.expand_node_with_closing_tag  When a Xaml node is self-closing (EG  MyNode/ ), this organise refactoring allows a developer to generate a closing tag for the node. For example, the node  MyNode/  would become  MyNode  ...  /MyNode  after applying this refactoring.", 
            "title": "Expand Node"
        }, 
        {
            "location": "/code-actions/xml/#format-xaml-document", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xml.format_document  Applies the xml formatting policy to the entire document. It will correctly indent nodes, sort attributes, align attributes under the parent node.", 
            "title": "Format Xaml Document"
        }, 
        {
            "location": "/code-actions/xml/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      AttributesOnSeparateLines  Boolean  False  Should attributes be placed onto separate lines?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-actions/xml/#uses", 
            "text": "Sort Attributes", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-actions/xml/#sort-xaml-attributes", 
            "text": "Professional Only  Configuration Id: com.mfractor.code_actions.xml.sort_attributes  This  Sort Attribute  code actions sorts the attributes for a Xaml node and then recreates the xaml node based on the IDE's xml formatting policy.   MFractor uses the following rules when sorting:   Attributes that declare an xml namespace are ordered first, sorted alphabetically ascending. For example  xmlns:forms=\\\"http://xamarin.com/schemas/2014/forms\\\"  will appear before  xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" .  Attributes that belong to the Microsoft Xaml schema  http://schemas.microsoft.com/winfx/2009/xaml  are ordered next. For example, the  x:Class  or  x:Name  declaration.  Attributes belonging to the default namespace are ordered next, sorted alphabetically ascending.  Attributes belonging to the other namespaces are then ordered next, sorted by namespace ascending and then by attribute name ascending.", 
            "title": "Sort Xaml Attributes"
        }, 
        {
            "location": "/code-actions/xml/#uses_1", 
            "text": "Sort Attributes", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-analysis/csharp/android/", 
            "text": "Android C# Code Analysis\n\n\nAutogenerated by MFractor v3.7.3\n\n\nActivity Icon Should Be Mip Map\n\n\nInspects usages of the \n[Activity]\n attribute and validates the \nIcon\n property uses a mip map instead of a drawable.\n\n\nApplication Requires Peer Connection Constructor\n\n\nCheck Android.Content.Res.Resources Usages\n\n\nWhen using the Android.Content.Res.Resources class, all Get* expressions expect the correct resource type identifier. For example, when using Resource.GetString(), a resource identifier of Resources.String.myString is expected. Passing any other resource identifier such as Resource.Color.myColor may result in unintended data being used or runtime exceptions. This code analyser validates that the correct resource type is being provided to the API call.\n\n\nClass Derives From IJavaObject\n\n\nOften when creating new classes in a Xamarin.Android codebase developers will need a new class to be usable between Java and C#. Xamarin.Android provides the IJavaObject interface to expose a class to Java. Instead of directly inheriting from the IJavaObject interface, a developer should instead inherit from Java.Lang.Object which implements the required interface members.\n\n\nIncorrect Activity Creation\n\n\nThis analyser detects when a developer is instantiating an Android activity or activity subclass directly using a new expression. Activities should only ever be created through the operating system; creating them through a new expression leaves them in an invalid state.\n\n\nVerify Toast Is Shown\n\n\nSometimes when a Toast is created via MakeText, the Show method is accidently omitted. This analysis routine looks for invocations of Toast.MakeText() that don't then invoke the Show() method on the toast object in the same expression. If the MakeText() result is assigned into a variable or passed as a method argument then this check is skipped.\n\n\nWarn Of Static Context References\n\n\nThis analyser inspects static variable declarations within classes and checks if the type derives from Android.Content.Context. Static context references have the potential to cause large memory leaks.", 
            "title": "Android C# Analysis"
        }, 
        {
            "location": "/code-analysis/csharp/android/#android-c-code-analysis", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "Android C# Code Analysis"
        }, 
        {
            "location": "/code-analysis/csharp/android/#activity-icon-should-be-mip-map", 
            "text": "Inspects usages of the  [Activity]  attribute and validates the  Icon  property uses a mip map instead of a drawable.", 
            "title": "Activity Icon Should Be Mip Map"
        }, 
        {
            "location": "/code-analysis/csharp/android/#application-requires-peer-connection-constructor", 
            "text": "", 
            "title": "Application Requires Peer Connection Constructor"
        }, 
        {
            "location": "/code-analysis/csharp/android/#check-androidcontentresresources-usages", 
            "text": "When using the Android.Content.Res.Resources class, all Get* expressions expect the correct resource type identifier. For example, when using Resource.GetString(), a resource identifier of Resources.String.myString is expected. Passing any other resource identifier such as Resource.Color.myColor may result in unintended data being used or runtime exceptions. This code analyser validates that the correct resource type is being provided to the API call.", 
            "title": "Check Android.Content.Res.Resources Usages"
        }, 
        {
            "location": "/code-analysis/csharp/android/#class-derives-from-ijavaobject", 
            "text": "Often when creating new classes in a Xamarin.Android codebase developers will need a new class to be usable between Java and C#. Xamarin.Android provides the IJavaObject interface to expose a class to Java. Instead of directly inheriting from the IJavaObject interface, a developer should instead inherit from Java.Lang.Object which implements the required interface members.", 
            "title": "Class Derives From IJavaObject"
        }, 
        {
            "location": "/code-analysis/csharp/android/#incorrect-activity-creation", 
            "text": "This analyser detects when a developer is instantiating an Android activity or activity subclass directly using a new expression. Activities should only ever be created through the operating system; creating them through a new expression leaves them in an invalid state.", 
            "title": "Incorrect Activity Creation"
        }, 
        {
            "location": "/code-analysis/csharp/android/#verify-toast-is-shown", 
            "text": "Sometimes when a Toast is created via MakeText, the Show method is accidently omitted. This analysis routine looks for invocations of Toast.MakeText() that don't then invoke the Show() method on the toast object in the same expression. If the MakeText() result is assigned into a variable or passed as a method argument then this check is skipped.", 
            "title": "Verify Toast Is Shown"
        }, 
        {
            "location": "/code-analysis/csharp/android/#warn-of-static-context-references", 
            "text": "This analyser inspects static variable declarations within classes and checks if the type derives from Android.Content.Context. Static context references have the potential to cause large memory leaks.", 
            "title": "Warn Of Static Context References"
        }, 
        {
            "location": "/code-analysis/csharp/xamarin-forms/", 
            "text": "Autogenerated by MFractor v3.1.0\n\n\nValidate ExportRendererAttribute Usages\n\n\nProfessional Only\n\n\nThis analyser inspects usages of the ExportRenderer attribute, validating the type passed into the view argument is derived from Xamarin.Forms.View and that the type passed into the renderer argument is a renderer type.", 
            "title": "Xamarin.Forms C# Analysis"
        }, 
        {
            "location": "/code-analysis/csharp/xamarin-forms/#validate-exportrendererattribute-usages", 
            "text": "Professional Only  This analyser inspects usages of the ExportRenderer attribute, validating the type passed into the view argument is derived from Xamarin.Forms.View and that the type passed into the renderer argument is a renderer type.", 
            "title": "Validate ExportRendererAttribute Usages"
        }, 
        {
            "location": "/code-analysis/xaml/", 
            "text": "XAML Code Analysis\n\n\nAutogenerated by MFractor v3.7.3\n\n\nAmbiguous Static Resource Reference\n\n\nInspects StaticResource expressions and checks if one or more static resources will be returned from the resource expression.\n\n\nBinding Against Non-Public Property\n\n\nInspects data-binding expressions and validates that the property return is a public property. Data-binding against a non-public property causes data-binding to fail.\n\n\nBinding Expression Path Does Not Resolve\n\n\nInspects the \nPath\n component of a data binding expression and validates that all components of the path resolve.\n\n\nBinding Expression Return Type Mismatch\n\n\nValidates that the .NET symbol returned by a binding expression matches the expected type for the property.\n\n\nBinding Expressions Resolve\n\n\nInspects \nBinding\n expressions and validates that the symbol referred to in the binding context exists. This analyser requires an explict or implicit binding context.\n\n\nClass Does Not Have Attached Property\n\n\nLooks for attached properties (for example \nGrid.Row\n) and validates they exist in the class that they are attempting to use.\n\n\nColumn Is Outside Grid Boundaries\n\n\nThis code analyser inspects usages of the \nGrid.Column\n attribute and validates that the column provided is within the total columns declared by the parent grid.\n\n\nColumnSpan Is Outside Grid Boundaries\n\n\nThis code analyser inspects usages of the \nGrid.ColumnSpan\n attribute and validates that the span provided is within the total columns declared by the parent grid.\n\n\nContentPage Has Multiple Direct Children\n\n\nInspects usages of \nContentPage\n and checks that it only has a single child view. Assigning multiple children into a \nContentPage\n is a common mistake where the developer usually intended to wrap the chid views with a \nGrid\n or a \nStackLayout\n.\n\n\nContentView Has Multiple Direct Children\n\n\nInspects usages of the \nContentView\n element and checks that it only has a single child view. Assigning multiple children into a \nContentView\n is a common mistake where the developer usually intended to wrap the chid views with a \nGrid\n or a \nStackLayout\n.\n\n\nDetect Missing Image In Linked Projects\n\n\nThis code analyser inspects the value provided into an \nImageSource\n and validates that an image of that name exists within any iOS or Android projects that reference this shared project or PCL.\n\n\nDuplicate AutomationIds\n\n\nInspects a Xaml document for occurances of duplicate \nAutomationId\n declarations.\n\n\nDuplicate Code Behind Field Declarations\n\n\nChecks that the value assigned to an \nx:Name\n attribute is unique within the scope of the document.\n\n\nDuplicate Namespace Declaration\n\n\nChecks that an xml namespace points to a unique namespace and assembly. For example if both \nxmlns:local=\"clr-namespace:MFractor.Licensing.MobileApp\"\n and \nxmlns:myassembly=\"clr-namespace:MFractor.Licensing.MobileApp\"\n were declared, this analyser would warn that they both reference the same assembly and namespace.\n\n\nDuplicate Resource Dictionary Keys\n\n\nValidates the each resource entry within a resource dictionary has a unique key.\n\n\nEmpty AutomationId Declaration\n\n\nInspects a Xaml document for occurances of duplicate \nAutomationId\n declarations.\n\n\nEmpty Code Behind Field Declaration\n\n\nInspects occurances of the \nx:Name\n attribute and validates that a value is assigned; empty \nx:Name\n expressions generate an empty named code-behind field, causing compilation errors.\n\n\nEmpty Event Handler Assignment\n\n\nChecks that an event handler assignment is not empty as empty event handler assignments will cause a compilation error.\n\n\nEmpty Value Assignment\n\n\nDetects when a boolean, double, long or integer value is being assigned an empty value and will cause a compilation error.\n\n\nEvent Handler Exists In Code Behind Class\n\n\nChecks that an event callback referenced referenced by an attribute value exists in the code behind class.\n\n\nEvent Handler Signature Mismatch\n\n\nChecks that the signature for the event callback in a code behind class matches the expected signature for the property it is assigned to.\n\n\nGeneric Usage Is Missing x:TypeArguments\n\n\nInspects generic classes that are instantiated through Xaml and validates that an \nx:TypeArguments\n attribute or property assignment node is present.\n\n\nGrid.Column Usage Is Redundant\n\n\nThis code analyser inspects usages of the \nGrid.Column\n attribute and validates that the element is inside a \nGrid\n.\n\n\nGrid.ColumnSpan Usage Is Redundant\n\n\nThis code analyser inspects usages of the \nGrid.ColumnSpan\n attribute and validates that the element is inside a \nGrid\n.\n\n\nGrid.Row Usage Is Redundant\n\n\nThis code analyser inspects usages of the \nGrid.Row\n attribute and validates that the element is inside a \nGrid\n.\n\n\nGrid.RowSpan Usage Is Redundant\n\n\nThis code analyser inspects usages of the \nGrid.RowSpan\n attribute and validates that the element is inside a \nGrid\n.\n\n\nInvalid Named Font Size\n\n\nInspects \nFontSize\n attributes and validates that the named size provided to it is a valid font size name (Micro, Small, Medium, Large).\n\n\nInvalid Thickness Attribute Value\n\n\nInspects attribute properties that use the \nXamarin.Forms.Thickness\n type and checks the value used can be translated to a thickness. For example, \nThickness\n could accidentally be provided \n0,5,05\n, with the intention of it being \n0,5,0,5\n; the first example has three arguments while the second has four. This misuse would cause the app to crash when using inflated XAML or for XAMLC to fail.\n\n\nMissing Microsoft Schema\n\n\nInspects at the root xaml node and verifies that it references the Microsoft Xaml schema: \nhttp://schemas.microsoft.com/winfx/2009/xaml\n. This schema is required for Xamarin Forms Xaml documents.\n\n\nNo Key Provided To DynamicResource Expression\n\n\nInspects \nDynamicResource\n expressions and validates that a resource key has been provided.\n\n\nNo Key Provided To Static Resource Expression\n\n\nInspects \nStaticResource\n expressions and validates that a resource key has been provided.\n\n\nObsolete Property Used\n\n\nChecks for attributes that are marked as obsolete/deprecated.\n\n\nOnIdiom Return Type Mismatch\n\n\nChecks the type returned by a \nXamarin.Forms.OnIdiom\n element is valid with the parent property type.\n\n\nOnPlatform Return Type Mismatch\n\n\nChecks the type returned by a \nXamarin.Forms.OnPlatform\n element is valid with the parent property type.\n\n\nProperty Node Maps To Member In Parent Type\n\n\nChecks that a property node resolves to a member within its parent type.\n\n\nProperty Setter Does Not Exist In Style TargetType\n\n\nThis code inspection looks at \nSetter\n elements when they are used inside a \nStyle\n and validates that the member specified in the \nProperty\n attribute exists on the type symbol referenced in the parent \nStyle\ns \nTargetType\n attribute.\n\n\nProperty Setter Node Misuse\n\n\nInspects for property setters that don't apply to the outer class. For example, if a developer used OnIdiom.Phone inside a OnPlatform element, the OnIdiom.Phone property setter makes no sense within the given context.\n\n\nProperty Setter Type Mismatch\n\n\nWhen using MyClass.MyProperty node setter syntax, validate that the inner child node returns a .NET object of the correct type for the property.\n\n\nReferenced Attribute Member Exists In Parent Type\n\n\nChecks that an attribute resolves to a member within its parent type.\n\n\nReferenced Code Behind Field Exists\n\n\nInspects usages of the \nx:Reference\n expression and validates the referenced element has been declared within the document. \nx:Reference\n expressions are used to resolve another Xaml node has a code behind field defined using the \nx:Name\n attribute.\n\n\nResource Entry Does Not Define Key\n\n\nValidates the elements provided to a resource dictionary supply an \nx:Key\n attribute to declare their resource dictionary key.\n\n\nResource Key Conflict\n\n\nInspects resource key declarations and validates that the resource key is not already defined in other files that are used by this file.\n\n\nRow Is Outside Grid Boundaries\n\n\nThis code analyser inspects usages of the \nGrid.Row\n attribute and validates that the row provided is within the total rows declared by the parent grid.\n\n\nRowSpan Is Outside Grid Boundaries\n\n\nThis code analyser inspects usages of the \nGrid.RowSpan\n attribute and validates that the span provided is within the total rows declared by the parent grid.\n\n\nScrollView Has Multiple Direct Children\n\n\nInspects usages of \nScrollView\n and checks that it only has a single child view. Assigning multiple children into a \nScrollView\n is a common mistake where the developer usually intended to wrap the chid views with a \nGrid\n or a \nStackLayout\n.\n\n\nSetter Property Exists\n\n\nInspects the \nProperty\n attribute for a \nXamarin.Forms.Setter\n and validates that it exists in the parents specified \nTargetType\n.\n\n\nStaticResource Return Type Mismatch\n\n\nValidates that the symbol returned by a \nStaticResource\n expression matches the expected type for the property.\n\n\nStyle Is Missing TargetType\n\n\nWhen a \nStyle\n is used within XAML, it should always specify a type it targets using the \nTargetType\n property. This analysis check inspects for usages of \nStyle\n that don't assign the \nTargetType\n property.\n\n\nStyle Or Trigger Has Duplicate Setters\n\n\nInspects Style and Trigger declarations and checks if there is are multiple Setter's for a property.\n\n\nStyle TargetType Does Not Match BasedOn TargetType\n\n\nInspects XAML styles that use the \nBasedOn\n property to inherit from another style and validates the \nTargetType\n of the current style matches the \nTargetType\n defined by the \nBasedOn\n style.\n\n\nTrigger Is Missing Target Type\n\n\nInspects XAML elements that derive from \nXamarin.Forms.TriggerBase\n and validates that they include a \nTargetType\n attribute\n\n\nTrigger TargetType Does Not Match Parent\n\n\nInspects usages of the \nTargetType\n property for a \nXamarin.Forms.TriggerBase\n and validates that the type provided matches the outer XAML node.\n\n\nUndefined Static Resource Usage\n\n\nValidates that the element referenced by a \nStaticResource\n expression resource lookup resolves to a resource defined in the xaml file.\n\n\nUnknown Static Property Value\n\n\nFor attributes that accept a class object, inspects that the literal value maps to a static property or field in the class type. For example, the \nLayoutOptions\n class has the static fields \nFill\n or \nCentreAndExpand\n that can be used a literal attribute values. If \nCentreAndFill\n was provided (an invalid value), this analyser would inspect the \nLayoutOptions\n class for a static field named \nCentreAndFill\n and trigger an analysis error when it couldn't be found.\n\n\nUnknown Type Provided To Generic\n\n\nInspects usages of \nx:TypeArguments\n and validates that the type provided exists.\n\n\nUnresolved .NET Symbols Within Xaml Expression\n\n\nInspects a .net symbol reference (eg \nlocal:MyClass.MyProperty\n) and validates that the symbol portion ('MyClass.MyProperty') resolves to a .NET symbol within the current project and it's references.\n\n\nUnresolved Namespace Within Xaml Expression\n\n\nInspects a .net symbol reference (eg \nlocal:MyClass.MyProperty\n) and validates that the namespace portion ('local') resolves to a xmlns declaration in the current document.\n\n\nUnresolved Xml Namespace\n\n\nChecks that the namespace used on the xml nodes is defined within the current document.\n\n\nUnresolved Xmlns Assembly\n\n\nChecks that the 'assembly' component of an xmlns statement resolves to an assembly referenced by the project.\n\n\nUnused Resource\n\n\nInspects that resource dictionary entries are used via the \nStaticResource\n markup extension expression within this document.\n\n\nUnused Xml Namespace\n\n\nValidate that xmlns attributes that declare a namespace and assembly that is used within the current document.\n\n\nValidate Binding Expressions Return A Property\n\n\nEvaluates a \nBinding\n expression and validates that it points to property within the binding context. This analyser requires an explict or implicit binding context.\n\n\nValidate Setter Attached Property Usage\n\n\nInspects the \nProperty\n attribute for a \nXamarin.Forms.Setter\n and, when it is referencing an attached property, validates that the namespace, class and attached property exist.\n\n\nValidate Value Types\n\n\nInspects the input provided to attributes that expect value types (int, bool, double etc) and validates that the input is valid.\n\n\nValue Converter Input Type Mismatch\n\n\nInspects the \nConverter\n property of a \nBinding\nexpression and validates that the input type is correct. This analyser requires that the \nIValueConverter\n implementation uses the \nValueConversion\n attribute to declare it input type.\n\n\nValue Converter Output Type Mismatch\n\n\nInspects the \nConverter\n component of a \nBinding\n expression and validates that the returned output type is valid for the parent attribute. This analyser requires that the \nIValueConverter\n implementation uses the \nValueConversion\n attribute to declare it input type.\n\n\nx:Name Has Invalid Characters\n\n\nChecks that x:Name expressions define a valid code-behind variable name. A value declared by an x:Name attribute must start with a @, _ or a-Z character followed by underscores or alpha-numeric characters.\n\n\nx:Static Return Type Mismatch\n\n\nValidates that the .NET symbol returned by an \nx:Static\n expressions matches the expected type for the property.\n\n\nx:TypeArguments Used On Non-Generic Class\n\n\nInspects for usages of \nx:TypeArguments\n on elements that are non-generic classes.\n\n\nXamarin.Forms.Image Used When FFImageLoading Available\n\n\nDetects when the standard \nXamarin.Forms.Image\n control is used when FFImageLoading's \nCachedImage\n control is available for use. The CachedImage control is superior as it reduces memory pressure on Android and provides an expanded API for loading, error handling and transformations.\n\n\nXaml Node Resolves\n\n\nChecks that xaml nodes map to a valid .NET symbol.", 
            "title": "XAML Analysis"
        }, 
        {
            "location": "/code-analysis/xaml/#xaml-code-analysis", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "XAML Code Analysis"
        }, 
        {
            "location": "/code-analysis/xaml/#ambiguous-static-resource-reference", 
            "text": "Inspects StaticResource expressions and checks if one or more static resources will be returned from the resource expression.", 
            "title": "Ambiguous Static Resource Reference"
        }, 
        {
            "location": "/code-analysis/xaml/#binding-against-non-public-property", 
            "text": "Inspects data-binding expressions and validates that the property return is a public property. Data-binding against a non-public property causes data-binding to fail.", 
            "title": "Binding Against Non-Public Property"
        }, 
        {
            "location": "/code-analysis/xaml/#binding-expression-path-does-not-resolve", 
            "text": "Inspects the  Path  component of a data binding expression and validates that all components of the path resolve.", 
            "title": "Binding Expression Path Does Not Resolve"
        }, 
        {
            "location": "/code-analysis/xaml/#binding-expression-return-type-mismatch", 
            "text": "Validates that the .NET symbol returned by a binding expression matches the expected type for the property.", 
            "title": "Binding Expression Return Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#binding-expressions-resolve", 
            "text": "Inspects  Binding  expressions and validates that the symbol referred to in the binding context exists. This analyser requires an explict or implicit binding context.", 
            "title": "Binding Expressions Resolve"
        }, 
        {
            "location": "/code-analysis/xaml/#class-does-not-have-attached-property", 
            "text": "Looks for attached properties (for example  Grid.Row ) and validates they exist in the class that they are attempting to use.", 
            "title": "Class Does Not Have Attached Property"
        }, 
        {
            "location": "/code-analysis/xaml/#column-is-outside-grid-boundaries", 
            "text": "This code analyser inspects usages of the  Grid.Column  attribute and validates that the column provided is within the total columns declared by the parent grid.", 
            "title": "Column Is Outside Grid Boundaries"
        }, 
        {
            "location": "/code-analysis/xaml/#columnspan-is-outside-grid-boundaries", 
            "text": "This code analyser inspects usages of the  Grid.ColumnSpan  attribute and validates that the span provided is within the total columns declared by the parent grid.", 
            "title": "ColumnSpan Is Outside Grid Boundaries"
        }, 
        {
            "location": "/code-analysis/xaml/#contentpage-has-multiple-direct-children", 
            "text": "Inspects usages of  ContentPage  and checks that it only has a single child view. Assigning multiple children into a  ContentPage  is a common mistake where the developer usually intended to wrap the chid views with a  Grid  or a  StackLayout .", 
            "title": "ContentPage Has Multiple Direct Children"
        }, 
        {
            "location": "/code-analysis/xaml/#contentview-has-multiple-direct-children", 
            "text": "Inspects usages of the  ContentView  element and checks that it only has a single child view. Assigning multiple children into a  ContentView  is a common mistake where the developer usually intended to wrap the chid views with a  Grid  or a  StackLayout .", 
            "title": "ContentView Has Multiple Direct Children"
        }, 
        {
            "location": "/code-analysis/xaml/#detect-missing-image-in-linked-projects", 
            "text": "This code analyser inspects the value provided into an  ImageSource  and validates that an image of that name exists within any iOS or Android projects that reference this shared project or PCL.", 
            "title": "Detect Missing Image In Linked Projects"
        }, 
        {
            "location": "/code-analysis/xaml/#duplicate-automationids", 
            "text": "Inspects a Xaml document for occurances of duplicate  AutomationId  declarations.", 
            "title": "Duplicate AutomationIds"
        }, 
        {
            "location": "/code-analysis/xaml/#duplicate-code-behind-field-declarations", 
            "text": "Checks that the value assigned to an  x:Name  attribute is unique within the scope of the document.", 
            "title": "Duplicate Code Behind Field Declarations"
        }, 
        {
            "location": "/code-analysis/xaml/#duplicate-namespace-declaration", 
            "text": "Checks that an xml namespace points to a unique namespace and assembly. For example if both  xmlns:local=\"clr-namespace:MFractor.Licensing.MobileApp\"  and  xmlns:myassembly=\"clr-namespace:MFractor.Licensing.MobileApp\"  were declared, this analyser would warn that they both reference the same assembly and namespace.", 
            "title": "Duplicate Namespace Declaration"
        }, 
        {
            "location": "/code-analysis/xaml/#duplicate-resource-dictionary-keys", 
            "text": "Validates the each resource entry within a resource dictionary has a unique key.", 
            "title": "Duplicate Resource Dictionary Keys"
        }, 
        {
            "location": "/code-analysis/xaml/#empty-automationid-declaration", 
            "text": "Inspects a Xaml document for occurances of duplicate  AutomationId  declarations.", 
            "title": "Empty AutomationId Declaration"
        }, 
        {
            "location": "/code-analysis/xaml/#empty-code-behind-field-declaration", 
            "text": "Inspects occurances of the  x:Name  attribute and validates that a value is assigned; empty  x:Name  expressions generate an empty named code-behind field, causing compilation errors.", 
            "title": "Empty Code Behind Field Declaration"
        }, 
        {
            "location": "/code-analysis/xaml/#empty-event-handler-assignment", 
            "text": "Checks that an event handler assignment is not empty as empty event handler assignments will cause a compilation error.", 
            "title": "Empty Event Handler Assignment"
        }, 
        {
            "location": "/code-analysis/xaml/#empty-value-assignment", 
            "text": "Detects when a boolean, double, long or integer value is being assigned an empty value and will cause a compilation error.", 
            "title": "Empty Value Assignment"
        }, 
        {
            "location": "/code-analysis/xaml/#event-handler-exists-in-code-behind-class", 
            "text": "Checks that an event callback referenced referenced by an attribute value exists in the code behind class.", 
            "title": "Event Handler Exists In Code Behind Class"
        }, 
        {
            "location": "/code-analysis/xaml/#event-handler-signature-mismatch", 
            "text": "Checks that the signature for the event callback in a code behind class matches the expected signature for the property it is assigned to.", 
            "title": "Event Handler Signature Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#generic-usage-is-missing-xtypearguments", 
            "text": "Inspects generic classes that are instantiated through Xaml and validates that an  x:TypeArguments  attribute or property assignment node is present.", 
            "title": "Generic Usage Is Missing x:TypeArguments"
        }, 
        {
            "location": "/code-analysis/xaml/#gridcolumn-usage-is-redundant", 
            "text": "This code analyser inspects usages of the  Grid.Column  attribute and validates that the element is inside a  Grid .", 
            "title": "Grid.Column Usage Is Redundant"
        }, 
        {
            "location": "/code-analysis/xaml/#gridcolumnspan-usage-is-redundant", 
            "text": "This code analyser inspects usages of the  Grid.ColumnSpan  attribute and validates that the element is inside a  Grid .", 
            "title": "Grid.ColumnSpan Usage Is Redundant"
        }, 
        {
            "location": "/code-analysis/xaml/#gridrow-usage-is-redundant", 
            "text": "This code analyser inspects usages of the  Grid.Row  attribute and validates that the element is inside a  Grid .", 
            "title": "Grid.Row Usage Is Redundant"
        }, 
        {
            "location": "/code-analysis/xaml/#gridrowspan-usage-is-redundant", 
            "text": "This code analyser inspects usages of the  Grid.RowSpan  attribute and validates that the element is inside a  Grid .", 
            "title": "Grid.RowSpan Usage Is Redundant"
        }, 
        {
            "location": "/code-analysis/xaml/#invalid-named-font-size", 
            "text": "Inspects  FontSize  attributes and validates that the named size provided to it is a valid font size name (Micro, Small, Medium, Large).", 
            "title": "Invalid Named Font Size"
        }, 
        {
            "location": "/code-analysis/xaml/#invalid-thickness-attribute-value", 
            "text": "Inspects attribute properties that use the  Xamarin.Forms.Thickness  type and checks the value used can be translated to a thickness. For example,  Thickness  could accidentally be provided  0,5,05 , with the intention of it being  0,5,0,5 ; the first example has three arguments while the second has four. This misuse would cause the app to crash when using inflated XAML or for XAMLC to fail.", 
            "title": "Invalid Thickness Attribute Value"
        }, 
        {
            "location": "/code-analysis/xaml/#missing-microsoft-schema", 
            "text": "Inspects at the root xaml node and verifies that it references the Microsoft Xaml schema:  http://schemas.microsoft.com/winfx/2009/xaml . This schema is required for Xamarin Forms Xaml documents.", 
            "title": "Missing Microsoft Schema"
        }, 
        {
            "location": "/code-analysis/xaml/#no-key-provided-to-dynamicresource-expression", 
            "text": "Inspects  DynamicResource  expressions and validates that a resource key has been provided.", 
            "title": "No Key Provided To DynamicResource Expression"
        }, 
        {
            "location": "/code-analysis/xaml/#no-key-provided-to-static-resource-expression", 
            "text": "Inspects  StaticResource  expressions and validates that a resource key has been provided.", 
            "title": "No Key Provided To Static Resource Expression"
        }, 
        {
            "location": "/code-analysis/xaml/#obsolete-property-used", 
            "text": "Checks for attributes that are marked as obsolete/deprecated.", 
            "title": "Obsolete Property Used"
        }, 
        {
            "location": "/code-analysis/xaml/#onidiom-return-type-mismatch", 
            "text": "Checks the type returned by a  Xamarin.Forms.OnIdiom  element is valid with the parent property type.", 
            "title": "OnIdiom Return Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#onplatform-return-type-mismatch", 
            "text": "Checks the type returned by a  Xamarin.Forms.OnPlatform  element is valid with the parent property type.", 
            "title": "OnPlatform Return Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#property-node-maps-to-member-in-parent-type", 
            "text": "Checks that a property node resolves to a member within its parent type.", 
            "title": "Property Node Maps To Member In Parent Type"
        }, 
        {
            "location": "/code-analysis/xaml/#property-setter-does-not-exist-in-style-targettype", 
            "text": "This code inspection looks at  Setter  elements when they are used inside a  Style  and validates that the member specified in the  Property  attribute exists on the type symbol referenced in the parent  Style s  TargetType  attribute.", 
            "title": "Property Setter Does Not Exist In Style TargetType"
        }, 
        {
            "location": "/code-analysis/xaml/#property-setter-node-misuse", 
            "text": "Inspects for property setters that don't apply to the outer class. For example, if a developer used OnIdiom.Phone inside a OnPlatform element, the OnIdiom.Phone property setter makes no sense within the given context.", 
            "title": "Property Setter Node Misuse"
        }, 
        {
            "location": "/code-analysis/xaml/#property-setter-type-mismatch", 
            "text": "When using MyClass.MyProperty node setter syntax, validate that the inner child node returns a .NET object of the correct type for the property.", 
            "title": "Property Setter Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#referenced-attribute-member-exists-in-parent-type", 
            "text": "Checks that an attribute resolves to a member within its parent type.", 
            "title": "Referenced Attribute Member Exists In Parent Type"
        }, 
        {
            "location": "/code-analysis/xaml/#referenced-code-behind-field-exists", 
            "text": "Inspects usages of the  x:Reference  expression and validates the referenced element has been declared within the document.  x:Reference  expressions are used to resolve another Xaml node has a code behind field defined using the  x:Name  attribute.", 
            "title": "Referenced Code Behind Field Exists"
        }, 
        {
            "location": "/code-analysis/xaml/#resource-entry-does-not-define-key", 
            "text": "Validates the elements provided to a resource dictionary supply an  x:Key  attribute to declare their resource dictionary key.", 
            "title": "Resource Entry Does Not Define Key"
        }, 
        {
            "location": "/code-analysis/xaml/#resource-key-conflict", 
            "text": "Inspects resource key declarations and validates that the resource key is not already defined in other files that are used by this file.", 
            "title": "Resource Key Conflict"
        }, 
        {
            "location": "/code-analysis/xaml/#row-is-outside-grid-boundaries", 
            "text": "This code analyser inspects usages of the  Grid.Row  attribute and validates that the row provided is within the total rows declared by the parent grid.", 
            "title": "Row Is Outside Grid Boundaries"
        }, 
        {
            "location": "/code-analysis/xaml/#rowspan-is-outside-grid-boundaries", 
            "text": "This code analyser inspects usages of the  Grid.RowSpan  attribute and validates that the span provided is within the total rows declared by the parent grid.", 
            "title": "RowSpan Is Outside Grid Boundaries"
        }, 
        {
            "location": "/code-analysis/xaml/#scrollview-has-multiple-direct-children", 
            "text": "Inspects usages of  ScrollView  and checks that it only has a single child view. Assigning multiple children into a  ScrollView  is a common mistake where the developer usually intended to wrap the chid views with a  Grid  or a  StackLayout .", 
            "title": "ScrollView Has Multiple Direct Children"
        }, 
        {
            "location": "/code-analysis/xaml/#setter-property-exists", 
            "text": "Inspects the  Property  attribute for a  Xamarin.Forms.Setter  and validates that it exists in the parents specified  TargetType .", 
            "title": "Setter Property Exists"
        }, 
        {
            "location": "/code-analysis/xaml/#staticresource-return-type-mismatch", 
            "text": "Validates that the symbol returned by a  StaticResource  expression matches the expected type for the property.", 
            "title": "StaticResource Return Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#style-is-missing-targettype", 
            "text": "When a  Style  is used within XAML, it should always specify a type it targets using the  TargetType  property. This analysis check inspects for usages of  Style  that don't assign the  TargetType  property.", 
            "title": "Style Is Missing TargetType"
        }, 
        {
            "location": "/code-analysis/xaml/#style-or-trigger-has-duplicate-setters", 
            "text": "Inspects Style and Trigger declarations and checks if there is are multiple Setter's for a property.", 
            "title": "Style Or Trigger Has Duplicate Setters"
        }, 
        {
            "location": "/code-analysis/xaml/#style-targettype-does-not-match-basedon-targettype", 
            "text": "Inspects XAML styles that use the  BasedOn  property to inherit from another style and validates the  TargetType  of the current style matches the  TargetType  defined by the  BasedOn  style.", 
            "title": "Style TargetType Does Not Match BasedOn TargetType"
        }, 
        {
            "location": "/code-analysis/xaml/#trigger-is-missing-target-type", 
            "text": "Inspects XAML elements that derive from  Xamarin.Forms.TriggerBase  and validates that they include a  TargetType  attribute", 
            "title": "Trigger Is Missing Target Type"
        }, 
        {
            "location": "/code-analysis/xaml/#trigger-targettype-does-not-match-parent", 
            "text": "Inspects usages of the  TargetType  property for a  Xamarin.Forms.TriggerBase  and validates that the type provided matches the outer XAML node.", 
            "title": "Trigger TargetType Does Not Match Parent"
        }, 
        {
            "location": "/code-analysis/xaml/#undefined-static-resource-usage", 
            "text": "Validates that the element referenced by a  StaticResource  expression resource lookup resolves to a resource defined in the xaml file.", 
            "title": "Undefined Static Resource Usage"
        }, 
        {
            "location": "/code-analysis/xaml/#unknown-static-property-value", 
            "text": "For attributes that accept a class object, inspects that the literal value maps to a static property or field in the class type. For example, the  LayoutOptions  class has the static fields  Fill  or  CentreAndExpand  that can be used a literal attribute values. If  CentreAndFill  was provided (an invalid value), this analyser would inspect the  LayoutOptions  class for a static field named  CentreAndFill  and trigger an analysis error when it couldn't be found.", 
            "title": "Unknown Static Property Value"
        }, 
        {
            "location": "/code-analysis/xaml/#unknown-type-provided-to-generic", 
            "text": "Inspects usages of  x:TypeArguments  and validates that the type provided exists.", 
            "title": "Unknown Type Provided To Generic"
        }, 
        {
            "location": "/code-analysis/xaml/#unresolved-net-symbols-within-xaml-expression", 
            "text": "Inspects a .net symbol reference (eg  local:MyClass.MyProperty ) and validates that the symbol portion ('MyClass.MyProperty') resolves to a .NET symbol within the current project and it's references.", 
            "title": "Unresolved .NET Symbols Within Xaml Expression"
        }, 
        {
            "location": "/code-analysis/xaml/#unresolved-namespace-within-xaml-expression", 
            "text": "Inspects a .net symbol reference (eg  local:MyClass.MyProperty ) and validates that the namespace portion ('local') resolves to a xmlns declaration in the current document.", 
            "title": "Unresolved Namespace Within Xaml Expression"
        }, 
        {
            "location": "/code-analysis/xaml/#unresolved-xml-namespace", 
            "text": "Checks that the namespace used on the xml nodes is defined within the current document.", 
            "title": "Unresolved Xml Namespace"
        }, 
        {
            "location": "/code-analysis/xaml/#unresolved-xmlns-assembly", 
            "text": "Checks that the 'assembly' component of an xmlns statement resolves to an assembly referenced by the project.", 
            "title": "Unresolved Xmlns Assembly"
        }, 
        {
            "location": "/code-analysis/xaml/#unused-resource", 
            "text": "Inspects that resource dictionary entries are used via the  StaticResource  markup extension expression within this document.", 
            "title": "Unused Resource"
        }, 
        {
            "location": "/code-analysis/xaml/#unused-xml-namespace", 
            "text": "Validate that xmlns attributes that declare a namespace and assembly that is used within the current document.", 
            "title": "Unused Xml Namespace"
        }, 
        {
            "location": "/code-analysis/xaml/#validate-binding-expressions-return-a-property", 
            "text": "Evaluates a  Binding  expression and validates that it points to property within the binding context. This analyser requires an explict or implicit binding context.", 
            "title": "Validate Binding Expressions Return A Property"
        }, 
        {
            "location": "/code-analysis/xaml/#validate-setter-attached-property-usage", 
            "text": "Inspects the  Property  attribute for a  Xamarin.Forms.Setter  and, when it is referencing an attached property, validates that the namespace, class and attached property exist.", 
            "title": "Validate Setter Attached Property Usage"
        }, 
        {
            "location": "/code-analysis/xaml/#validate-value-types", 
            "text": "Inspects the input provided to attributes that expect value types (int, bool, double etc) and validates that the input is valid.", 
            "title": "Validate Value Types"
        }, 
        {
            "location": "/code-analysis/xaml/#value-converter-input-type-mismatch", 
            "text": "Inspects the  Converter  property of a  Binding expression and validates that the input type is correct. This analyser requires that the  IValueConverter  implementation uses the  ValueConversion  attribute to declare it input type.", 
            "title": "Value Converter Input Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#value-converter-output-type-mismatch", 
            "text": "Inspects the  Converter  component of a  Binding  expression and validates that the returned output type is valid for the parent attribute. This analyser requires that the  IValueConverter  implementation uses the  ValueConversion  attribute to declare it input type.", 
            "title": "Value Converter Output Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#xname-has-invalid-characters", 
            "text": "Checks that x:Name expressions define a valid code-behind variable name. A value declared by an x:Name attribute must start with a @, _ or a-Z character followed by underscores or alpha-numeric characters.", 
            "title": "x:Name Has Invalid Characters"
        }, 
        {
            "location": "/code-analysis/xaml/#xstatic-return-type-mismatch", 
            "text": "Validates that the .NET symbol returned by an  x:Static  expressions matches the expected type for the property.", 
            "title": "x:Static Return Type Mismatch"
        }, 
        {
            "location": "/code-analysis/xaml/#xtypearguments-used-on-non-generic-class", 
            "text": "Inspects for usages of  x:TypeArguments  on elements that are non-generic classes.", 
            "title": "x:TypeArguments Used On Non-Generic Class"
        }, 
        {
            "location": "/code-analysis/xaml/#xamarinformsimage-used-when-ffimageloading-available", 
            "text": "Detects when the standard  Xamarin.Forms.Image  control is used when FFImageLoading's  CachedImage  control is available for use. The CachedImage control is superior as it reduces memory pressure on Android and provides an expanded API for loading, error handling and transformations.", 
            "title": "Xamarin.Forms.Image Used When FFImageLoading Available"
        }, 
        {
            "location": "/code-analysis/xaml/#xaml-node-resolves", 
            "text": "Checks that xaml nodes map to a valid .NET symbol.", 
            "title": "Xaml Node Resolves"
        }, 
        {
            "location": "/code-analysis/configuration/", 
            "text": "MFractor Configuration Analysis\n\n\nAutogenerated by MFractor v3.7.3\n\n\nInvalid Property Value\n\n\nInspects the \nvalue\n attribute of a \nproperty\n within MFractor configuration file and checks that the value provided is valid.\n\n\nUnknown Configurable Property\n\n\nInspects the \nproperty\n element of an MFractor configuration file and validates the \nname\n element refers to a property on the configurable targetted by the parent \nconfigure\n element.\n\n\nUnknown Configuration Identifier\n\n\nInspects the \nconfigure\n element of an MFractor configuration file and validates the \nidentifier\n element refers to a valid MFractor configurable.", 
            "title": "MFractor Configuration Analysis"
        }, 
        {
            "location": "/code-analysis/configuration/#mfractor-configuration-analysis", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "MFractor Configuration Analysis"
        }, 
        {
            "location": "/code-analysis/configuration/#invalid-property-value", 
            "text": "Inspects the  value  attribute of a  property  within MFractor configuration file and checks that the value provided is valid.", 
            "title": "Invalid Property Value"
        }, 
        {
            "location": "/code-analysis/configuration/#unknown-configurable-property", 
            "text": "Inspects the  property  element of an MFractor configuration file and validates the  name  element refers to a property on the configurable targetted by the parent  configure  element.", 
            "title": "Unknown Configurable Property"
        }, 
        {
            "location": "/code-analysis/configuration/#unknown-configuration-identifier", 
            "text": "Inspects the  configure  element of an MFractor configuration file and validates the  identifier  element refers to a valid MFractor configurable.", 
            "title": "Unknown Configuration Identifier"
        }, 
        {
            "location": "/code-generation/csharp/", 
            "text": "C# Code Generation\n\n\nAutogenerated by MFractor v3.7.3\n\n\nCreate AttributeUsage Annotation\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.attribute_usage_annotation\n\n\nCreate an \n[System.AttributeUsage()]\n annotation that can can be attached to a class declaration that derives from \nSystem.Attribute\n.\n\n\nCreate Base Constructor\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.base_constructor\n\n\nGenerates a class constructor that routes a series of constructor parameters into a \nbase(...)\n constructor.\n\n\nUses:\n\n\n\n\nCreate Constructor\n\n\n\n\nCreate Class Declaration\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.class_declaration\n\n\nGenerates a new class declaration implementing all provided members, base class constructors, base class abstract invocations and interfaces\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nImplementBaseConstructors\n\n\nBoolean\n\n\nFalse\n\n\nShould the base class constructors be automatically created?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nMember Field Generator\n\n\nGenerate Instance Property\n\n\nMethod Generator\n\n\nCreate Base Constructor\n\n\nGenerate Event Handler Declaration\n\n\n\n\nCreate Constructor\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.constructor\n\n\nGenerates a class constructor, optionally with a set of arguments.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nArgumentFirstLetterToLowerCase\n\n\nBoolean\n\n\nTrue\n\n\nShould all constructor arguments have their first letter forced to lower case?\n\n\n\n\n\n\n\n\nGenerate Assignment Expression\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.assignment_expression\n\n\nGenerates an assignment expresssion; eg \nthis.myField = value;\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIncludeThisForMembers\n\n\nBoolean\n\n\nFalse\n\n\nWhen assigning to a class member, should a \nthis.\n be added to the variable being assigned?\n\n\n\n\n\n\n\n\nGenerate Event Handler Declaration\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.event_handler_declaration\n\n\nGenerates an \nevent EventHandler\nEventArgs\n declaration that can be bound against by a callback.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new event handler.\nevent_type\n: The fully qualified type of the event handler.\narguments_type\n: The fully qualified type of the event arguments.\n\n\npublic event $event_type$\n$argument_type$\n $name$;\n\n\nWhat is the code snippet to use when creating a new event handler?\n\n\n\n\n\n\n\n\nGenerate Event Handler Method\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.event_handler_method\n\n\nGenerates a method that's compatible for registration with an \nEventHandler\nEventArgs\n as a callback.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new method.\ntype\n: The fully qualified type of the event arguments.\n\n\npublic void $name$(object sender, $type$ e)\n{\n    throw new System.NotImplementedException();\n}\n\n\nWhat is the code snippet to use when creating the new event handler method declaration?\n\n\n\n\n\n\n\n\nGenerate Instance Property\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.instance_property\n\n\nGenerates a instance property with a getter and setter.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\ntype\n: The fully qualified type of the new property.\nname\n: The name of the new propety.\nvalue\n: The value to assign to the new property.\n\n\npublic $type$ $name$\n{\n    set;\n}\n\n\nWhat is the code snippet to use when creating the property declaration?\n\n\n\n\n\n\nReadOnlySnippet\n\n\nCode Snippet\nArguments\n:\ntype\n: The fully qualified type of the new property.\nname\n: The name of the new propety.\nvalue\n: The value to assign to the new property.\n\n\npublic $type$ $name$\n{\n    get;\n}\n\n\nWhat is the code snippet to use when creating a readonly property declaration?\n\n\n\n\n\n\nWriteOnlySnippet\n\n\nCode Snippet\nArguments\n:\ntype\n: The fully qualified type of the new property.\nname\n: The name of the new propety.\nvalue\n: The value to assign to the new property.\n\n\npublic $type$ $name$\n{\n    get;\n    set;\n}\n\n\nWhat is the code snippet to use when creating a write only property declaration?\n\n\n\n\n\n\n\n\nGenerate Member Initialiser\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.member_initialiser_expression\n\n\nGenerates an initilisation expression for a class/struct member (such as a property or field).\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nForceStringLiteral\n\n\nBoolean\n\n\nFalse\n\n\nShould the code generator always attempt to assign members with a string literal?\n\n\n\n\n\n\n\n\nMember Field Generator\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.field_declaration\n\n\nGenerates member field declarations with an optional value initialisation\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUnderscoreOnBackingField\n\n\nBoolean\n\n\nFalse\n\n\nWhen creating a backing field for a property, should the field have an underscore appended to the start of the field name?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Member Initialiser\n\n\n\n\nMethod Generator\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.method_declaration\n\n\nGenerates a new method declaration\n\n\nNamespace Declaration\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.namespace_declaration\n\n\nGenerates a new namespace declaration syntax element\n\n\nUsing Directive Generator\n\n\nConfiguration Id: com.mfractor.code_gen.csharp.using_directive\n\n\nGenerates a new using directive for the provided namespace", 
            "title": "C#"
        }, 
        {
            "location": "/code-generation/csharp/#c-code-generation", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "C# Code Generation"
        }, 
        {
            "location": "/code-generation/csharp/#create-attributeusage-annotation", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.attribute_usage_annotation  Create an  [System.AttributeUsage()]  annotation that can can be attached to a class declaration that derives from  System.Attribute .", 
            "title": "Create AttributeUsage Annotation"
        }, 
        {
            "location": "/code-generation/csharp/#create-base-constructor", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.base_constructor  Generates a class constructor that routes a series of constructor parameters into a  base(...)  constructor.", 
            "title": "Create Base Constructor"
        }, 
        {
            "location": "/code-generation/csharp/#uses", 
            "text": "Create Constructor", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/csharp/#create-class-declaration", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.class_declaration  Generates a new class declaration implementing all provided members, base class constructors, base class abstract invocations and interfaces", 
            "title": "Create Class Declaration"
        }, 
        {
            "location": "/code-generation/csharp/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      ImplementBaseConstructors  Boolean  False  Should the base class constructors be automatically created?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/csharp/#uses_1", 
            "text": "Member Field Generator  Generate Instance Property  Method Generator  Create Base Constructor  Generate Event Handler Declaration", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/csharp/#create-constructor", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.constructor  Generates a class constructor, optionally with a set of arguments.", 
            "title": "Create Constructor"
        }, 
        {
            "location": "/code-generation/csharp/#configurable-properties_1", 
            "text": "Name  Type  Defaults To  Description      ArgumentFirstLetterToLowerCase  Boolean  True  Should all constructor arguments have their first letter forced to lower case?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/csharp/#generate-assignment-expression", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.assignment_expression  Generates an assignment expresssion; eg  this.myField = value;", 
            "title": "Generate Assignment Expression"
        }, 
        {
            "location": "/code-generation/csharp/#configurable-properties_2", 
            "text": "Name  Type  Defaults To  Description      IncludeThisForMembers  Boolean  False  When assigning to a class member, should a  this.  be added to the variable being assigned?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/csharp/#generate-event-handler-declaration", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.event_handler_declaration  Generates an  event EventHandler EventArgs  declaration that can be bound against by a callback.", 
            "title": "Generate Event Handler Declaration"
        }, 
        {
            "location": "/code-generation/csharp/#configurable-properties_3", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : name : The name of the new event handler. event_type : The fully qualified type of the event handler. arguments_type : The fully qualified type of the event arguments.  public event $event_type$ $argument_type$  $name$;  What is the code snippet to use when creating a new event handler?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/csharp/#generate-event-handler-method", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.event_handler_method  Generates a method that's compatible for registration with an  EventHandler EventArgs  as a callback.", 
            "title": "Generate Event Handler Method"
        }, 
        {
            "location": "/code-generation/csharp/#configurable-properties_4", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : name : The name of the new method. type : The fully qualified type of the event arguments.  public void $name$(object sender, $type$ e) {     throw new System.NotImplementedException(); }  What is the code snippet to use when creating the new event handler method declaration?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/csharp/#generate-instance-property", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.instance_property  Generates a instance property with a getter and setter.", 
            "title": "Generate Instance Property"
        }, 
        {
            "location": "/code-generation/csharp/#configurable-properties_5", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : type : The fully qualified type of the new property. name : The name of the new propety. value : The value to assign to the new property.  public $type$ $name$ {     set; }  What is the code snippet to use when creating the property declaration?    ReadOnlySnippet  Code Snippet Arguments : type : The fully qualified type of the new property. name : The name of the new propety. value : The value to assign to the new property.  public $type$ $name$ {     get; }  What is the code snippet to use when creating a readonly property declaration?    WriteOnlySnippet  Code Snippet Arguments : type : The fully qualified type of the new property. name : The name of the new propety. value : The value to assign to the new property.  public $type$ $name$ {     get;     set; }  What is the code snippet to use when creating a write only property declaration?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/csharp/#generate-member-initialiser", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.member_initialiser_expression  Generates an initilisation expression for a class/struct member (such as a property or field).", 
            "title": "Generate Member Initialiser"
        }, 
        {
            "location": "/code-generation/csharp/#configurable-properties_6", 
            "text": "Name  Type  Defaults To  Description      ForceStringLiteral  Boolean  False  Should the code generator always attempt to assign members with a string literal?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/csharp/#member-field-generator", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.field_declaration  Generates member field declarations with an optional value initialisation", 
            "title": "Member Field Generator"
        }, 
        {
            "location": "/code-generation/csharp/#configurable-properties_7", 
            "text": "Name  Type  Defaults To  Description      UnderscoreOnBackingField  Boolean  False  When creating a backing field for a property, should the field have an underscore appended to the start of the field name?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/csharp/#uses_2", 
            "text": "Generate Member Initialiser", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/csharp/#method-generator", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.method_declaration  Generates a new method declaration", 
            "title": "Method Generator"
        }, 
        {
            "location": "/code-generation/csharp/#namespace-declaration", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.namespace_declaration  Generates a new namespace declaration syntax element", 
            "title": "Namespace Declaration"
        }, 
        {
            "location": "/code-generation/csharp/#using-directive-generator", 
            "text": "Configuration Id: com.mfractor.code_gen.csharp.using_directive  Generates a new using directive for the provided namespace", 
            "title": "Using Directive Generator"
        }, 
        {
            "location": "/code-generation/csharp/android/", 
            "text": "Android C# Code Generation\n\n\nAutogenerated by MFractor v3.5.13\n\n\nGenerate UsesLayout Attribute Annotation\n\n\nConfiguration Id: com.mfractor.code_gen.android.csharp.uses_layout_attribute\n\n\nCreates a new \nUsesLayout\n atttribute annotation that can be attached to a class in an Android project to target a specific Android Layout for MFractor layout validation.", 
            "title": "Android (C#)"
        }, 
        {
            "location": "/code-generation/csharp/android/#android-c-code-generation", 
            "text": "Autogenerated by MFractor v3.5.13", 
            "title": "Android C# Code Generation"
        }, 
        {
            "location": "/code-generation/csharp/android/#generate-useslayout-attribute-annotation", 
            "text": "Configuration Id: com.mfractor.code_gen.android.csharp.uses_layout_attribute  Creates a new  UsesLayout  atttribute annotation that can be attached to a class in an Android project to target a specific Android Layout for MFractor layout validation.", 
            "title": "Generate UsesLayout Attribute Annotation"
        }, 
        {
            "location": "/code-generation/xamarin-forms/", 
            "text": "Xamarin.Forms C# Code Generation\n\n\nAutogenerated by MFractor v3.7.3\n\n\nData Template Selector Code Generator\n\n\nConfiguration Id: com.mfractor.code_gen.forms.data_template_selector\n\n\nThe Data Template Selector Code Generator creates a new Xamarin.Forms.DataTemplateSelector that you can fill in.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The namespace that the new DataTemplateSelector should be placed within.\nname\n: The name of the new DataTemplateSelector\n\n\nView Code Snippet\n\n\nThe code snippet for  to insert onto the code behind class to target a design time binding context.\n\n\n\n\n\n\nNamespace\n\n\nSystem.String\n\n\n.DataTemplateSelectors\n\n\nThe\n\n\n\n\n\n\n\n\nDesign Time Binding Context Attribute\n\n\nConfiguration Id: com.mfractor.code_gen.forms.design_time_binding_context_attribute\n\n\nCreates an implementation of the DesignTimeBindingContextAttribute class that can be used to target MFractor towards a binding context for a class where one would normally be unresolved.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAnnotationSnippet\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The namespace that the design time binding context resides inside.\ntype\n: The type to use as the design time binding context.\n\n\n[$namespace$.DesignTimeBindingContext(typeof($type$))]\n\n\nThe annotation to insert onto the code behind class to target a design time binding context.\n\n\n\n\n\n\nDesignTimeBindingContextAttributeFileName\n\n\nSystem.String\n\n\nDesignTimeBindingContextAttribute.cs\n\n\nWhat is the filename to use when creating the design time binding context?\n\n\n\n\n\n\nDesignTimeBindingContextAttributeFolderPath\n\n\nSystem.String\n\n\nAttributes\n\n\nWhat is the project folder path to place the  to use when creating the default design time binding context?\n\n\n\n\n\n\n\n\nGenerate Bindable Property\n\n\nConfiguration Id: com.mfractor.code_gen.forms.csharp.bindable_property\n\n\nGenerates a Xamarin.Forms bindable property implementation and a proxy property that calls the \nBindableProperty\n implementation.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new bindable property.\ntype\n: The type of the new bindable property.\ncontrol_type\n: The control type that the new bindable property has been created inside.\n\n\nView Code Snippet\n\n\nWhen creating the new bindable property, what is the default code snippet MFractor should use?\n\n\n\n\n\n\n\n\nGenerate Custom Renderer For Xamarin.Forms Control\n\n\nConfiguration Id: com.mfractor.code_gen.forms.generate_control_native_renderer\n\n\nFor a given Xamarin.Forms user control in C#, the \nGenerate Custom Renderer For Xamarin.Forms Control\n code action enables you to generate a custom renderer for that control in each iOS and Android project in your solution.\n\n\nUses:\n\n\n\n\nIOS Custom Renderer Code Snippets\n\n\nAndroid Custom Renderer Code Snippets\n\n\n\n\nGenerate ICommand Implementation\n\n\nConfiguration Id: com.mfractor.code_gen.forms.csharp.command_implementation\n\n\nGenerates a boilerplate implementation of ICommand using an inline Xamarin.Forms.Command.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new command.\ntype\n: The fully qualified type of the new command\n\n\nView Code Snippet\n\n\nWhat is the code snippet to use when creating the command stub? If not set, this code generator will default to generating a stub \nXamarin.Forms.Command\n implementation\n\n\n\n\n\n\nCommandType\n\n\nSystem.String\n\n\nXamarin.Forms.Command\n\n\nThe fully qualified type to use as the command implementation. For example, using \nXamarin.Forms.Command\n would cause the new expression to be \nnew Xamarin.Forms.Command\n\n\n\n\n\n\n\n\nGenerate IValueConverter Implementation\n\n\nConfiguration Id: com.mfractor.code_gen.forms.csharp.value_converter\n\n\nGenerates an implementation of a value converter.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCreateMissingValueConversionAttribute\n\n\nBoolean\n\n\nTrue\n\n\nIf an implementation of the ValueConversionAttribute class cannot be resolved within the project compilation, should MFractor automatically create the implementation?\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new value converter.\nnamespace\n: The namespace the new converter will be placed inside.\nvalue_conversion_attribute\n: The fully qualified type of the value conversion attribute (if available).\ninput_type\n: The fully qualified type that the value converter should accept as it's input type. If unavailable, defaults to \nSystem.Object\n.\noutput_type\n: The fully qualified type that the value converter should accept as it's output type. If unavailable, defaults to \nSystem.Object\n.\nparameter_type\n: The fully qualified type that the value converter should accept as it's parameter type. If unavailable, defaults to \nSystem.Object\n.\n\n\nView Code Snippet\n\n\nWhat is the code snippet to use when generating the value converter class file?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Value Conversion Attribute\n\n\nValue Conversion Settings\n\n\n\n\nGenerate Page And View Model\n\n\nConfiguration Id: com.mfractor.code_gen.forms.view_and_view_model\n\n\nGenerates a new ContentPage with an associated view model.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nViewBaseClass\n\n\nSystem.String\n\n\nXamarin.Forms.ContentPage\n\n\nWhat is the default base class that should be used when creating the page and it's code behind?\n\n\n\n\n\n\nViewSuffix\n\n\nSystem.String\n\n\nPage\n\n\nWhat is the suffix to use when creating a new page?\n\n\n\n\n\n\nViewsFolder\n\n\nSystem.String\n\n\nPages\n\n\nWhere should new views be placed?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate View With XAML and Code-Behind Class\n\n\nGenerate New View Model\n\n\nUsing Directive Generator\n\n\nCreate Class Declaration\n\n\nNamespace Declaration\n\n\nMVVM Resolution Settings\n\n\n\n\nGenerate Platform Specific Effect\n\n\nConfiguration Id: com.mfractor.code_gen.forms.csharp.platform_effect\n\n\nGenerates a new effect, creating the effect inside the common project as well as linked Android and iOS projects.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIOSEffectsFolder\n\n\nSystem.String\n\n\nEffects\n\n\nWhat is the folder that iOS platform-specific effects should be placed into?\n\n\n\n\n\n\nAndroidEffectsFolder\n\n\nSystem.String\n\n\nEffects\n\n\nWhat is the folder that Android platform-specific effects should be placed into?\n\n\n\n\n\n\nEffectsFolder\n\n\nSystem.String\n\n\nEffects\n\n\nWhat is the folder that the effects declaration be placed into?\n\n\n\n\n\n\nResolutionGroupName\n\n\nSystem.String\n\n\nEffects\n\n\nWhat is the name of the resolution group?\n\n\n\n\n\n\nIOSEffectSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new effect.\ngroup_name\n: The resolution group name of the new effect.\nnamespace\n: The iOS projects default namespace.\nplatform\n: If you wish to shared the platform-specific effect template, this is the name of the effects platform.\n\n\nView Code Snippet\n\n\nWhat is the code snippet for the iOS platform-specific effect?\n\n\n\n\n\n\nAndroidEffectSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new effect.\ngroup_name\n: The resolution group name of the new effect.\nnamespace\n: The Android projects default namespace.\nplatform\n: If you wish to shared the platform-specific effect template, this is the name of the effects platform.\n\n\nView Code Snippet\n\n\nWhat is the code snippet for the Android platform-specific effect?\n\n\n\n\n\n\nGtkEffectSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new effect.\ngroup_name\n: The resolution group name of the new effect.\nnamespace\n: The GTK projects default namespace.\nplatform\n: If you wish to shared the platform-specific effect template, this is the name of the effects platform.\n\n\nView Code Snippet\n\n\nWhat is the code snippet for the GTK platform-specific effect?\n\n\n\n\n\n\nEffectSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new effect.\ngroup_name\n: The resolution group name of the new effect.\nnamespace\n: The common projects default namespace.\n\n\nView Code Snippet\n\n\nWhat is the code snippet for the effect?\n\n\n\n\n\n\n\n\nGenerate Value Conversion Attribute\n\n\nConfiguration Id: com.mfractor.code_gen.forms.csharp.value_conversion_attribute\n\n\nGenerates an implementation of the \nValueConversionAttribute\n; the attribute used to hint type-flow in a value converter for design time tools like MFractor.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The namespace that the new value conversion attribute should be placed within.\n\n\nView Code Snippet\n\n\nWhat is the default code snippet to use when creating the value conversion attribute implementation?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nValue Conversion Settings\n\n\n\n\nGenerate View With XAML and Code-Behind Class\n\n\nConfiguration Id: com.mfractor.code_gen.forms.xaml_view_with_code_behind\n\n\nCreates a new view/control using a XAML to define the UI and a code-behind class to encapsulate backing logic.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultViewClass\n\n\nSystem.String\n\n\nXamarin.Forms.View\n\n\nWhat is the default class to use when creating new views?\n\n\n\n\n\n\nViewSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new class.\nnamespace\n: The namespace that the new class resides inside.\ntype\n: The base type of the new class.\n\n\n?xml version=\"1.0\" encoding=\"UTF-8\"?\n$type$ xmlns=\"http://xamarin.com/schemas/2014/forms\"\n  xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n  x:Class=\"$namespace$.$name$\"\n\n\nWhat is the default implementation of the new XAML control's XAML file?\n\n\n\n\n\n\nCodeBehindSnippet\n\n\nCode Snippet\nArguments\n:\nname\n: The name of the new class.\nnamespace\n: The namespace that the new class resides inside.\ntype\n: The base type of the new class.\n\n\nView Code Snippet\n\n\nWhat is the default implementation of the new XAML control's code behind class?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nUsing Directive Generator\n\n\nNamespace Declaration\n\n\n\n\nGenerates Xamarin.Forms Cascading Style Sheet\n\n\nConfiguration Id: com.mfractor.code_gen.forms.generate_style_sheet\n\n\nGenerates a new Xamarin.Forms cascading style sheet that can be used to style XAML\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\ncontrol\n: The name of the control that this style sheet is for. EG: \nstackLayout\n, \nentry\n, \nview\n etc\n\n\n$control$  {\n    margin:10;\n}\n\n\nThe default cascading style sheet to use.\n\n\n\n\n\n\nStyleFolder\n\n\nSystem.String\n\n\nStyles\n\n\nWhat is the folder to place new style sheets into?\n\n\n\n\n\n\nDefaultControl\n\n\nSystem.String\n\n\nview\n\n\nWhat is the default control to use when generating new style sheets?\n\n\n\n\n\n\n\n\nString Localisation Generator\n\n\nConfiguration Id: com.mfractor.code_gen.forms.replace_with_localisation_lookup\n\n\nThe string localisation generator converts literal string value inside a XAML document to a localised value lookup. This replaces the text with a localistaion lookup extension and generates a resx entry for the old value.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nTranslateExtensionSymbol\n\n\nSystem.String\n\n\n.i18n.TranslateExtension\n\n\nWhat is the full sybol name (namespace + class name) of the translate markup extension? Prepend the symbol name with a dot to make it relative to the projects default namespace. For example, using \n.Localisation.TranslateExtension\n when the default namespace is \nMyApp\n would cause the full symbol name to become \nMyApp.Localisation.TranslateExtension\n.\n\n\n\n\n\n\nTranslationXamlNamespace\n\n\nSystem.String\n\n\ni18n\n\n\nWhen importing a XAML namespace reference to the translation extension, what is the default namespace name that should be used?\n\n\n\n\n\n\nXamlLocalisationExpression\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The xml namespace for the translate extension symbol when used in XAML.\ntranslate_extension\n: The name of the translation extension that's used to lookup a localised value for a given key.\nkey\n: The key that's used to lookup a localised value in this applications resources.\nresx_name\n: The name of the RESX file to look into for the given key, excluding the \n.resx\n file extension.\n\n\n{$namespace$:$translate_extension$ $key$}\n\n\nWhen importing a XAML namespace reference to the translation extension, what is the default namespace name that should be used?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate ResX Entry\n\n\nDefault Resource File\n\n\nResX Localisation Values Provider\n\n\n\n\nView Model Property Generator\n\n\nConfiguration Id: com.mfractor.code_gen.forms.csharp.view_model_property\n\n\nGenerates a property declaration for a Xamarin.Forms ViewModel. By default, this code generator routes to the standard PropertyGenerator. However, specifying a code snippet will cause the code generator to use that instead.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSnippet\n\n\nCode Snippet\nArguments\n:\ntype\n: The fully qualified type of the new property.\nname\n: The name of the new property.\n\n\npublic $type$ $name$\n{\n    get;\n    set;\n}\n\n\nWhat is the code snippet to use when creating the property declaration?\n\n\n\n\n\n\nValueSnippet\n\n\nCode Snippet\nArguments\n:\ntype\n: The fully qualified type of the new property.\nname\n: The name of the new property.\nvalue\n: The value to assign to the new property.\n\n\npublic $type$ $name$\n{\n    get;\n    set;\n} = $value$;\n\n\nWhat is the code snippet to use when creating a property declaration with a default value?\n\n\n\n\n\n\nDefaultEnumerableType\n\n\nSystem.String\n\n\nSystem.Collections.Generic.List\n\n\nWhen the new view model property is an \nIEnumerable\n, what is the default type that should be used instead of \nIEnumerable\n? To use the provided \nIEnumerable\n type, set this to an empty string.\n\n\n\n\n\n\n\n\nXAML Localisation Infrastructure Generation\n\n\nConfiguration Id: com.mfractor.code_gen.forms.xaml_localisation_infrastructure\n\n\nBuilds the necessary infrustructure needed for XAML localisation using the best practice outlined in \nLocalizing Xamarin.Forms Apps with RESX Resource Files\n.\n\n\nThis code generator will create the following:\n\n\nMyApp.Core\n\n\n\n\ni18n/TranslateExtension.cs\n:\n\n\ni18n/ILocalise.cs\n: The interface that provides the current culture on each platform.\n\n\n\n\nMyApp.iOS\n\n - \nLocalise.cs\n: The iOS implementation of \nILocalise\n to provide iOS's current culture.\n\n\nMyApp.Android\n\n - \nLocalise.cs\n: The Android implementation of \nILocalise\n to provide iOS's current culture.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLocalisationFolder\n\n\nSystem.String\n\n\ni18n\n\n\nWhat is the folder that the translation extension and localiser class should be placed into?\n\n\n\n\n\n\nLocaliserName\n\n\nSystem.String\n\n\nILocale\n\n\nWhat is the name of the class that provides the culture information for translation extension?\n\n\n\n\n\n\nILocaliserSnippet\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The projects namespace\nname\n: The name of the new localiser interface. Defaults to \nILocale\n\n\nView Code Snippet\n\n\nThe code snippet to use for the \nILocalise\n interface that each platform project should implement.\n\n\n\n\n\n\nTranslateExtensionSnippet\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The projects namespace\nname\n: The name of the translation extension class. This will be derived from the string localisation generations \nTranslateExtensionSymbol\n property.\nresource\n: The fully qualified type of the resource file that the translate extension should use when looking for localisation values. This will be provided by the apps default resource file config.\nlocaliser\n: The name of the localisation interface that provides the current culture.\n\n\nView Code Snippet\n\n\nThe code snippet to use for the translation extension.\n\n\n\n\n\n\nAndroidLocaliserClassName\n\n\nSystem.String\n\n\nLocale_Android\n\n\nWhat is the name of the Android localiser class?\n\n\n\n\n\n\nAndroidLocaliseSnippet\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The projects namespace\ni18n_namespace\n: The namespace that the translate extension and ILocale interface live within\nlocaliser\n: The name of the localisation interface that provides the current culture.\n\n\nView Code Snippet\n\n\nThe code snippet to use for the Android implementation of the localization interface to provide the current culture.\n\n\n\n\n\n\nIOSLocaliserClassName\n\n\nSystem.String\n\n\nLocale_iOS\n\n\nWhat is the name of the iOS localiser class?\n\n\n\n\n\n\nIOSLocaliseSnippet\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The projects namespace\ni18n_namespace\n: The namespace that the translate extension and ILocale interface live within\nlocaliser\n: The name of the localisation interface that provides the current culture.\n\n\nView Code Snippet\n\n\nThe code snippet to use for the iOS implementation of the localization interface to provide the current culture.\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nString Localisation Generator\n\n\nDefault Resource File\n\n\nGenerate ResX File", 
            "title": "Xamarin.Forms (C#)"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#xamarinforms-c-code-generation", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "Xamarin.Forms C# Code Generation"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#data-template-selector-code-generator", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.data_template_selector  The Data Template Selector Code Generator creates a new Xamarin.Forms.DataTemplateSelector that you can fill in.", 
            "title": "Data Template Selector Code Generator"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : namespace : The namespace that the new DataTemplateSelector should be placed within. name : The name of the new DataTemplateSelector  View Code Snippet  The code snippet for  to insert onto the code behind class to target a design time binding context.    Namespace  System.String  .DataTemplateSelectors  The", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#design-time-binding-context-attribute", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.design_time_binding_context_attribute  Creates an implementation of the DesignTimeBindingContextAttribute class that can be used to target MFractor towards a binding context for a class where one would normally be unresolved.", 
            "title": "Design Time Binding Context Attribute"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#configurable-properties_1", 
            "text": "Name  Type  Defaults To  Description      AnnotationSnippet  Code Snippet Arguments : namespace : The namespace that the design time binding context resides inside. type : The type to use as the design time binding context.  [$namespace$.DesignTimeBindingContext(typeof($type$))]  The annotation to insert onto the code behind class to target a design time binding context.    DesignTimeBindingContextAttributeFileName  System.String  DesignTimeBindingContextAttribute.cs  What is the filename to use when creating the design time binding context?    DesignTimeBindingContextAttributeFolderPath  System.String  Attributes  What is the project folder path to place the  to use when creating the default design time binding context?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#generate-bindable-property", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.csharp.bindable_property  Generates a Xamarin.Forms bindable property implementation and a proxy property that calls the  BindableProperty  implementation.", 
            "title": "Generate Bindable Property"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#configurable-properties_2", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : name : The name of the new bindable property. type : The type of the new bindable property. control_type : The control type that the new bindable property has been created inside.  View Code Snippet  When creating the new bindable property, what is the default code snippet MFractor should use?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#generate-custom-renderer-for-xamarinforms-control", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.generate_control_native_renderer  For a given Xamarin.Forms user control in C#, the  Generate Custom Renderer For Xamarin.Forms Control  code action enables you to generate a custom renderer for that control in each iOS and Android project in your solution.", 
            "title": "Generate Custom Renderer For Xamarin.Forms Control"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#uses", 
            "text": "IOS Custom Renderer Code Snippets  Android Custom Renderer Code Snippets", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#generate-icommand-implementation", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.csharp.command_implementation  Generates a boilerplate implementation of ICommand using an inline Xamarin.Forms.Command.", 
            "title": "Generate ICommand Implementation"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#configurable-properties_3", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : name : The name of the new command. type : The fully qualified type of the new command  View Code Snippet  What is the code snippet to use when creating the command stub? If not set, this code generator will default to generating a stub  Xamarin.Forms.Command  implementation    CommandType  System.String  Xamarin.Forms.Command  The fully qualified type to use as the command implementation. For example, using  Xamarin.Forms.Command  would cause the new expression to be  new Xamarin.Forms.Command", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#generate-ivalueconverter-implementation", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.csharp.value_converter  Generates an implementation of a value converter.", 
            "title": "Generate IValueConverter Implementation"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#configurable-properties_4", 
            "text": "Name  Type  Defaults To  Description      CreateMissingValueConversionAttribute  Boolean  True  If an implementation of the ValueConversionAttribute class cannot be resolved within the project compilation, should MFractor automatically create the implementation?    Snippet  Code Snippet Arguments : name : The name of the new value converter. namespace : The namespace the new converter will be placed inside. value_conversion_attribute : The fully qualified type of the value conversion attribute (if available). input_type : The fully qualified type that the value converter should accept as it's input type. If unavailable, defaults to  System.Object . output_type : The fully qualified type that the value converter should accept as it's output type. If unavailable, defaults to  System.Object . parameter_type : The fully qualified type that the value converter should accept as it's parameter type. If unavailable, defaults to  System.Object .  View Code Snippet  What is the code snippet to use when generating the value converter class file?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#uses_1", 
            "text": "Generate Value Conversion Attribute  Value Conversion Settings", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#generate-page-and-view-model", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.view_and_view_model  Generates a new ContentPage with an associated view model.", 
            "title": "Generate Page And View Model"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#configurable-properties_5", 
            "text": "Name  Type  Defaults To  Description      ViewBaseClass  System.String  Xamarin.Forms.ContentPage  What is the default base class that should be used when creating the page and it's code behind?    ViewSuffix  System.String  Page  What is the suffix to use when creating a new page?    ViewsFolder  System.String  Pages  Where should new views be placed?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#uses_2", 
            "text": "Generate View With XAML and Code-Behind Class  Generate New View Model  Using Directive Generator  Create Class Declaration  Namespace Declaration  MVVM Resolution Settings", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#generate-platform-specific-effect", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.csharp.platform_effect  Generates a new effect, creating the effect inside the common project as well as linked Android and iOS projects.", 
            "title": "Generate Platform Specific Effect"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#configurable-properties_6", 
            "text": "Name  Type  Defaults To  Description      IOSEffectsFolder  System.String  Effects  What is the folder that iOS platform-specific effects should be placed into?    AndroidEffectsFolder  System.String  Effects  What is the folder that Android platform-specific effects should be placed into?    EffectsFolder  System.String  Effects  What is the folder that the effects declaration be placed into?    ResolutionGroupName  System.String  Effects  What is the name of the resolution group?    IOSEffectSnippet  Code Snippet Arguments : name : The name of the new effect. group_name : The resolution group name of the new effect. namespace : The iOS projects default namespace. platform : If you wish to shared the platform-specific effect template, this is the name of the effects platform.  View Code Snippet  What is the code snippet for the iOS platform-specific effect?    AndroidEffectSnippet  Code Snippet Arguments : name : The name of the new effect. group_name : The resolution group name of the new effect. namespace : The Android projects default namespace. platform : If you wish to shared the platform-specific effect template, this is the name of the effects platform.  View Code Snippet  What is the code snippet for the Android platform-specific effect?    GtkEffectSnippet  Code Snippet Arguments : name : The name of the new effect. group_name : The resolution group name of the new effect. namespace : The GTK projects default namespace. platform : If you wish to shared the platform-specific effect template, this is the name of the effects platform.  View Code Snippet  What is the code snippet for the GTK platform-specific effect?    EffectSnippet  Code Snippet Arguments : name : The name of the new effect. group_name : The resolution group name of the new effect. namespace : The common projects default namespace.  View Code Snippet  What is the code snippet for the effect?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#generate-value-conversion-attribute", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.csharp.value_conversion_attribute  Generates an implementation of the  ValueConversionAttribute ; the attribute used to hint type-flow in a value converter for design time tools like MFractor.", 
            "title": "Generate Value Conversion Attribute"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#configurable-properties_7", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : namespace : The namespace that the new value conversion attribute should be placed within.  View Code Snippet  What is the default code snippet to use when creating the value conversion attribute implementation?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#uses_3", 
            "text": "Value Conversion Settings", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#generate-view-with-xaml-and-code-behind-class", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.xaml_view_with_code_behind  Creates a new view/control using a XAML to define the UI and a code-behind class to encapsulate backing logic.", 
            "title": "Generate View With XAML and Code-Behind Class"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#configurable-properties_8", 
            "text": "Name  Type  Defaults To  Description      DefaultViewClass  System.String  Xamarin.Forms.View  What is the default class to use when creating new views?    ViewSnippet  Code Snippet Arguments : name : The name of the new class. namespace : The namespace that the new class resides inside. type : The base type of the new class.  ?xml version=\"1.0\" encoding=\"UTF-8\"? $type$ xmlns=\"http://xamarin.com/schemas/2014/forms\"   xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"   x:Class=\"$namespace$.$name$\"  What is the default implementation of the new XAML control's XAML file?    CodeBehindSnippet  Code Snippet Arguments : name : The name of the new class. namespace : The namespace that the new class resides inside. type : The base type of the new class.  View Code Snippet  What is the default implementation of the new XAML control's code behind class?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#uses_4", 
            "text": "Using Directive Generator  Namespace Declaration", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#generates-xamarinforms-cascading-style-sheet", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.generate_style_sheet  Generates a new Xamarin.Forms cascading style sheet that can be used to style XAML", 
            "title": "Generates Xamarin.Forms Cascading Style Sheet"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#configurable-properties_9", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : control : The name of the control that this style sheet is for. EG:  stackLayout ,  entry ,  view  etc  $control$  {     margin:10; }  The default cascading style sheet to use.    StyleFolder  System.String  Styles  What is the folder to place new style sheets into?    DefaultControl  System.String  view  What is the default control to use when generating new style sheets?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#string-localisation-generator", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.replace_with_localisation_lookup  The string localisation generator converts literal string value inside a XAML document to a localised value lookup. This replaces the text with a localistaion lookup extension and generates a resx entry for the old value.", 
            "title": "String Localisation Generator"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#configurable-properties_10", 
            "text": "Name  Type  Defaults To  Description      TranslateExtensionSymbol  System.String  .i18n.TranslateExtension  What is the full sybol name (namespace + class name) of the translate markup extension? Prepend the symbol name with a dot to make it relative to the projects default namespace. For example, using  .Localisation.TranslateExtension  when the default namespace is  MyApp  would cause the full symbol name to become  MyApp.Localisation.TranslateExtension .    TranslationXamlNamespace  System.String  i18n  When importing a XAML namespace reference to the translation extension, what is the default namespace name that should be used?    XamlLocalisationExpression  Code Snippet Arguments : namespace : The xml namespace for the translate extension symbol when used in XAML. translate_extension : The name of the translation extension that's used to lookup a localised value for a given key. key : The key that's used to lookup a localised value in this applications resources. resx_name : The name of the RESX file to look into for the given key, excluding the  .resx  file extension.  {$namespace$:$translate_extension$ $key$}  When importing a XAML namespace reference to the translation extension, what is the default namespace name that should be used?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#uses_5", 
            "text": "Generate ResX Entry  Default Resource File  ResX Localisation Values Provider", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#view-model-property-generator", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.csharp.view_model_property  Generates a property declaration for a Xamarin.Forms ViewModel. By default, this code generator routes to the standard PropertyGenerator. However, specifying a code snippet will cause the code generator to use that instead.", 
            "title": "View Model Property Generator"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#configurable-properties_11", 
            "text": "Name  Type  Defaults To  Description      Snippet  Code Snippet Arguments : type : The fully qualified type of the new property. name : The name of the new property.  public $type$ $name$ {     get;     set; }  What is the code snippet to use when creating the property declaration?    ValueSnippet  Code Snippet Arguments : type : The fully qualified type of the new property. name : The name of the new property. value : The value to assign to the new property.  public $type$ $name$ {     get;     set; } = $value$;  What is the code snippet to use when creating a property declaration with a default value?    DefaultEnumerableType  System.String  System.Collections.Generic.List  When the new view model property is an  IEnumerable , what is the default type that should be used instead of  IEnumerable ? To use the provided  IEnumerable  type, set this to an empty string.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#xaml-localisation-infrastructure-generation", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.xaml_localisation_infrastructure  Builds the necessary infrustructure needed for XAML localisation using the best practice outlined in  Localizing Xamarin.Forms Apps with RESX Resource Files .  This code generator will create the following:  MyApp.Core   i18n/TranslateExtension.cs :  i18n/ILocalise.cs : The interface that provides the current culture on each platform.   MyApp.iOS \n -  Localise.cs : The iOS implementation of  ILocalise  to provide iOS's current culture.  MyApp.Android \n -  Localise.cs : The Android implementation of  ILocalise  to provide iOS's current culture.", 
            "title": "XAML Localisation Infrastructure Generation"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#configurable-properties_12", 
            "text": "Name  Type  Defaults To  Description      LocalisationFolder  System.String  i18n  What is the folder that the translation extension and localiser class should be placed into?    LocaliserName  System.String  ILocale  What is the name of the class that provides the culture information for translation extension?    ILocaliserSnippet  Code Snippet Arguments : namespace : The projects namespace name : The name of the new localiser interface. Defaults to  ILocale  View Code Snippet  The code snippet to use for the  ILocalise  interface that each platform project should implement.    TranslateExtensionSnippet  Code Snippet Arguments : namespace : The projects namespace name : The name of the translation extension class. This will be derived from the string localisation generations  TranslateExtensionSymbol  property. resource : The fully qualified type of the resource file that the translate extension should use when looking for localisation values. This will be provided by the apps default resource file config. localiser : The name of the localisation interface that provides the current culture.  View Code Snippet  The code snippet to use for the translation extension.    AndroidLocaliserClassName  System.String  Locale_Android  What is the name of the Android localiser class?    AndroidLocaliseSnippet  Code Snippet Arguments : namespace : The projects namespace i18n_namespace : The namespace that the translate extension and ILocale interface live within localiser : The name of the localisation interface that provides the current culture.  View Code Snippet  The code snippet to use for the Android implementation of the localization interface to provide the current culture.    IOSLocaliserClassName  System.String  Locale_iOS  What is the name of the iOS localiser class?    IOSLocaliseSnippet  Code Snippet Arguments : namespace : The projects namespace i18n_namespace : The namespace that the translate extension and ILocale interface live within localiser : The name of the localisation interface that provides the current culture.  View Code Snippet  The code snippet to use for the iOS implementation of the localization interface to provide the current culture.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xamarin-forms/#uses_6", 
            "text": "String Localisation Generator  Default Resource File  Generate ResX File", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/linker/", 
            "text": "Linker Code Generation\n\n\nAutogenerated by MFractor v3.7.3\n\n\nLinker File Generation\n\n\nConfiguration Id: com.mfractor.code_gen.linker.linker_file\n\n\nThe linker file generator can create a new linker file for an Android or iOS project. It can also add new symbols to an existing linker file\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultLinkerFileName\n\n\nSystem.String\n\n\nlinker.xml\n\n\nWhen creating a new linker file for iOS and Android projects, what is it's name?\n\n\n\n\n\n\nDefaultLinkerFileFolder\n\n\nSystem.String\n\n\nProperties\n\n\nWhen creating a new linker file for iOS and Android projects, which folder should it be placed within?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nLinker XML Generator\n\n\n\n\nLinker XML Generator\n\n\nConfiguration Id: com.mfractor.code_gen.linker.linker_entry\n\n\nThe Linker XML generator can create linker XML entries", 
            "title": "Linker"
        }, 
        {
            "location": "/code-generation/linker/#linker-code-generation", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "Linker Code Generation"
        }, 
        {
            "location": "/code-generation/linker/#linker-file-generation", 
            "text": "Configuration Id: com.mfractor.code_gen.linker.linker_file  The linker file generator can create a new linker file for an Android or iOS project. It can also add new symbols to an existing linker file", 
            "title": "Linker File Generation"
        }, 
        {
            "location": "/code-generation/linker/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      DefaultLinkerFileName  System.String  linker.xml  When creating a new linker file for iOS and Android projects, what is it's name?    DefaultLinkerFileFolder  System.String  Properties  When creating a new linker file for iOS and Android projects, which folder should it be placed within?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/linker/#uses", 
            "text": "Linker XML Generator", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/linker/#linker-xml-generator", 
            "text": "Configuration Id: com.mfractor.code_gen.linker.linker_entry  The Linker XML generator can create linker XML entries", 
            "title": "Linker XML Generator"
        }, 
        {
            "location": "/code-generation/xaml/", 
            "text": "XAML Code Generation\n\n\nAutogenerated by MFractor v3.7.3\n\n\nGenerate Grid\n\n\nConfiguration Id: com.mfractor.code_gen.forms.xaml.grid\n\n\nGenerates a new \nGrid\n XAML element.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIncludeColumnDefinitions\n\n\nBoolean\n\n\nTrue\n\n\nShould the new grid include a \nColumnDefinitions\n element by default?\n\n\n\n\n\n\nIncludeRowDefinitions\n\n\nBoolean\n\n\nTrue\n\n\nShould the new grid include a \nRowDefinitions\n element by default?\n\n\n\n\n\n\nDefaultRowsCount\n\n\nInteger\n\n\n1\n\n\nWhat is the default amount of rows that the new grid should have?\n\n\n\n\n\n\nDefaultColumnsCount\n\n\nInteger\n\n\n1\n\n\nWhat is the default amount of columns that the new grid should have?\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate Grid Row Definition\n\n\nGenerate Grid Column Definition\n\n\n\n\nGenerate Grid Column Definition\n\n\nConfiguration Id: com.mfractor.code_gen.forms.xaml.grid_column_definition\n\n\nGenerates a \nColumnDefinition\n Xaml node that is used inside a \nGrid.ColumnDefinitions\n node.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultWidthValue\n\n\nSystem.String\n\n\n*\n\n\nWhen creating a new \nColumnDefinition\n for a grid, what is the default width value.\n\n\n\n\n\n\n\n\nGenerate Grid Row Definition\n\n\nConfiguration Id: com.mfractor.code_gen.forms.xaml.grid_row_definition\n\n\nGenerates a \nRowDefinition\n Xaml node that is used inside a \nGrid.RowDefinitions\n node.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDefaultHeightValue\n\n\nSystem.String\n\n\n*\n\n\nWhen creating a new \nRowDefinition\n for a grid, what is the default height of a newly created row?\n\n\n\n\n\n\n\n\nRename Xaml Namespace Generator\n\n\nConfiguration Id: com.mfractor.code_gen.forms.xaml.rename_xaml_namespace\n\n\nGenerates a series of replace text fixes to rename a namespace\n\n\nRename XAML Node\n\n\nConfiguration Id: com.mfractor.code_gen.xaml.change_element_type\n\n\nThis code generator will create a list of responses that converts the opening and closing tags, property setters and triggers to the new type.", 
            "title": "Xaml"
        }, 
        {
            "location": "/code-generation/xaml/#xaml-code-generation", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "XAML Code Generation"
        }, 
        {
            "location": "/code-generation/xaml/#generate-grid", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.xaml.grid  Generates a new  Grid  XAML element.", 
            "title": "Generate Grid"
        }, 
        {
            "location": "/code-generation/xaml/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      IncludeColumnDefinitions  Boolean  True  Should the new grid include a  ColumnDefinitions  element by default?    IncludeRowDefinitions  Boolean  True  Should the new grid include a  RowDefinitions  element by default?    DefaultRowsCount  Integer  1  What is the default amount of rows that the new grid should have?    DefaultColumnsCount  Integer  1  What is the default amount of columns that the new grid should have?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xaml/#uses", 
            "text": "Generate Grid Row Definition  Generate Grid Column Definition", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/xaml/#generate-grid-column-definition", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.xaml.grid_column_definition  Generates a  ColumnDefinition  Xaml node that is used inside a  Grid.ColumnDefinitions  node.", 
            "title": "Generate Grid Column Definition"
        }, 
        {
            "location": "/code-generation/xaml/#configurable-properties_1", 
            "text": "Name  Type  Defaults To  Description      DefaultWidthValue  System.String  *  When creating a new  ColumnDefinition  for a grid, what is the default width value.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xaml/#generate-grid-row-definition", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.xaml.grid_row_definition  Generates a  RowDefinition  Xaml node that is used inside a  Grid.RowDefinitions  node.", 
            "title": "Generate Grid Row Definition"
        }, 
        {
            "location": "/code-generation/xaml/#configurable-properties_2", 
            "text": "Name  Type  Defaults To  Description      DefaultHeightValue  System.String  *  When creating a new  RowDefinition  for a grid, what is the default height of a newly created row?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/xaml/#rename-xaml-namespace-generator", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.xaml.rename_xaml_namespace  Generates a series of replace text fixes to rename a namespace", 
            "title": "Rename Xaml Namespace Generator"
        }, 
        {
            "location": "/code-generation/xaml/#rename-xaml-node", 
            "text": "Configuration Id: com.mfractor.code_gen.xaml.change_element_type  This code generator will create a list of responses that converts the opening and closing tags, property setters and triggers to the new type.", 
            "title": "Rename XAML Node"
        }, 
        {
            "location": "/code-generation/resx/", 
            "text": "ResX Code Generation\n\n\nAutogenerated by MFractor v3.7.3\n\n\nGenerate C# ResX Resource Lookup\n\n\nConfiguration Id: com.mfractor.code_gen.resx.generate_csharp_resx_lookup\n\n\nGenerates C# resource lookup such as \nMyApp.Resources.Resources.MyLabel\n\n\nGenerate ResX Entry\n\n\nConfiguration Id: com.mfractor.code_gen.resx.generate_resx_entry\n\n\nGenerates a single ResX resource entry element containing the key, value and comment.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIncludeCommentWhenEmpty\n\n\nBoolean\n\n\nFalse\n\n\nWhen no comment for the new ResX entry has been provided, should an empty comment tag be included?\n\n\n\n\n\n\n\n\nGenerate ResX File\n\n\nConfiguration Id: com.mfractor.code_gen.resx.resx_file\n\n\nGenerates a new ResX file\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nResXTemplate\n\n\nCode Snippet\nArguments\n:\nvalues\n: The values to insert\n\n\nView Code Snippet\n\n\nThe default .resx file template.\n\n\n\n\n\n\nResXDesignerTemplate\n\n\nCode Snippet\nArguments\n:\nnamespace\n: The namespace of the \n\n\nView Code Snippet\n\n\nThe default designer file template for a .resx resource.\n\n\n\n\n\n\n\n\nUses:\n\n\n\n\nGenerate ResX Entry", 
            "title": "ResX"
        }, 
        {
            "location": "/code-generation/resx/#resx-code-generation", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "ResX Code Generation"
        }, 
        {
            "location": "/code-generation/resx/#generate-c-resx-resource-lookup", 
            "text": "Configuration Id: com.mfractor.code_gen.resx.generate_csharp_resx_lookup  Generates C# resource lookup such as  MyApp.Resources.Resources.MyLabel", 
            "title": "Generate C# ResX Resource Lookup"
        }, 
        {
            "location": "/code-generation/resx/#generate-resx-entry", 
            "text": "Configuration Id: com.mfractor.code_gen.resx.generate_resx_entry  Generates a single ResX resource entry element containing the key, value and comment.", 
            "title": "Generate ResX Entry"
        }, 
        {
            "location": "/code-generation/resx/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      IncludeCommentWhenEmpty  Boolean  False  When no comment for the new ResX entry has been provided, should an empty comment tag be included?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/resx/#generate-resx-file", 
            "text": "Configuration Id: com.mfractor.code_gen.resx.resx_file  Generates a new ResX file", 
            "title": "Generate ResX File"
        }, 
        {
            "location": "/code-generation/resx/#configurable-properties_1", 
            "text": "Name  Type  Defaults To  Description      ResXTemplate  Code Snippet Arguments : values : The values to insert  View Code Snippet  The default .resx file template.    ResXDesignerTemplate  Code Snippet Arguments : namespace : The namespace of the   View Code Snippet  The default designer file template for a .resx resource.", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/code-generation/resx/#uses", 
            "text": "Generate ResX Entry", 
            "title": "Uses:"
        }, 
        {
            "location": "/code-generation/xml/", 
            "text": "XML Code Generation\n\n\nAutogenerated by MFractor v3.7.3\n\n\nSort Attributes\n\n\nConfiguration Id: com.mfractor.code_gen.forms.xml.sorted_attributes\n\n\nGiven a collection of XML attributes this code generator sorts them by namespace and name.", 
            "title": "XML"
        }, 
        {
            "location": "/code-generation/xml/#xml-code-generation", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "XML Code Generation"
        }, 
        {
            "location": "/code-generation/xml/#sort-attributes", 
            "text": "Configuration Id: com.mfractor.code_gen.forms.xml.sorted_attributes  Given a collection of XML attributes this code generator sorts them by namespace and name.", 
            "title": "Sort Attributes"
        }, 
        {
            "location": "/code-completion/xaml/", 
            "text": "XAML IntelliSense\n\n\nAutogenerated by MFractor v3.7.3\n\n\nAttached Property Completions\n\n\nProvides completion support for attached properties in XAML IntelliSense\n\n\nBinding Context Property Completion\n\n\n\n\nWhen the binding context at the IntelliSense location can be resolved, provides suggestions of available properties on that binding context. After choosing the binding context, MFractor inserts a \n{Binding MyProperty}\n expression into the XAML.\n\n\nCascading Style Sheet Completions\n\n\nProvides cascading style sheet resource suggestions into the XAML IntelliSense engine.\n\n\nColor Picker IntelliSense Code Action\n\n\n\n\nWhen editing a color in XAML, this code action opens the color picker, enabling you to visually choose the color you would like to use.\n\n\nColor Suggestions Completions\n\n\n\n\nSuggests available colors from the \nXamarin.Forms.Color\n type. This is a significantly expanded choice of colors from the default XAML IntelliSense.\n\n\nColumnDefinition Completion\n\n\nWhen editing Grid.ColumnDefinitions this code completion inserts a ColumnDefinition with an automatically generated Width attribute.\n\n\nEvent Completion\n\n\nSuggests event handlers for XAML symbol.\n\n\nGenerate Binding Context Command Completion\n\n\n\n\nWhen a binding context can be resolved at the current IntelliSense location and the user is editing a property that accepts an \nICommand\n, this completion will generate a new command implementation onto the binding context and insert a \n{Binding MyCommand}\n expression in the XAML.\n\n\nGenerate Effect Completion\n\n\nWhen editing inside a \nView.Effects\n property setter node, this completion will generate a new \nRoutingEffect\n inside the shared code project and a \nPlatformEffect\n in iOS and Android projects.\n\n\nGenerate Event Handler Completion\n\n\nWhen the attribute at the current IntelliSense location is an event handler, this code completion will generate a new event handler in the code behind class for the XAML file.\n\n\nGenerate Value Converter Resource Completion\n\n\n\n\nWhen editing inside a \nResourceDictionary\n, this completion will let's you create a new IValueConverter implementation.\n\n\nGenerate View Model Property Completion\n\n\n\n\nWhen a binding context can be resolved at the current IntelliSense location and the user is editing a bindable property, this completion will generate a new property implementation (using any code snippet configuration) onto the binding context and insert a \n{Binding MyProperty}\n expression in the XAML.\n\n\nGesture Recogiser Completion\n\n\nWhen editing XAML files, MFractor will suggest the available types within a users solutions. For example, \nView\ns, \nTrigger\ns, \nGestureRecognizer\ns etc.\n\n\nGrid ColumnSpan Completion\n\n\n\n\nWhen editing inside a \nGrid.ColumnSpan\n attribute, MFractor will suggests columns spans that are valid as defined in the \nGrid.ColumnDefinitions\n for the grid.\n\n\nGrid Row Completion\n\n\n\n\nWhen editing inside a \nGrid.Row\n attribute, MFractor suggests the available row indices definited in the \nGrid.RowDefinitions\n for the grid.\n\n\nGrid RowSpan Completion\n\n\n\n\nWhen editing inside a \nGrid.RowSpan\n attribute, MFractor will suggests rows spans that are valid as defined in the \nGrid.RowDefinitions\n for the grid.\n\n\nImage Asset Completion\n\n\n\n\nWhen editing the \nSource\n attribute for an \nImage\n view or any \nImage\n subclass, this completion suggests the available image assets in the Android and iOS projects.\n\n\nImport Image Completion\n\n\nWhen editing the \nSource\n attribute for an \nImage\n view or any \nImage\n view subclass, this completion will open the image importing wizard. Using the image wizard developers can very quickly import new image resources into their iOS and Android apps, generating the downscaled image sizes and placing all image assets into the appropriate folders.\n\n\nImport Type Completion\n\n\nWhen the XAML element can be resolved to a type in a namespace or assembly that isn't referenced by this XAML file, this completion lets you choose a new xml namespace name for it and create the xmlns import to resolve this symbol.\n\n\nImport Xml Namespace Completion\n\n\n\n\nWhen creating a new xmlns declaration, this IntelliSense completion suggests all available namespaces and assemblies, creating the full xmlns statement to reference that namespace and assembly when actioned.\n\n\nMarkup Extension Property Completion\n\n\nWhen editing inside a XAML markup expression, MFractor will suggest the available properties for the current markup extension.\n\n\nMarkup Extension Type Completion\n\n\nWhen editing XAML markup extension expressions, MFractor will suggest all available IMarkupExtensions based on the namespaces in the current XAML document.\n\n\nRename Element Completion\n\n\n\n\nWhen you change the opening tag of XAML symbol, MFractor will automatically update it's closing tag and all its children!\n\n\nReserved Markup Extension Completion\n\n\nWhen editing XAML markup extension expressions, MFractor will suggest all the common markup extension that are defined by the Xamarin.Forms and Microsoft schemas.\n\n\nThis includes the following markup extensions:\n\n\nXamarin.Forms Markup Extensions\n\n\n\n\nXamarin.Forms.Xaml.ArrayExtension\n: The Array markup extension allows you to define an array in markup\n\n\nXamarin.Forms.Xaml.BindingExtension\n: Creates a data-binding between this visual elements binding context and this bindable property.\n\n\nXamarin.Forms.ConstraintExpression\n: Defines a constraint relationship.\n\n\nXamarin.Forms.Xaml.DynamicResourceExtension\n: The DynamicResource markup extension is similar to the StaticResource markup extension in that both use a dictionary key to fetch a value from a ResourceDictionary. However, while the StaticResource performs a single dictionary lookup, the DynamicResource maintains a link to the dictionary key. Therefore, if the dictionary entry associated with the key is replaced, the change is applied to the visual element. This enables runtime style changes to be made in an application.\n\n\nXamarin.Forms.Xaml.NullExtension\n: A markup extension class that differentiates between null values and empty strings.\n\n\nXamarin.Forms.Xaml.ReferenceExtension\n: A markup extension for referring to other XAML-defined types.\n\n\nXamarin.Forms.Xaml.StaticExtension\n: A markup extension that gets a static member value.\n\n\nXamarin.Forms.Xaml.StaticResourceExtension\n: A markup extension that gets a static static resource value from this views resource dictionary, any referenced resource dictionaries or the App.xaml.\n\n\nXamarin.Forms.Xaml.TemplateBindingExtension\n: Binds a template property to the parent of the view that owns a ControlTemplate.\n\n\nXamarin.Forms.Xaml.TypeExtension\n: The Type markup extension is the XAML equivalent of the C# typeof keyword.\n\n\nXamarin.Forms.Xaml.OnIdiomExtension\n: A markup extension for applying idiom-specific values. \nSee here\n\n\nXamarin.Forms.Xaml.OnPlatformExtension\n: A markup extension for applying platform-specific values. \nSee here\n\n\n\n\nMicrosoft Markup Extensions\n\n\n\n\nx:Array\n: The x:Array markup extension allows you to define an array in markup\n\n\nx:Binding\n: Creates a data-binding between this visual elements binding context and this bindable property.\n\n\nx:DynamicResource\n: The DynamicResource markup extension is similar to the StaticResource markup extension in that both use a dictionary key to fetch a value from a ResourceDictionary. However, while the StaticResource performs a single dictionary lookup, the DynamicResource maintains a link to the dictionary key. Therefore, if the dictionary entry associated with the key is replaced, the change is applied to the visual element. This enables runtime style changes to be made in an application.\n\n\nx:Null\n: A markup extension class that differentiates between null values and empty strings.\n\n\nx:Reference\n: A markup extension for referring to other XAML-defined types.\n\n\nx:Static\n: A markup extension that gets a static member value.\n\n\nx:StaticResource\n: A markup extension that gets a static static resource value from this views resource dictionary, any referenced resource dictionaries or the App.xaml.\n\n\nx:TemplateBinding\n: Binds a template property to the parent of the view that owns a ControlTemplate.\n\n\nx:Type\n: The x:Type markup extension is the XAML equivalent of the C# typeof keyword.\n\n\n\n\nFor more information on markup extensions, see \nXAML Markup Extensions\n.\n\n\nRowDefinition Completion\n\n\nWhen editing Grid.RowDefinitions this code completion inserts a RowDefinition with an automatically generated Height attribute.\n\n\nSelect Image Asset Completion\n\n\n\n\nWhen editing the \nSource\n attribute for an \nImage\n view or any \nImage\n view subclass, this completion will open the image browser view so that you can visually choose the image you'd like to use.\n\n\nSetter Property Shorthand Completion\n\n\n\n\nWhen editing inside a style and you wish to create a new Setter, MFractor will discover the outer target type for the style, trigger or visual state and suggest the properties that can be used inside a setter. When a setter property completion is triggered, MFractor inserts the setter as \nSetter Property=\"TheProperty\" Value=\"\"/\n and then centers the caret inside the value attribute.\n\n\nStatic Resource Completion\n\n\nProvides auto-completion support for Xamarin.Forms static resources defined in the current file, referenced resource dictionaries and the app.xaml.\n\n\nTrigger Completion\n\n\n\n\nWhen editing XAML within a \nView.Trigger\n property assignment, MFractor suggests all available \nXamarin.Forms.Trigger\ns within the namespaces in the current document. For example, \nMultiTrigger\n, \nTrigger\n, \nDataTrigger\n etc.\n\n\nType Symbol Completion\n\n\nWhen editing XAML files, MFractor will suggest the available types within a users solutions. For example, \nView\ns, \nTrigger\ns, \nGestureRecognizer\ns etc.\n\n\nx:Reference Value Completion\n\n\n\n\nWhen editing an \nx:Reference\n XAML markup expression, MFractor will suggest all available XAML elements that have an \nx:Name\n attribute inside the current XAML document.\n\n\nx:Static Namespace Completion\n\n\n\n\nWhen editing an \nx:Static\n XAML markup expression, MFractor will suggest all available XAML namespaces defined by the current XAML document.", 
            "title": "XAML IntelliSense"
        }, 
        {
            "location": "/code-completion/xaml/#xaml-intellisense", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "XAML IntelliSense"
        }, 
        {
            "location": "/code-completion/xaml/#attached-property-completions", 
            "text": "Provides completion support for attached properties in XAML IntelliSense", 
            "title": "Attached Property Completions"
        }, 
        {
            "location": "/code-completion/xaml/#binding-context-property-completion", 
            "text": "When the binding context at the IntelliSense location can be resolved, provides suggestions of available properties on that binding context. After choosing the binding context, MFractor inserts a  {Binding MyProperty}  expression into the XAML.", 
            "title": "Binding Context Property Completion"
        }, 
        {
            "location": "/code-completion/xaml/#cascading-style-sheet-completions", 
            "text": "Provides cascading style sheet resource suggestions into the XAML IntelliSense engine.", 
            "title": "Cascading Style Sheet Completions"
        }, 
        {
            "location": "/code-completion/xaml/#color-picker-intellisense-code-action", 
            "text": "When editing a color in XAML, this code action opens the color picker, enabling you to visually choose the color you would like to use.", 
            "title": "Color Picker IntelliSense Code Action"
        }, 
        {
            "location": "/code-completion/xaml/#color-suggestions-completions", 
            "text": "Suggests available colors from the  Xamarin.Forms.Color  type. This is a significantly expanded choice of colors from the default XAML IntelliSense.", 
            "title": "Color Suggestions Completions"
        }, 
        {
            "location": "/code-completion/xaml/#columndefinition-completion", 
            "text": "When editing Grid.ColumnDefinitions this code completion inserts a ColumnDefinition with an automatically generated Width attribute.", 
            "title": "ColumnDefinition Completion"
        }, 
        {
            "location": "/code-completion/xaml/#event-completion", 
            "text": "Suggests event handlers for XAML symbol.", 
            "title": "Event Completion"
        }, 
        {
            "location": "/code-completion/xaml/#generate-binding-context-command-completion", 
            "text": "When a binding context can be resolved at the current IntelliSense location and the user is editing a property that accepts an  ICommand , this completion will generate a new command implementation onto the binding context and insert a  {Binding MyCommand}  expression in the XAML.", 
            "title": "Generate Binding Context Command Completion"
        }, 
        {
            "location": "/code-completion/xaml/#generate-effect-completion", 
            "text": "When editing inside a  View.Effects  property setter node, this completion will generate a new  RoutingEffect  inside the shared code project and a  PlatformEffect  in iOS and Android projects.", 
            "title": "Generate Effect Completion"
        }, 
        {
            "location": "/code-completion/xaml/#generate-event-handler-completion", 
            "text": "When the attribute at the current IntelliSense location is an event handler, this code completion will generate a new event handler in the code behind class for the XAML file.", 
            "title": "Generate Event Handler Completion"
        }, 
        {
            "location": "/code-completion/xaml/#generate-value-converter-resource-completion", 
            "text": "When editing inside a  ResourceDictionary , this completion will let's you create a new IValueConverter implementation.", 
            "title": "Generate Value Converter Resource Completion"
        }, 
        {
            "location": "/code-completion/xaml/#generate-view-model-property-completion", 
            "text": "When a binding context can be resolved at the current IntelliSense location and the user is editing a bindable property, this completion will generate a new property implementation (using any code snippet configuration) onto the binding context and insert a  {Binding MyProperty}  expression in the XAML.", 
            "title": "Generate View Model Property Completion"
        }, 
        {
            "location": "/code-completion/xaml/#gesture-recogiser-completion", 
            "text": "When editing XAML files, MFractor will suggest the available types within a users solutions. For example,  View s,  Trigger s,  GestureRecognizer s etc.", 
            "title": "Gesture Recogiser Completion"
        }, 
        {
            "location": "/code-completion/xaml/#grid-columnspan-completion", 
            "text": "When editing inside a  Grid.ColumnSpan  attribute, MFractor will suggests columns spans that are valid as defined in the  Grid.ColumnDefinitions  for the grid.", 
            "title": "Grid ColumnSpan Completion"
        }, 
        {
            "location": "/code-completion/xaml/#grid-row-completion", 
            "text": "When editing inside a  Grid.Row  attribute, MFractor suggests the available row indices definited in the  Grid.RowDefinitions  for the grid.", 
            "title": "Grid Row Completion"
        }, 
        {
            "location": "/code-completion/xaml/#grid-rowspan-completion", 
            "text": "When editing inside a  Grid.RowSpan  attribute, MFractor will suggests rows spans that are valid as defined in the  Grid.RowDefinitions  for the grid.", 
            "title": "Grid RowSpan Completion"
        }, 
        {
            "location": "/code-completion/xaml/#image-asset-completion", 
            "text": "When editing the  Source  attribute for an  Image  view or any  Image  subclass, this completion suggests the available image assets in the Android and iOS projects.", 
            "title": "Image Asset Completion"
        }, 
        {
            "location": "/code-completion/xaml/#import-image-completion", 
            "text": "When editing the  Source  attribute for an  Image  view or any  Image  view subclass, this completion will open the image importing wizard. Using the image wizard developers can very quickly import new image resources into their iOS and Android apps, generating the downscaled image sizes and placing all image assets into the appropriate folders.", 
            "title": "Import Image Completion"
        }, 
        {
            "location": "/code-completion/xaml/#import-type-completion", 
            "text": "When the XAML element can be resolved to a type in a namespace or assembly that isn't referenced by this XAML file, this completion lets you choose a new xml namespace name for it and create the xmlns import to resolve this symbol.", 
            "title": "Import Type Completion"
        }, 
        {
            "location": "/code-completion/xaml/#import-xml-namespace-completion", 
            "text": "When creating a new xmlns declaration, this IntelliSense completion suggests all available namespaces and assemblies, creating the full xmlns statement to reference that namespace and assembly when actioned.", 
            "title": "Import Xml Namespace Completion"
        }, 
        {
            "location": "/code-completion/xaml/#markup-extension-property-completion", 
            "text": "When editing inside a XAML markup expression, MFractor will suggest the available properties for the current markup extension.", 
            "title": "Markup Extension Property Completion"
        }, 
        {
            "location": "/code-completion/xaml/#markup-extension-type-completion", 
            "text": "When editing XAML markup extension expressions, MFractor will suggest all available IMarkupExtensions based on the namespaces in the current XAML document.", 
            "title": "Markup Extension Type Completion"
        }, 
        {
            "location": "/code-completion/xaml/#rename-element-completion", 
            "text": "When you change the opening tag of XAML symbol, MFractor will automatically update it's closing tag and all its children!", 
            "title": "Rename Element Completion"
        }, 
        {
            "location": "/code-completion/xaml/#reserved-markup-extension-completion", 
            "text": "When editing XAML markup extension expressions, MFractor will suggest all the common markup extension that are defined by the Xamarin.Forms and Microsoft schemas.  This includes the following markup extensions:  Xamarin.Forms Markup Extensions   Xamarin.Forms.Xaml.ArrayExtension : The Array markup extension allows you to define an array in markup  Xamarin.Forms.Xaml.BindingExtension : Creates a data-binding between this visual elements binding context and this bindable property.  Xamarin.Forms.ConstraintExpression : Defines a constraint relationship.  Xamarin.Forms.Xaml.DynamicResourceExtension : The DynamicResource markup extension is similar to the StaticResource markup extension in that both use a dictionary key to fetch a value from a ResourceDictionary. However, while the StaticResource performs a single dictionary lookup, the DynamicResource maintains a link to the dictionary key. Therefore, if the dictionary entry associated with the key is replaced, the change is applied to the visual element. This enables runtime style changes to be made in an application.  Xamarin.Forms.Xaml.NullExtension : A markup extension class that differentiates between null values and empty strings.  Xamarin.Forms.Xaml.ReferenceExtension : A markup extension for referring to other XAML-defined types.  Xamarin.Forms.Xaml.StaticExtension : A markup extension that gets a static member value.  Xamarin.Forms.Xaml.StaticResourceExtension : A markup extension that gets a static static resource value from this views resource dictionary, any referenced resource dictionaries or the App.xaml.  Xamarin.Forms.Xaml.TemplateBindingExtension : Binds a template property to the parent of the view that owns a ControlTemplate.  Xamarin.Forms.Xaml.TypeExtension : The Type markup extension is the XAML equivalent of the C# typeof keyword.  Xamarin.Forms.Xaml.OnIdiomExtension : A markup extension for applying idiom-specific values.  See here  Xamarin.Forms.Xaml.OnPlatformExtension : A markup extension for applying platform-specific values.  See here   Microsoft Markup Extensions   x:Array : The x:Array markup extension allows you to define an array in markup  x:Binding : Creates a data-binding between this visual elements binding context and this bindable property.  x:DynamicResource : The DynamicResource markup extension is similar to the StaticResource markup extension in that both use a dictionary key to fetch a value from a ResourceDictionary. However, while the StaticResource performs a single dictionary lookup, the DynamicResource maintains a link to the dictionary key. Therefore, if the dictionary entry associated with the key is replaced, the change is applied to the visual element. This enables runtime style changes to be made in an application.  x:Null : A markup extension class that differentiates between null values and empty strings.  x:Reference : A markup extension for referring to other XAML-defined types.  x:Static : A markup extension that gets a static member value.  x:StaticResource : A markup extension that gets a static static resource value from this views resource dictionary, any referenced resource dictionaries or the App.xaml.  x:TemplateBinding : Binds a template property to the parent of the view that owns a ControlTemplate.  x:Type : The x:Type markup extension is the XAML equivalent of the C# typeof keyword.   For more information on markup extensions, see  XAML Markup Extensions .", 
            "title": "Reserved Markup Extension Completion"
        }, 
        {
            "location": "/code-completion/xaml/#rowdefinition-completion", 
            "text": "When editing Grid.RowDefinitions this code completion inserts a RowDefinition with an automatically generated Height attribute.", 
            "title": "RowDefinition Completion"
        }, 
        {
            "location": "/code-completion/xaml/#select-image-asset-completion", 
            "text": "When editing the  Source  attribute for an  Image  view or any  Image  view subclass, this completion will open the image browser view so that you can visually choose the image you'd like to use.", 
            "title": "Select Image Asset Completion"
        }, 
        {
            "location": "/code-completion/xaml/#setter-property-shorthand-completion", 
            "text": "When editing inside a style and you wish to create a new Setter, MFractor will discover the outer target type for the style, trigger or visual state and suggest the properties that can be used inside a setter. When a setter property completion is triggered, MFractor inserts the setter as  Setter Property=\"TheProperty\" Value=\"\"/  and then centers the caret inside the value attribute.", 
            "title": "Setter Property Shorthand Completion"
        }, 
        {
            "location": "/code-completion/xaml/#static-resource-completion", 
            "text": "Provides auto-completion support for Xamarin.Forms static resources defined in the current file, referenced resource dictionaries and the app.xaml.", 
            "title": "Static Resource Completion"
        }, 
        {
            "location": "/code-completion/xaml/#trigger-completion", 
            "text": "When editing XAML within a  View.Trigger  property assignment, MFractor suggests all available  Xamarin.Forms.Trigger s within the namespaces in the current document. For example,  MultiTrigger ,  Trigger ,  DataTrigger  etc.", 
            "title": "Trigger Completion"
        }, 
        {
            "location": "/code-completion/xaml/#type-symbol-completion", 
            "text": "When editing XAML files, MFractor will suggest the available types within a users solutions. For example,  View s,  Trigger s,  GestureRecognizer s etc.", 
            "title": "Type Symbol Completion"
        }, 
        {
            "location": "/code-completion/xaml/#xreference-value-completion", 
            "text": "When editing an  x:Reference  XAML markup expression, MFractor will suggest all available XAML elements that have an  x:Name  attribute inside the current XAML document.", 
            "title": "x:Reference Value Completion"
        }, 
        {
            "location": "/code-completion/xaml/#xstatic-namespace-completion", 
            "text": "When editing an  x:Static  XAML markup expression, MFractor will suggest all available XAML namespaces defined by the current XAML document.", 
            "title": "x:Static Namespace Completion"
        }, 
        {
            "location": "/localisation/", 
            "text": "Localisation\n\n\nAutogenerated by MFractor v3.7.3\n\n\nAndroid Resource Folder Localisation Importer\n\n\nConfiguration Id: com.mfractor.localisation.android.importer\n\n\nThe android localisation importer gets all string values inside an Android project or resources folder. This localisation importer supports both Xamarin.Android 'Resources' folder and Android native 'res' folders as sources.\n\n\nExcel Spreadsheet Localisation Resource Exporter\n\n\nConfiguration Id: com.mfractor.localisation.exporting.excel_spreadsheet\n\n\nExports the localisation resources for a project into an excel spreadsheet.\n\n\nResX Localisation Values Provider\n\n\nConfiguration Id: com.mfractor.localisation.resx.importer\n\n\nRetrives all localisation values from ResX files in a project", 
            "title": "Localisation"
        }, 
        {
            "location": "/localisation/#localisation", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "Localisation"
        }, 
        {
            "location": "/localisation/#android-resource-folder-localisation-importer", 
            "text": "Configuration Id: com.mfractor.localisation.android.importer  The android localisation importer gets all string values inside an Android project or resources folder. This localisation importer supports both Xamarin.Android 'Resources' folder and Android native 'res' folders as sources.", 
            "title": "Android Resource Folder Localisation Importer"
        }, 
        {
            "location": "/localisation/#excel-spreadsheet-localisation-resource-exporter", 
            "text": "Configuration Id: com.mfractor.localisation.exporting.excel_spreadsheet  Exports the localisation resources for a project into an excel spreadsheet.", 
            "title": "Excel Spreadsheet Localisation Resource Exporter"
        }, 
        {
            "location": "/localisation/#resx-localisation-values-provider", 
            "text": "Configuration Id: com.mfractor.localisation.resx.importer  Retrives all localisation values from ResX files in a project", 
            "title": "ResX Localisation Values Provider"
        }, 
        {
            "location": "/translation/", 
            "text": "Translation\n\n\nAutogenerated by MFractor v3.7.3\n\n\nGoogle Cloud Translation\n\n\nConfiguration Id: com.mfractor.translation.google_cloud_translation\n\n\nProvides translation capabilities to MFractor through the Google Cloud Translation API.\n\n\nConfigurable Properties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefaults To\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nApiKey\n\n\nSystem.String\n\n\nnull\n\n\nWhat is the API key for the Google Cloud Translation API?", 
            "title": "Translation"
        }, 
        {
            "location": "/translation/#translation", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "Translation"
        }, 
        {
            "location": "/translation/#google-cloud-translation", 
            "text": "Configuration Id: com.mfractor.translation.google_cloud_translation  Provides translation capabilities to MFractor through the Google Cloud Translation API.", 
            "title": "Google Cloud Translation"
        }, 
        {
            "location": "/translation/#configurable-properties", 
            "text": "Name  Type  Defaults To  Description      ApiKey  System.String  null  What is the API key for the Google Cloud Translation API?", 
            "title": "Configurable Properties"
        }, 
        {
            "location": "/search/", 
            "text": "Search\n\n\nAutogenerated by MFractor v3.7.3\n\n\nAndroid Resource Search\n\n\nSurfaces all Android resources (drawables, strings, colors, images, menus etc) into the global search bar in Visual Studio For Mac.\n\n\nAutomation ID Search\n\n\nSurfaces all AutomationIDs that are declaraed in XAML into the global search bar in Visual Studio For Mac.\n\n\nXAML Resource Search\n\n\nSurfaces all Xamarin.Forms static resource declarations into the global search bar in Visual Studio For Mac.", 
            "title": "Search"
        }, 
        {
            "location": "/search/#search", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "Search"
        }, 
        {
            "location": "/search/#android-resource-search", 
            "text": "Surfaces all Android resources (drawables, strings, colors, images, menus etc) into the global search bar in Visual Studio For Mac.", 
            "title": "Android Resource Search"
        }, 
        {
            "location": "/search/#automation-id-search", 
            "text": "Surfaces all AutomationIDs that are declaraed in XAML into the global search bar in Visual Studio For Mac.", 
            "title": "Automation ID Search"
        }, 
        {
            "location": "/search/#xaml-resource-search", 
            "text": "Surfaces all Xamarin.Forms static resource declarations into the global search bar in Visual Studio For Mac.", 
            "title": "XAML Resource Search"
        }, 
        {
            "location": "/utilities/", 
            "text": "Utilities\n\n\nAutogenerated by MFractor v3.7.3\n\n\nClean And Compress\n\n\nWhen using the solution explorer pad, the clean and compress action will delete all bin and obj folders and then zip up the project or solution. To use, right click on a project or solution and choose \nClean And Compress\n\n\nClear NuGet Packages\n\n\nThe Clear NuGet Packages command let's you right click on a project or solution in the solution explorer and then clear all local nuget packages that the project/solution uses.\n\n\nCopy ResourceID to Clipboard\n\n\nProfessional Only\n\n\nThe Copy ResourceID to Clipboard shortcut let's you right click on a EmbeddedResource file in the project pad and copy it's resource ID to the clipboard.\n\n\nDelete Output Folders\n\n\nWhen in the solution explorer pad, the \nDelete Output Folders\n action will delete all bin and obj folders for a project or solution. To use, right click on a project or solution and choose \nDelete Output Folders\n\n\nMVVM Wizard\n\n\n\n\nThe MVVM wizard creates a new XAML view, code behind and view model.\n\n\nOpen Android SDK Folder\n\n\nThe \nOpen Android SDK Folder\n menu will open the Android SDK folder in Finder.", 
            "title": "Utilities"
        }, 
        {
            "location": "/utilities/#utilities", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "Utilities"
        }, 
        {
            "location": "/utilities/#clean-and-compress", 
            "text": "When using the solution explorer pad, the clean and compress action will delete all bin and obj folders and then zip up the project or solution. To use, right click on a project or solution and choose  Clean And Compress", 
            "title": "Clean And Compress"
        }, 
        {
            "location": "/utilities/#clear-nuget-packages", 
            "text": "The Clear NuGet Packages command let's you right click on a project or solution in the solution explorer and then clear all local nuget packages that the project/solution uses.", 
            "title": "Clear NuGet Packages"
        }, 
        {
            "location": "/utilities/#copy-resourceid-to-clipboard", 
            "text": "Professional Only  The Copy ResourceID to Clipboard shortcut let's you right click on a EmbeddedResource file in the project pad and copy it's resource ID to the clipboard.", 
            "title": "Copy ResourceID to Clipboard"
        }, 
        {
            "location": "/utilities/#delete-output-folders", 
            "text": "When in the solution explorer pad, the  Delete Output Folders  action will delete all bin and obj folders for a project or solution. To use, right click on a project or solution and choose  Delete Output Folders", 
            "title": "Delete Output Folders"
        }, 
        {
            "location": "/utilities/#mvvm-wizard", 
            "text": "The MVVM wizard creates a new XAML view, code behind and view model.", 
            "title": "MVVM Wizard"
        }, 
        {
            "location": "/utilities/#open-android-sdk-folder", 
            "text": "The  Open Android SDK Folder  menu will open the Android SDK folder in Finder.", 
            "title": "Open Android SDK Folder"
        }, 
        {
            "location": "/debugging/", 
            "text": "Debugging\n\n\nAutogenerated by MFractor v3.7.3\n\n\nAdd Watch To Debugger\n\n\nProfessional Only\n\n\n\n\nThis code action adds the symbol or expression under the cursor to the debug watch pad.", 
            "title": "Debugging"
        }, 
        {
            "location": "/debugging/#debugging", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "Debugging"
        }, 
        {
            "location": "/debugging/#add-watch-to-debugger", 
            "text": "Professional Only   This code action adds the symbol or expression under the cursor to the debug watch pad.", 
            "title": "Add Watch To Debugger"
        }, 
        {
            "location": "/image-tools/", 
            "text": "Image Tools\n\n\nAutogenerated by MFractor v3.7.3\n\n\n__gtksharp_54_Xwt_GtkBackend_CustomContainer", 
            "title": "Image Tools"
        }, 
        {
            "location": "/image-tools/#image-tools", 
            "text": "Autogenerated by MFractor v3.7.3", 
            "title": "Image Tools"
        }, 
        {
            "location": "/image-tools/#__gtksharp_54_xwt_gtkbackend_customcontainer", 
            "text": "", 
            "title": "__gtksharp_54_Xwt_GtkBackend_CustomContainer"
        }, 
        {
            "location": "/release-notes/v3-6/", 
            "text": "Release Notes v3.6.0\n\n\n9th of October 2018\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v3.6.0 of MFractor for Visual Studio Mac.\n\n\nThis release focuses on making MFractors XAML IntelliSense engine more awesome and adds several tools to make it easier to work with the linker.\n\n\nFeatures\n\n\n\n\nOur new product tip window will now show up once a week and show you something new about MFractor!\n\n\nDebugging:\n\n\nNew \nAdd Watch\n shortcut adds the variable under the cursor to the debug watch pad. This appears above the expression evaluator in the right click context menu.\n\n\n\n\n\n\nSearch:\n\n\nAll AutomationIDs that are declared in XAML now appear in the global search bar.\n\n\nAll static resources declared in XAML now appear in the global search bar.\n\n\n\n\n\n\nXAML Analysis:\n\n\nUnused ResourceDictionary resources are greyed out to let you know they aren't in use.\n\n\n\n\n\n\nLinker:\n\n\nIntelliSense support for linker configuration files.\n\n\nNew code action to add symbols to the linker.xml file for your ios and Android projects.\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nVisual Studio Mac 7.6 Support.\n\n\nXAML IntelliSense:\n\n\nView and layout auto-completion when inside a \nControlTemplate\n\n\nViewCell suggestion when inside a \nDataTemplate\n\n\nSuggest \nControlTemplate\n and \nDataTemplate\n when editing resource dictionaries.\n\n\nSuggest compatible StaticResources for property values.\n\n\nSupport for code completion inside XAML expressions.\n\n\nWhen editing an \nxmlns\n, MFractor suggests all available assemblies and namespaces and generates the clr-namespace import.\n\n\nWhen inside a style, trigger, or visual state, you can type the property name of the outer \nTargetType\n and MFractor will generate the full setter element.\n\n\nWhen inside a \n{Binding ...}\n expression MFractor will suggest available properties for data-binding.\n\n\nWhen inside a \n{StaticResource ...}\n expression MFractor will suggest available static resources.\n\n\nSupport for Visual State Management.\n\n\nSupport for \nx:Static\n expressions.\n\n\nSupport for the OnIdiom and OnPlatform markup extensions.\n\n\nWhen editing an attribute that accepts an \nImageSource\n, you can use the \nSelect an image asset\n IntelliSense action to browse available images and choose the image you wish to use.\n\n\nSupport for FlexLayouts.\n\n\nIntelliSense action for importing controls. Simply type out the full name of the control (with the optional namespace name) and choose \nImport MyControl from MyNamespace.Namespace\n.\n\n\nCompletion support for XAML element values such as Colors, images, booleans etc.\n\n\nWhen creating an event callback, you can now type the fullname of the new event handler and generate it.\n\n\nWhen create a XAML node such as a color or boolean, MFractor now suggests available values inline as the XAML node value.\n\n\nSupport for the \nCompressedLayout.IsHeadless\n attached property.\n\n\n\n\n\n\nStatic resource tooltips.\n\n\nThe image wizard now has an option to skip generating the MSBuild into the projects the new images are placed into. This option can be used for SDK style projects or image assets that are included with wildcards.\n\n\nWe've separated out long code snippets into their own pages to make our documentation easier to browse.\n\n\nNew Third Party Software Licenses attribution window under Help -\n MFractor -\n Third Party Software Licenses.\n\n\nWhen editing an MFractor configuration file, we've introduced shortcuts to insert the configuration id and property values so that the files are easier to edit.\n\n\nWhen you hover over a \nXamarin.Forms.Thickness\n symbol in XAML, we've included some hints to help you remember the correct syntax.\n\n\nWe no longer use Xamarin.Forms for our user interfaces. This reduces the size of our package and makes MFractor faster and less buggy in general. We've rebuilt the following UIs:\n\n\nSelect image window.\n\n\nOnboarding window.\n\n\nGenerate interface window.\n\n\n\n\n\n\nWhen we can't resolve the binding context for a binding expression, we now nudge you towards our documentation so that you can learn how MFractor infers binding contexts.\n\n\n\n\nBug Fixes\n\n\n\n\nFixed: Syntax reduction does not work on \nnew\n statements.\n\n\nFixed: \n.mfc.xml\n files aren't picked up when using nuget package references in SDK style projects.\n\n\nFixed: For manually issued trial licenses, MFractor failed to activate the Professional feature-set.\n\n\nFixed: Using OnPlatform or OnIdiom property setters inside a \nContentView.Content\n does not suggest available controls.\n\n\nFixed: In Visual Studio Mac 7.5, generating C# code from would cause the C# file to reload and the changes to be lost.\n\n\nFixed: In Visual Studio Mac 7.5, MFractors C# code actions and analysers were no longer available.\n\n\nFixed: In Visual Studio Mac 7.5, image asset tooltips were broken and did not render.\n\n\nFixed: Remove the x:Class does not exist on root element code analyser as it added no value.\n\n\nFixed: Occasionally MFractor would start suggesting properties for an unclosed type in XAML.\n\n\nFixed: When declaring resources inside \nApplication.Resources\n MFractor failed to index them into the resources database, resulting in many static resource analysis and completion errors. MFractor now correctly indexes these elements.\n\n\nFixed: MFractor failed to deduce the relationship to another resource dictionary when using the \nResourceDictionary.Source\n attribute.\n\n\nFixed: MFractors XAML intellisense would sometimes fail when forcing the completion window to show for XAML nodes and attributes.\n\n\nFixed: MFractors XAML IntelliSense would sometimes clash with the in-built XAML editor.\n\n\nFixed: MFractors XAML IntelliSense would sometimes fail when the XAML file was within a shared project.\n\n\nFixed: When a XAML node has a \nBindingContext=\"{Binding MyProperty}\"\n to specify the binding context, MFractor now correctly evaluates the binding expression when possible. This fixes several analysis and code completion bugs.\n\n\nFixed: When using the dark theme, our weekly tooltip window is now readable.\n\n\nFixed: Missing static resource analysis would occosionally fail.\n\n\nFixed: Binding context tooltips woudl occosional fail.\n\n\nFixed: Go to declaration for symbols resolve from a binding context would occasionally fail.\n\n\nFixed: MFractor failed to detect missing images when the XAMLs project was a shared project.\n\n\nFixed: When detecting a static field accesor assignment, EG: HorizontalOptions=Fill, MFractor wouldn't detect mispelling on the value when it included any non-alphanumerical characters.", 
            "title": "v3.6"
        }, 
        {
            "location": "/release-notes/v3-6/#release-notes-v360", 
            "text": "9th of October 2018", 
            "title": "Release Notes v3.6.0"
        }, 
        {
            "location": "/release-notes/v3-6/#introduction", 
            "text": "This is a summary of the changes introduced in v3.6.0 of MFractor for Visual Studio Mac.  This release focuses on making MFractors XAML IntelliSense engine more awesome and adds several tools to make it easier to work with the linker.", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v3-6/#features", 
            "text": "Our new product tip window will now show up once a week and show you something new about MFractor!  Debugging:  New  Add Watch  shortcut adds the variable under the cursor to the debug watch pad. This appears above the expression evaluator in the right click context menu.    Search:  All AutomationIDs that are declared in XAML now appear in the global search bar.  All static resources declared in XAML now appear in the global search bar.    XAML Analysis:  Unused ResourceDictionary resources are greyed out to let you know they aren't in use.    Linker:  IntelliSense support for linker configuration files.  New code action to add symbols to the linker.xml file for your ios and Android projects.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v3-6/#enhancements", 
            "text": "Visual Studio Mac 7.6 Support.  XAML IntelliSense:  View and layout auto-completion when inside a  ControlTemplate  ViewCell suggestion when inside a  DataTemplate  Suggest  ControlTemplate  and  DataTemplate  when editing resource dictionaries.  Suggest compatible StaticResources for property values.  Support for code completion inside XAML expressions.  When editing an  xmlns , MFractor suggests all available assemblies and namespaces and generates the clr-namespace import.  When inside a style, trigger, or visual state, you can type the property name of the outer  TargetType  and MFractor will generate the full setter element.  When inside a  {Binding ...}  expression MFractor will suggest available properties for data-binding.  When inside a  {StaticResource ...}  expression MFractor will suggest available static resources.  Support for Visual State Management.  Support for  x:Static  expressions.  Support for the OnIdiom and OnPlatform markup extensions.  When editing an attribute that accepts an  ImageSource , you can use the  Select an image asset  IntelliSense action to browse available images and choose the image you wish to use.  Support for FlexLayouts.  IntelliSense action for importing controls. Simply type out the full name of the control (with the optional namespace name) and choose  Import MyControl from MyNamespace.Namespace .  Completion support for XAML element values such as Colors, images, booleans etc.  When creating an event callback, you can now type the fullname of the new event handler and generate it.  When create a XAML node such as a color or boolean, MFractor now suggests available values inline as the XAML node value.  Support for the  CompressedLayout.IsHeadless  attached property.    Static resource tooltips.  The image wizard now has an option to skip generating the MSBuild into the projects the new images are placed into. This option can be used for SDK style projects or image assets that are included with wildcards.  We've separated out long code snippets into their own pages to make our documentation easier to browse.  New Third Party Software Licenses attribution window under Help -  MFractor -  Third Party Software Licenses.  When editing an MFractor configuration file, we've introduced shortcuts to insert the configuration id and property values so that the files are easier to edit.  When you hover over a  Xamarin.Forms.Thickness  symbol in XAML, we've included some hints to help you remember the correct syntax.  We no longer use Xamarin.Forms for our user interfaces. This reduces the size of our package and makes MFractor faster and less buggy in general. We've rebuilt the following UIs:  Select image window.  Onboarding window.  Generate interface window.    When we can't resolve the binding context for a binding expression, we now nudge you towards our documentation so that you can learn how MFractor infers binding contexts.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v3-6/#bug-fixes", 
            "text": "Fixed: Syntax reduction does not work on  new  statements.  Fixed:  .mfc.xml  files aren't picked up when using nuget package references in SDK style projects.  Fixed: For manually issued trial licenses, MFractor failed to activate the Professional feature-set.  Fixed: Using OnPlatform or OnIdiom property setters inside a  ContentView.Content  does not suggest available controls.  Fixed: In Visual Studio Mac 7.5, generating C# code from would cause the C# file to reload and the changes to be lost.  Fixed: In Visual Studio Mac 7.5, MFractors C# code actions and analysers were no longer available.  Fixed: In Visual Studio Mac 7.5, image asset tooltips were broken and did not render.  Fixed: Remove the x:Class does not exist on root element code analyser as it added no value.  Fixed: Occasionally MFractor would start suggesting properties for an unclosed type in XAML.  Fixed: When declaring resources inside  Application.Resources  MFractor failed to index them into the resources database, resulting in many static resource analysis and completion errors. MFractor now correctly indexes these elements.  Fixed: MFractor failed to deduce the relationship to another resource dictionary when using the  ResourceDictionary.Source  attribute.  Fixed: MFractors XAML intellisense would sometimes fail when forcing the completion window to show for XAML nodes and attributes.  Fixed: MFractors XAML IntelliSense would sometimes clash with the in-built XAML editor.  Fixed: MFractors XAML IntelliSense would sometimes fail when the XAML file was within a shared project.  Fixed: When a XAML node has a  BindingContext=\"{Binding MyProperty}\"  to specify the binding context, MFractor now correctly evaluates the binding expression when possible. This fixes several analysis and code completion bugs.  Fixed: When using the dark theme, our weekly tooltip window is now readable.  Fixed: Missing static resource analysis would occosionally fail.  Fixed: Binding context tooltips woudl occosional fail.  Fixed: Go to declaration for symbols resolve from a binding context would occasionally fail.  Fixed: MFractor failed to detect missing images when the XAMLs project was a shared project.  Fixed: When detecting a static field accesor assignment, EG: HorizontalOptions=Fill, MFractor wouldn't detect mispelling on the value when it included any non-alphanumerical characters.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v3-5/", 
            "text": "Release Notes v3.5.0\n\n\n18th of April 2018\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v3.5.0 of MFractor for Visual Studio Mac.\n\n\nThis release focuses on stabilising what MFractor already has and enhancing all of our existing features.\n\n\nFor example, we've added a dozen more code completions (including static resource completion), added search capabilities for static resources, included a go-to definition code action, made it super easier to generate custom renderers and have added heaps of enhancements and bug fixes.\n\n\nCheck it all out below!\n\n\nFeatures\n\n\n\n\nThe Go To Implementation C# code action will find interface and abstract class implementations for a given type or member. Use this with the \nOption+D\n shortcut.\n\n\nUse the \nClean And Compress\n action to clean and then zip up a project or solution.\n\n\nXAML IntelliSense:\n\n\nSuggest available value converters in resource dictionaries.\n\n\nSuggest a variety of commonly used types inside resource dictionaries.\n\n\nUse the Generate Effect IntelliSense code action to quickly create a new platform specific effect.\n\n\nWhen setting the row or column of an element in a grid, MFractor will suggest available row and column indexes with a summary of that row/column.\n\n\nWhen setting the row span or column span of an element in a grid, MFractor will suggest available row and column spans with a summary of that span.\n\n\nMFractor will suggest available static resources based on the current document, the app.xaml and any referenced resource dictionaries.\n\n\nSuggest available style sheets.\n\n\nWhen setting the source property on a style sheet, MFractor allows you to easily generate a new style sheet resource.\n\n\nWhen adding new elements to a resource dictionary, you can use the \"Generate New Value Converer\" IntelliSense action to quickly create a\n\n\n\n\n\n\nCode Actions:\n\n\nThe Generate XAML Localisation infrastructure code action will create the necessary classes to localise XAML.\n\n\nThe Generate Custom Renderers code action will create a platform specific renderer for iOS and Android for a custom control.\n\n\n\n\n\n\nCode Analysis:\n\n\nInspect static resource references and validate they exist within the scope of the current document.\n\n\nWarn when a Grid.Row, Grid.RowSpan, Grid.Column or Grid.ColumnSpan is used when the the outer type is not a grid.\n\n\n\n\n\n\nTooltips:\n\n\nWhen you hover over a grid row or column definition, you can now see the index that row or column.\n\n\n\n\n\n\nSearch:\n\n\nStatic resources now appear in the global search bar. Press Command + Return to activate the search bar and then search for your static resources.\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nSupport for \"invisible\" config files. Name a config file .mfc.xml and place it alongside a project for MFractor to import that config setting. Silent configs are designed to be included in a .gitignore so you can use MFractor configs without needing to include it into your project.\n\n\nIn IntelliSense, MFractor can now infer the binding context from the current context while you're editing your XAML. For example:\n\n\nSupport for inferring the binding context via ListView's item source while editing inside the ItemTemplate.\n\n\nSupport for custom binding contexts using the \nMyXamlPage.BindingContext\n local:MyViewModel\n \n/MyXamlPage.BindingContext\n syntax.\n\n\nSupport for custom binding contexts through the \nBindingContext\n attribute. EG \n... BindingContext=\"{x:Type local:MyViewModel}\"/\n or \n... BindingContext=\"{x:Reference slider}\"/\n.\n\n\n\n\n\n\nMFractor can now discover the view model for your XAML across project boundaries. For example, if your views are defined in \nMyApp.Views\n and your view models are defined in \nMyApp.ViewModels\n, when one of these project references the other, MFractor will discover the MVVM relationship and use it to power the MVVM tool-suite.\n\n\nMFractor now let's you know that your license is expiring and directs you to re-purchase (1 week before expiry, day of expiry).\n\n\nSignificantly improved support for generating code across project boundaries.\n\n\nWhen MFractor detects multiple code issues at the same location, it will display errors first, then warnings and lastly all other issues.\n\n\nCleaned up error messages for code analysis issues to make the issues they find more precise.\n\n\nMFractor now saves the last window location of the localisation wizard and restores it in that same spot.\n\n\nWe've added icons for most IntelliSense suggestions to make is easily to understand what an action does at a glance.\n\n\nMFractor now indexes all XAML files in your solution, building a resource data-base that is used to power some of our new features.\n\n\n\n\nBug Fixes\n\n\n\n\nFixed: Added parser support for \nusing:\n syntax inside XAML namespace declarations.\n\n\nFixed: When converting fully qualified types into usings, the syntax reducer would collapse namespace declaration and other using statements.\n\n\nFixed: The syntax reducer would occasionally make the generate immutable constructor and the generate base class constructor code action fail.\n\n\nFixed: Don't suggest the exact same namespace for a symbol in XAML when it can't be resolved.\n\n\nFixed: When an assembly isn't referenced by a project, describe it clearly in the missing assembly xmlns code issue.\n\n\nFixed: When a symbol can't be resolved because it's namespace is unresolved, clearly say this in the code analysis issue.\n\n\nFixed: MFractor now supports creating custom controls or classes into other assemblies as specified by the xml namespace.\n\n\nFixed: When the root element in a XAML document failed to resolve it would cause a cascading effect that broke subsequent symbol resolutions and caused false code issues to be reported.\n\n\nFixed: For attached properties on the root XAML node, correctly resolve the symbol when the root element fails to resolve.\n\n\nFixed: When using go to view model or code behind and the view model or code behind is already open, MFractor will focus the document and not jump to the symbol.\n\n\nFixed: When navigating to a XAML symbol that has a XAML file as UI code, MFractor now opens the XAML file instead of the code behind.\n\n\nFixed: When generating new code in SDK style projects that used the projects default namespace, would incorrectly insert the namespace \n$(MSBuildProjectName)\n instead of evaluating it to the project name.\n\n\nFixed: When suggesting image assets, MFractor no longer suggests Android xml drawables.", 
            "title": "v3.5"
        }, 
        {
            "location": "/release-notes/v3-5/#release-notes-v350", 
            "text": "18th of April 2018", 
            "title": "Release Notes v3.5.0"
        }, 
        {
            "location": "/release-notes/v3-5/#introduction", 
            "text": "This is a summary of the changes introduced in v3.5.0 of MFractor for Visual Studio Mac.  This release focuses on stabilising what MFractor already has and enhancing all of our existing features.  For example, we've added a dozen more code completions (including static resource completion), added search capabilities for static resources, included a go-to definition code action, made it super easier to generate custom renderers and have added heaps of enhancements and bug fixes.  Check it all out below!", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v3-5/#features", 
            "text": "The Go To Implementation C# code action will find interface and abstract class implementations for a given type or member. Use this with the  Option+D  shortcut.  Use the  Clean And Compress  action to clean and then zip up a project or solution.  XAML IntelliSense:  Suggest available value converters in resource dictionaries.  Suggest a variety of commonly used types inside resource dictionaries.  Use the Generate Effect IntelliSense code action to quickly create a new platform specific effect.  When setting the row or column of an element in a grid, MFractor will suggest available row and column indexes with a summary of that row/column.  When setting the row span or column span of an element in a grid, MFractor will suggest available row and column spans with a summary of that span.  MFractor will suggest available static resources based on the current document, the app.xaml and any referenced resource dictionaries.  Suggest available style sheets.  When setting the source property on a style sheet, MFractor allows you to easily generate a new style sheet resource.  When adding new elements to a resource dictionary, you can use the \"Generate New Value Converer\" IntelliSense action to quickly create a    Code Actions:  The Generate XAML Localisation infrastructure code action will create the necessary classes to localise XAML.  The Generate Custom Renderers code action will create a platform specific renderer for iOS and Android for a custom control.    Code Analysis:  Inspect static resource references and validate they exist within the scope of the current document.  Warn when a Grid.Row, Grid.RowSpan, Grid.Column or Grid.ColumnSpan is used when the the outer type is not a grid.    Tooltips:  When you hover over a grid row or column definition, you can now see the index that row or column.    Search:  Static resources now appear in the global search bar. Press Command + Return to activate the search bar and then search for your static resources.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v3-5/#enhancements", 
            "text": "Support for \"invisible\" config files. Name a config file .mfc.xml and place it alongside a project for MFractor to import that config setting. Silent configs are designed to be included in a .gitignore so you can use MFractor configs without needing to include it into your project.  In IntelliSense, MFractor can now infer the binding context from the current context while you're editing your XAML. For example:  Support for inferring the binding context via ListView's item source while editing inside the ItemTemplate.  Support for custom binding contexts using the  MyXamlPage.BindingContext  local:MyViewModel   /MyXamlPage.BindingContext  syntax.  Support for custom binding contexts through the  BindingContext  attribute. EG  ... BindingContext=\"{x:Type local:MyViewModel}\"/  or  ... BindingContext=\"{x:Reference slider}\"/ .    MFractor can now discover the view model for your XAML across project boundaries. For example, if your views are defined in  MyApp.Views  and your view models are defined in  MyApp.ViewModels , when one of these project references the other, MFractor will discover the MVVM relationship and use it to power the MVVM tool-suite.  MFractor now let's you know that your license is expiring and directs you to re-purchase (1 week before expiry, day of expiry).  Significantly improved support for generating code across project boundaries.  When MFractor detects multiple code issues at the same location, it will display errors first, then warnings and lastly all other issues.  Cleaned up error messages for code analysis issues to make the issues they find more precise.  MFractor now saves the last window location of the localisation wizard and restores it in that same spot.  We've added icons for most IntelliSense suggestions to make is easily to understand what an action does at a glance.  MFractor now indexes all XAML files in your solution, building a resource data-base that is used to power some of our new features.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v3-5/#bug-fixes", 
            "text": "Fixed: Added parser support for  using:  syntax inside XAML namespace declarations.  Fixed: When converting fully qualified types into usings, the syntax reducer would collapse namespace declaration and other using statements.  Fixed: The syntax reducer would occasionally make the generate immutable constructor and the generate base class constructor code action fail.  Fixed: Don't suggest the exact same namespace for a symbol in XAML when it can't be resolved.  Fixed: When an assembly isn't referenced by a project, describe it clearly in the missing assembly xmlns code issue.  Fixed: When a symbol can't be resolved because it's namespace is unresolved, clearly say this in the code analysis issue.  Fixed: MFractor now supports creating custom controls or classes into other assemblies as specified by the xml namespace.  Fixed: When the root element in a XAML document failed to resolve it would cause a cascading effect that broke subsequent symbol resolutions and caused false code issues to be reported.  Fixed: For attached properties on the root XAML node, correctly resolve the symbol when the root element fails to resolve.  Fixed: When using go to view model or code behind and the view model or code behind is already open, MFractor will focus the document and not jump to the symbol.  Fixed: When navigating to a XAML symbol that has a XAML file as UI code, MFractor now opens the XAML file instead of the code behind.  Fixed: When generating new code in SDK style projects that used the projects default namespace, would incorrectly insert the namespace  $(MSBuildProjectName)  instead of evaluating it to the project name.  Fixed: When suggesting image assets, MFractor no longer suggests Android xml drawables.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v3-4/", 
            "text": "Release Notes v3.4.0\n\n\nJanuary 25th 2018\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v3.4.0 of MFractor for Visual Studio Mac.\n\n\nThis release adds an MFractor powered XAML IntelliSense engine!\n\n\nThe MFractor XAML editor is a dramatic improvement on Visual Studio for Macs default IntelliSense. MFractors IntelliSense has feature parity and injects a lot of MFractors smarts into the XAML editing experience.\n\n\nInitially we've added obvious auto-completions to take the friction out of what you're currently working on; for example, we suggest available properties when creating a style setter based on the styles \nTargetType\n, suggest available images when editing an image source or even suggest available properties for databinding when MFractor can infer the view model.\n\n\nWe've also revamped our free licensing model; previously we had several feature groups as free and allowed up to 5 pro features per day; this licensing model was confusing, hard to communicate and didn't let you fully evaluate what you'd get by upgrading to MFractor Professional.\n\n\nTo simplify our free tier, we now allow unlimited use of all of MFractor's features in 2 XAML files per day. After you've used your 2 documents per day, Visual Studio for Mac will revert back to it's original behaviour. Additionally, all C# refactorings and inspections are still available in only MFractor Professional.\n\n\nFeatures\n\n\n\n\nXAML IntelliSense:\n\n\nFeature parity with Visual Studio Macs XAML IntelliSense.\n\n\nThe ability to generate property bindings from XAML when MFractor can resolve the ViewModel. This is intentionally deactivated in DataTemplates, ResourceDictionaries and the App.xaml.\n\n\nSuggest all available properties when the view model for a XAML view can be resolved.\n\n\nSuggest FontSizes such as \nMicro\n, \nSmall\n, \nLarge\n etc\n\n\nWhen in a GridUnit element, suggest \nAuto\n and \n*\n.\n\n\nSuggest the \n.Behaviors\n property for VisualElements and suggest available behaviors.\n\n\nSuggest the \n.Effects\n property for VisualElements and suggest available effects.\n\n\nSuggest the \n.Triggers\n property for VisualElements and suggest available triggers.\n\n\nSuggest the \n.GestureRecognizers\n property for Views and suggest available gesture recognisers.\n\n\nSuggest \nStyle\n, \nColor\n, \nString\n, \nDouble\n, \nOnIdiom\n and \nOnPlatform\n inside resource dictionaries.\n\n\nIn \nStyles\n, suggest \nSetters\n and available styleable controls in the \nTargetType\n property.\n\n\nIn \nSetters\n, suggest properties and relevant property values based on the \nTargetType\n of the parent style.\n\n\nIn \nTriggers\n, suggest properties and relevant property values based on the \nTargetType\n.\n\n\nFor colors, you can now open a color picker while coding XAML.\n\n\nFor colors, you now have access to all Xamarin.Forms colors.\n\n\nFor an \nImageSource\n, MFractor will provide available images from Android (drawable/mipmap) and iOS (Resources/image catalogs) projects.\n\n\nFor an \nImageSource\n, you can now open the Image Wizard to quickly import an image into your project.\n\n\nFor \nOnPlatform\n, suggest available platforms inside \nOn\n elements and provide relevant completions based on the \nx:TypeArguments\n.\n\n\nFor \nOnIdiom\n, provide relevant completions based on the \nx:TypeArguments\n.\n\n\nSuggest the \nMergedDictionaries\n property in resource dictionaries.\n\n\nSuggest available resource dictionaries to merge in \nResourceDictionary.MergeWith\n and \nResourceDictionary.MergedDictionaries\n properties.\n\n\nFull native view declaration editing support.\n\n\n\n\n\n\nNew MFractor options panel under \nVisual Studio\n -\n \nPreferences\n -\n \nMFractor\n.\n\n\nUse the \nDelete Output Folders\n action to quickly delete the bin and obj folders for a solution or project.\n\n\nNew C# refactoring to simplify a fully qualified type by introducing a using for its namespace (EG: \nSystem.IO.Path\n becomes \nPath\n + \nusing System.IO;\n);\n\n\n\n\nEnhancements\n\n\n\n\nIntelligent prioritisation of XAML completion suggestions.\n\n\nThe amount of information displayed in the XAML tooltips has been reduced as it was a bit too much.\n\n\nUnder settings, you can now turn off automatic code formatting. You should use this if you want to preserve the structure of code snippets when MFractor inserts them into your code.\n\n\nUnder settings, you can set MFractor to prompt you to choose the location to insert code or for MFractor to insert it automatically.\n\n\nIn the image wizard, when you start changing the width or height of the importing image, the \nResize\n checkbox is automatically enabled.\n\n\nThe \n.droidres\n directory that MFractor creates alongside a solution has been renamed to \n.mfractor\n.\n\n\nSignificantly reduced distribution size. We've shaved 30mbs off the final MFractor distribution bundle.\n\n\nNew licensing model of 2 XAML documents per day.\n\n\nWhen generating new code files or code insertions, MFractor will now convert fully qualified types into a using directive to cleanup code that it generates.\n\n\nMFractors C# code actions are now integrated with Visual Studio Macs \nQuick Fix\n menu.\n\n\n\n\nBug Fixes\n\n\n\n\nFixed: The \nFontSize\n analyser would incorrectly report \nDefault\n as an error.\n\n\nFixed: The Generate Interface code action would occasionally include the entire project folder. \ud83d\ude31\n\n\nFixed: The Generate Interface code action now correctly generates out and ref parameters in methods.\n\n\nFixed: The image wizard would occasionally lock Visual Studio due to a threading issue when adding the downsampled images into the project structure.\n\n\nFixed: The missing image analyser would fail when a project had \nno\n images in it.\n\n\nFixed: The missing image analyser now detects image catalogs on iOS.\n\n\n\n\nDeprecations\n\n\n\n\nDeprecated: MFractor no longer inspects XAML view resources to validate only resource dictionaries are used. This is irrelevant with coming StyleSheet support.", 
            "title": "v3.4"
        }, 
        {
            "location": "/release-notes/v3-4/#release-notes-v340", 
            "text": "January 25th 2018", 
            "title": "Release Notes v3.4.0"
        }, 
        {
            "location": "/release-notes/v3-4/#introduction", 
            "text": "This is a summary of the changes introduced in v3.4.0 of MFractor for Visual Studio Mac.  This release adds an MFractor powered XAML IntelliSense engine!  The MFractor XAML editor is a dramatic improvement on Visual Studio for Macs default IntelliSense. MFractors IntelliSense has feature parity and injects a lot of MFractors smarts into the XAML editing experience.  Initially we've added obvious auto-completions to take the friction out of what you're currently working on; for example, we suggest available properties when creating a style setter based on the styles  TargetType , suggest available images when editing an image source or even suggest available properties for databinding when MFractor can infer the view model.  We've also revamped our free licensing model; previously we had several feature groups as free and allowed up to 5 pro features per day; this licensing model was confusing, hard to communicate and didn't let you fully evaluate what you'd get by upgrading to MFractor Professional.  To simplify our free tier, we now allow unlimited use of all of MFractor's features in 2 XAML files per day. After you've used your 2 documents per day, Visual Studio for Mac will revert back to it's original behaviour. Additionally, all C# refactorings and inspections are still available in only MFractor Professional.", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v3-4/#features", 
            "text": "XAML IntelliSense:  Feature parity with Visual Studio Macs XAML IntelliSense.  The ability to generate property bindings from XAML when MFractor can resolve the ViewModel. This is intentionally deactivated in DataTemplates, ResourceDictionaries and the App.xaml.  Suggest all available properties when the view model for a XAML view can be resolved.  Suggest FontSizes such as  Micro ,  Small ,  Large  etc  When in a GridUnit element, suggest  Auto  and  * .  Suggest the  .Behaviors  property for VisualElements and suggest available behaviors.  Suggest the  .Effects  property for VisualElements and suggest available effects.  Suggest the  .Triggers  property for VisualElements and suggest available triggers.  Suggest the  .GestureRecognizers  property for Views and suggest available gesture recognisers.  Suggest  Style ,  Color ,  String ,  Double ,  OnIdiom  and  OnPlatform  inside resource dictionaries.  In  Styles , suggest  Setters  and available styleable controls in the  TargetType  property.  In  Setters , suggest properties and relevant property values based on the  TargetType  of the parent style.  In  Triggers , suggest properties and relevant property values based on the  TargetType .  For colors, you can now open a color picker while coding XAML.  For colors, you now have access to all Xamarin.Forms colors.  For an  ImageSource , MFractor will provide available images from Android (drawable/mipmap) and iOS (Resources/image catalogs) projects.  For an  ImageSource , you can now open the Image Wizard to quickly import an image into your project.  For  OnPlatform , suggest available platforms inside  On  elements and provide relevant completions based on the  x:TypeArguments .  For  OnIdiom , provide relevant completions based on the  x:TypeArguments .  Suggest the  MergedDictionaries  property in resource dictionaries.  Suggest available resource dictionaries to merge in  ResourceDictionary.MergeWith  and  ResourceDictionary.MergedDictionaries  properties.  Full native view declaration editing support.    New MFractor options panel under  Visual Studio  -   Preferences  -   MFractor .  Use the  Delete Output Folders  action to quickly delete the bin and obj folders for a solution or project.  New C# refactoring to simplify a fully qualified type by introducing a using for its namespace (EG:  System.IO.Path  becomes  Path  +  using System.IO; );", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v3-4/#enhancements", 
            "text": "Intelligent prioritisation of XAML completion suggestions.  The amount of information displayed in the XAML tooltips has been reduced as it was a bit too much.  Under settings, you can now turn off automatic code formatting. You should use this if you want to preserve the structure of code snippets when MFractor inserts them into your code.  Under settings, you can set MFractor to prompt you to choose the location to insert code or for MFractor to insert it automatically.  In the image wizard, when you start changing the width or height of the importing image, the  Resize  checkbox is automatically enabled.  The  .droidres  directory that MFractor creates alongside a solution has been renamed to  .mfractor .  Significantly reduced distribution size. We've shaved 30mbs off the final MFractor distribution bundle.  New licensing model of 2 XAML documents per day.  When generating new code files or code insertions, MFractor will now convert fully qualified types into a using directive to cleanup code that it generates.  MFractors C# code actions are now integrated with Visual Studio Macs  Quick Fix  menu.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v3-4/#bug-fixes", 
            "text": "Fixed: The  FontSize  analyser would incorrectly report  Default  as an error.  Fixed: The Generate Interface code action would occasionally include the entire project folder. \ud83d\ude31  Fixed: The Generate Interface code action now correctly generates out and ref parameters in methods.  Fixed: The image wizard would occasionally lock Visual Studio due to a threading issue when adding the downsampled images into the project structure.  Fixed: The missing image analyser would fail when a project had  no  images in it.  Fixed: The missing image analyser now detects image catalogs on iOS.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v3-4/#deprecations", 
            "text": "Deprecated: MFractor no longer inspects XAML view resources to validate only resource dictionaries are used. This is irrelevant with coming StyleSheet support.", 
            "title": "Deprecations"
        }, 
        {
            "location": "/release-notes/v3-3/", 
            "text": "Release Notes v3.3.0\n\n\nDecember 19th 2017\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v3.3.0 of MFractor for Visual Studio Mac.\n\n\nThis standout feature in this release is the addition of code snippet support. Got a particular way you write your view model properties or commands? MFractor now lets you use your own code snippet, enabling complete customisation!\n\n\nWe've also added a localisation wizard that will quickly move string literals into ResX files, several handy code actions and a update notification dialog that let's you know when new MFractor releases are available.\n\n\nFeatures\n\n\n\n\nA localisation wizard for XAML and C# so you can quickly move strings into ResX files.\n\n\nCode Snippets are now generally supported throughout MFractor. They are available for:\n\n\nView Model Properties.\n\n\nBindable Properties.\n\n\nCommand Implementations.\n\n\nRouting Effects.\n\n\nPlatform Specific Effects.\n\n\nValue Converters.\n\n\nValue Conversion Attribute.\n\n\nCode Behind class declarations.\n\n\n\n\n\n\nUse the \nExtract XAML layout into new control\n code action to move a XAML section into its own code file.\n\n\nUse the \nGenerate Platform Effect\n code action to easily generate the routing effect and platform effects.\n\n\nUse the \nGenerate interface implementation\n code action to quickly create a new class implementation from an existing C# interface;\n\n\nThe \nAdd \nUsesLayout\n to class code action\n will append an \nMFractor.Annotations.Android.UsesLayout\n annotation to an Android class to specify the layout that class uses. Use this to quickly enable MFractors Android layout usage validation.\n\n\nSupport for config files that are included within a nuget packages build folder. Framework authors can now include an MFractor config to enforce their framework standards by including an MFractor config file named \n.mfc.xml\n in the packages build folder.\n\n\n\n\nEnhancements\n\n\n\n\nSupport for Visual Studio Mac 7.2 and above.\n\n\nSupport for Roslyn 2.3.\n\n\nMFractor now regularly checks for updates against the addin server and let's you know when there's been a new release.\n\n\nEnhanced code completion for MFractor configuration files.\n\n\nCode analysis for MFractor configuration files to check for common gotchas.\n\n\nSpecify a new width and height for the highest density when you import an image with the importing wizard.\n\n\nThe \nGenerate constructor for all readonly members\n will now include constructor arguments for auto properties as well as readonly fields.\n\n\nThe empty XAML attribute and node analysers have been removed as they were plain annoying (and frequently incorrect).\n\n\nMFractor Lite now allows up to 5 pro feature uses per day.\n\n\nInternally, MFractor now uses Roslyn's concept of text spans instead of line/columns. This significantly reduces MFractors memory footprint and improves the speed of all analysers.\n\n\nThe following features are now professional only:\n\n\nImage tooltips.\n\n\nGo To View Model, Go To Code Behind and Go To View.\n\n\nAndroid resource IntelliSense.\n\n\n\n\n\n\nSignificantly expanded documentation, we now, where possible, show a preview of the code MFractor will generate under default settings.\n\n\nBranded MFractor code completion.\n\n\n\n\nBug Fixes\n\n\n\n\nFixed: MFractor no longer bundles the Microsoft.CodeAnalysis (Roslyn) assemblies into its distribution package. This caused critical issues in VSMac 7.2 \ud83d\ude31\n\n\nFixed: Upgraded MFractor to use Microsoft.CodeAnalysis (Roslyn) 2.3. This required several code generators to be upgraded.\n\n\nFixed: A regression in the \nMigrate OnPlatform\n code action caused it to failed.\n\n\nFixed: When generating property bindings with a string value, the string would inserted as syntax rather than a string literal in the view model. (EG: \nstring myString = Hello\n instead of \nstring myString = \"Hello\"\n).\n\n\nFixed: When generating a bindable property, MFractor would always use \nbool\n as the instance property type. It will now try to infer the indended type, falling back to \nSystem.Object\n as a default.\n\n\nFixed: The XAML analyser would frequently fail to infer the BindingContext. It now uses the same MVVM resolution logic as the MVVM shortcuts.\n\n\nFixed: The \nValueConversionAttribute\n would occasionally fail to generate.\n\n\nFixed: The Android XML text editor would always trigger license notifications.\n\n\n\n\nDeprecations\n\n\n\n\nThe configurable property \nImplementConversionForConvert\n on the value converter generator is deprecated and has been removed. Please use the code snippet to control the \nConvert\n method body.\n\n\nThe configurable property \nImplementConversionForConvertBack\n on the value converter generator is deprecated and has been removed. Please use the code snippet to control the \nConvertBack\n method body.", 
            "title": "v3.3"
        }, 
        {
            "location": "/release-notes/v3-3/#release-notes-v330", 
            "text": "December 19th 2017", 
            "title": "Release Notes v3.3.0"
        }, 
        {
            "location": "/release-notes/v3-3/#introduction", 
            "text": "This is a summary of the changes introduced in v3.3.0 of MFractor for Visual Studio Mac.  This standout feature in this release is the addition of code snippet support. Got a particular way you write your view model properties or commands? MFractor now lets you use your own code snippet, enabling complete customisation!  We've also added a localisation wizard that will quickly move string literals into ResX files, several handy code actions and a update notification dialog that let's you know when new MFractor releases are available.", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v3-3/#features", 
            "text": "A localisation wizard for XAML and C# so you can quickly move strings into ResX files.  Code Snippets are now generally supported throughout MFractor. They are available for:  View Model Properties.  Bindable Properties.  Command Implementations.  Routing Effects.  Platform Specific Effects.  Value Converters.  Value Conversion Attribute.  Code Behind class declarations.    Use the  Extract XAML layout into new control  code action to move a XAML section into its own code file.  Use the  Generate Platform Effect  code action to easily generate the routing effect and platform effects.  Use the  Generate interface implementation  code action to quickly create a new class implementation from an existing C# interface;  The  Add  UsesLayout  to class code action  will append an  MFractor.Annotations.Android.UsesLayout  annotation to an Android class to specify the layout that class uses. Use this to quickly enable MFractors Android layout usage validation.  Support for config files that are included within a nuget packages build folder. Framework authors can now include an MFractor config to enforce their framework standards by including an MFractor config file named  .mfc.xml  in the packages build folder.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v3-3/#enhancements", 
            "text": "Support for Visual Studio Mac 7.2 and above.  Support for Roslyn 2.3.  MFractor now regularly checks for updates against the addin server and let's you know when there's been a new release.  Enhanced code completion for MFractor configuration files.  Code analysis for MFractor configuration files to check for common gotchas.  Specify a new width and height for the highest density when you import an image with the importing wizard.  The  Generate constructor for all readonly members  will now include constructor arguments for auto properties as well as readonly fields.  The empty XAML attribute and node analysers have been removed as they were plain annoying (and frequently incorrect).  MFractor Lite now allows up to 5 pro feature uses per day.  Internally, MFractor now uses Roslyn's concept of text spans instead of line/columns. This significantly reduces MFractors memory footprint and improves the speed of all analysers.  The following features are now professional only:  Image tooltips.  Go To View Model, Go To Code Behind and Go To View.  Android resource IntelliSense.    Significantly expanded documentation, we now, where possible, show a preview of the code MFractor will generate under default settings.  Branded MFractor code completion.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v3-3/#bug-fixes", 
            "text": "Fixed: MFractor no longer bundles the Microsoft.CodeAnalysis (Roslyn) assemblies into its distribution package. This caused critical issues in VSMac 7.2 \ud83d\ude31  Fixed: Upgraded MFractor to use Microsoft.CodeAnalysis (Roslyn) 2.3. This required several code generators to be upgraded.  Fixed: A regression in the  Migrate OnPlatform  code action caused it to failed.  Fixed: When generating property bindings with a string value, the string would inserted as syntax rather than a string literal in the view model. (EG:  string myString = Hello  instead of  string myString = \"Hello\" ).  Fixed: When generating a bindable property, MFractor would always use  bool  as the instance property type. It will now try to infer the indended type, falling back to  System.Object  as a default.  Fixed: The XAML analyser would frequently fail to infer the BindingContext. It now uses the same MVVM resolution logic as the MVVM shortcuts.  Fixed: The  ValueConversionAttribute  would occasionally fail to generate.  Fixed: The Android XML text editor would always trigger license notifications.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v3-3/#deprecations", 
            "text": "The configurable property  ImplementConversionForConvert  on the value converter generator is deprecated and has been removed. Please use the code snippet to control the  Convert  method body.  The configurable property  ImplementConversionForConvertBack  on the value converter generator is deprecated and has been removed. Please use the code snippet to control the  ConvertBack  method body.", 
            "title": "Deprecations"
        }, 
        {
            "location": "/release-notes/v3-2/", 
            "text": "Release Notes - v3.2.0\n\n\nAugust 10th 2017\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v3.2.0 of MFractor for Visual Studio Mac.\n\n\nThis release focuses on adding killer tools for working with images. We've added an import image wizard to make it dead-simple to bring images into your Android, iOS and Xamarin.Forms apps. You can access the image wizard through the \nTools\n main menu and then selecting \nImport Image Wizard\n.\n\n\n\n\nThe licensing tiers are being changed in the 3.2 release; all code analysis tooling is now part of the Lite tier and all code actions and code fixes have been moved into the Professional tier.\n\n\nLite Features\n\n\n\n\nGrid Analysis Support:\n\n\nCheck that value used in \nGrid.RowSpan\n usages don't extend beyond the amount of rows declared by the grid.\n\n\nCheck that value used in \nGrid.ColumnSpan\n usages don't extend beyond the amount of columns declared by the grid.\n\n\nCheck that value used in \nGrid.Row\n usages doesn't access a row outside the the amount of rows declared by the grid.\n\n\nCheck that value used in \nGrid.Column\n usages doesn't access a column outside the the amount of column declared by the grid.\n\n\n\n\n\n\nFont Analysis Support:\n\n\nInspect the value provided to \nFontSize\n attributes and validate that the named size provided is valid.\n\n\n\n\n\n\nScrollView Analysis Support:\n\n\nChecks that a single child has been provided to the ScrollView; it is a common mistake to declare multiple direct children instead of encapsulating them with with a container like a StackLayout or Grid.\n\n\n\n\n\n\n\n\nProfessional Features\n\n\n\n\nUse the new Import Image Wizard to import Android, iOS and Xamarin.Forms images into your app painlessly. See \nWorking With Images\n\n\n\n\nEnhancements\n\n\n\n\nThe C# code diagnostic that inspected usages of \nExportRendererAttribute\n has been disabled. It was causing false warnings and added no tangible benefit.\n\n\nSignificantly reduced XAML analysis time through aggressive caching strategies in each analysis pass. This slightly increases MFractors memory overhead.\n\n\nIncreased branding presence throughout the product so that it's clearer when MFractor is providing functionality instead of VS Mac.\n\n\nA rebuild class generator will now generate all base class constructors and abstract methods of a base class. The class generator is heavily in use by the view model generator.\n\n\n\n\nBug Fixes\n\n\n\n\nFixed: When a folder path is used in a config file for a new code file, MFractor will now create that folder when it's missing instead of silently failing.\n\n\nFixed: When generating a view model from a base class, the view model generator will check for bindings that reference a property in the base class and not generate them.", 
            "title": "v3.2"
        }, 
        {
            "location": "/release-notes/v3-2/#release-notes-v320", 
            "text": "August 10th 2017", 
            "title": "Release Notes - v3.2.0"
        }, 
        {
            "location": "/release-notes/v3-2/#introduction", 
            "text": "This is a summary of the changes introduced in v3.2.0 of MFractor for Visual Studio Mac.  This release focuses on adding killer tools for working with images. We've added an import image wizard to make it dead-simple to bring images into your Android, iOS and Xamarin.Forms apps. You can access the image wizard through the  Tools  main menu and then selecting  Import Image Wizard .   The licensing tiers are being changed in the 3.2 release; all code analysis tooling is now part of the Lite tier and all code actions and code fixes have been moved into the Professional tier.", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v3-2/#lite-features", 
            "text": "Grid Analysis Support:  Check that value used in  Grid.RowSpan  usages don't extend beyond the amount of rows declared by the grid.  Check that value used in  Grid.ColumnSpan  usages don't extend beyond the amount of columns declared by the grid.  Check that value used in  Grid.Row  usages doesn't access a row outside the the amount of rows declared by the grid.  Check that value used in  Grid.Column  usages doesn't access a column outside the the amount of column declared by the grid.    Font Analysis Support:  Inspect the value provided to  FontSize  attributes and validate that the named size provided is valid.    ScrollView Analysis Support:  Checks that a single child has been provided to the ScrollView; it is a common mistake to declare multiple direct children instead of encapsulating them with with a container like a StackLayout or Grid.", 
            "title": "Lite Features"
        }, 
        {
            "location": "/release-notes/v3-2/#professional-features", 
            "text": "Use the new Import Image Wizard to import Android, iOS and Xamarin.Forms images into your app painlessly. See  Working With Images", 
            "title": "Professional Features"
        }, 
        {
            "location": "/release-notes/v3-2/#enhancements", 
            "text": "The C# code diagnostic that inspected usages of  ExportRendererAttribute  has been disabled. It was causing false warnings and added no tangible benefit.  Significantly reduced XAML analysis time through aggressive caching strategies in each analysis pass. This slightly increases MFractors memory overhead.  Increased branding presence throughout the product so that it's clearer when MFractor is providing functionality instead of VS Mac.  A rebuild class generator will now generate all base class constructors and abstract methods of a base class. The class generator is heavily in use by the view model generator.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v3-2/#bug-fixes", 
            "text": "Fixed: When a folder path is used in a config file for a new code file, MFractor will now create that folder when it's missing instead of silently failing.  Fixed: When generating a view model from a base class, the view model generator will check for bindings that reference a property in the base class and not generate them.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v3-1/", 
            "text": "Release Notes - v3.1.0\n\n\nJuly 13th 2017\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v3.1.0 of MFractor for Visual Studio Mac.\n\n\nWe have rebranded our free tier into \nMFractor Lite\n and our paid tier into \nMFractor Professional\n. This is to better reflect the value difference between the different licensing levels.\n\n\nIn terms of features, this release adds a new on-boarding window to make it as easy as possible to learn to use MFractor. We've also added a suite of new professional features for C# and Android, a \nheap\n of bug fixes and a few handy XAML refactorings.\n\n\nLastly, we are slowly working through the documentation and adding a comprehensive explanation for each MFractor feature. This is ongoing and will take some time to complete.\n\n\nLite Features\n\n\n\n\nOnboarding Window\n: When MFractor is first installed, after activation, we now display an onboarding window to teaches you the fundamentals of using MFractor.\n\n\nXAML Code Actions\n\n\nQuickly migrate to the new \nOnPlatform\n methodology with the \nMigrate OnPlatform Usage\n code action.\n\n\nGenerate a new view from an unknown XAML node as a XAML view with a code behind class.\n\n\n\n\n\n\nXAML Code Analysis\n\n\nFor \nStyle\ns, inspect that it sets a \nTargetType\n attribute.\n\n\nFor \nStyle\n \nSetter\ns, inspect that the \nProperty\n value maps to a property in the type provided byt the  \nStyle\ns \nTargetType\n attribute.\n\n\n\n\n\n\n\n\nProfessional Features\n\n\n\n\nXAML\n\n\nFor XAML attributes that accept an \nImageSource\n, detect missing image resources in Android and iOS projects and offer the ability to easily import those images using the quick fix menu.\n\n\n\n\n\n\nC# Code Actions\n\n\nImplement all of a base classes constructors onto the class. See \nImplement Base Class Constructors\n.\n\n\nWhen a class ends with \nAttribute\n, use the \nMake Class Inherit From System.Attribute\n code action to add attribute inheritance.\n\n\nQuickly assign closely named constructor arguments to fields and properties using the \nAssign Constructor Argument To Member\n C# code action.\n\n\nUse \nAnnotate With Attribute Usage\n to add a \nAttributeUsage\n attribute to a class that inherits from \nSystem.Attribute\n.\n\n\nUse the \nCreate Immutable Constructor\n code action to generate a constructor that initializes all readonly fields from constructor arguments.\n\n\n\n\n\n\nAndroid C# Code Diagnostics\n\n\nDetect when a developer tries to manually create an \nActivity\n with new statement. See \nIncorrect Activity Creation\n.\n\n\nDetect when a developer directly implements the \nIJavaObject\n interface instead of inheriting from \nJava.Lang.Object\n. See \nClass Derives From IJavaObject\n.\n\n\nDetect when a subclass of \nAndroid.App.Application\n is missing the peer connection constructor. See \nApplication Requires Peer Connection Constructor\n.\n\n\nActivity icons should be a mip map not a drawable\n.\n\n\n\n\n\n\nXamarin.Forms C# Code Diagnostics\n\n\nWhen using the \nExportRendererAttribute\n, validate that the first argument is a view or view cell and the second argument is a renderer. See \nIncorrect Activity Creation\n.\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nAdded a \nFeedback\n menu into the \nHelp\n -\n \nMFractor\n menu. Use this menu to file bug reports and feature requests.\n\n\nThe \nGenerate Property Into Class\n now infers the type of the new property based on the attributes value and name. This behaviour can be disabled through the configuration engine.\n\n\nIssues that detect redundant XAML now grey out that code section.\n\n\nIssues that detect code improvements now underline that code segment.\n\n\nSignificantly improved analysis times for XAML documents.\n\n\nReduced memory consumption across the entire product.\n\n\nThe following code analysers have been removed:\n\n\nDetect when an abstract class was used in XAML. This caused false errors.\n\n\nDetect when the root XAML node has an x:Name declaration; it's likely the developer wants to reference the root element inside an \nx:Reference\n markup extension.\n\n\n\n\n\n\nThe bindable property generator can now generate a property with either an expression body or a return statement.\n\n\nSignificantly more configurable properties have been exposed throughout the product. Browse the docs site to see what you can change!\n\n\n\n\nBug Fixes\n\n\n\n\nFixed: Often the XAML analyser would fail to remove code-issue markers.\n\n\nFixed: Custom markup extension symbols would not be detected and would cause the unused XAML namespace analyser to trigger.\n\n\nFixed: The Android resource tooltips would not render over C# resource usages. EG: \nResource.Layout.myLayout\n.\n\n\nFixed: Image tooltips now work in shared projects.\n\n\nFixed: Image tooltips now work when the image source is referring to a nested image under a folder. EG: \"Icons/logo.png\" inside the iOS Resources folder.\n\n\nFixed: Using the \nListView CachingStrategy\n property in XAML no longer generates an unknown property warning.\n\n\nFixed: Multiple potential null access that would cause the XAML analyser to fail.\n\n\nFixed: When using \nGo-To XAML symbol\n on a class with a XAML view and code-behind, don't include the auto-generated designer class as an option and jump straight to the code-behind.\n\n\nFixed: When using \nGo-To Code Behind Class\n, don't include the auto-generated designer class as an option and jump straight to the code-behind.", 
            "title": "v3.1"
        }, 
        {
            "location": "/release-notes/v3-1/#release-notes-v310", 
            "text": "July 13th 2017", 
            "title": "Release Notes - v3.1.0"
        }, 
        {
            "location": "/release-notes/v3-1/#introduction", 
            "text": "This is a summary of the changes introduced in v3.1.0 of MFractor for Visual Studio Mac.  We have rebranded our free tier into  MFractor Lite  and our paid tier into  MFractor Professional . This is to better reflect the value difference between the different licensing levels.  In terms of features, this release adds a new on-boarding window to make it as easy as possible to learn to use MFractor. We've also added a suite of new professional features for C# and Android, a  heap  of bug fixes and a few handy XAML refactorings.  Lastly, we are slowly working through the documentation and adding a comprehensive explanation for each MFractor feature. This is ongoing and will take some time to complete.", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v3-1/#lite-features", 
            "text": "Onboarding Window : When MFractor is first installed, after activation, we now display an onboarding window to teaches you the fundamentals of using MFractor.  XAML Code Actions  Quickly migrate to the new  OnPlatform  methodology with the  Migrate OnPlatform Usage  code action.  Generate a new view from an unknown XAML node as a XAML view with a code behind class.    XAML Code Analysis  For  Style s, inspect that it sets a  TargetType  attribute.  For  Style   Setter s, inspect that the  Property  value maps to a property in the type provided byt the   Style s  TargetType  attribute.", 
            "title": "Lite Features"
        }, 
        {
            "location": "/release-notes/v3-1/#professional-features", 
            "text": "XAML  For XAML attributes that accept an  ImageSource , detect missing image resources in Android and iOS projects and offer the ability to easily import those images using the quick fix menu.    C# Code Actions  Implement all of a base classes constructors onto the class. See  Implement Base Class Constructors .  When a class ends with  Attribute , use the  Make Class Inherit From System.Attribute  code action to add attribute inheritance.  Quickly assign closely named constructor arguments to fields and properties using the  Assign Constructor Argument To Member  C# code action.  Use  Annotate With Attribute Usage  to add a  AttributeUsage  attribute to a class that inherits from  System.Attribute .  Use the  Create Immutable Constructor  code action to generate a constructor that initializes all readonly fields from constructor arguments.    Android C# Code Diagnostics  Detect when a developer tries to manually create an  Activity  with new statement. See  Incorrect Activity Creation .  Detect when a developer directly implements the  IJavaObject  interface instead of inheriting from  Java.Lang.Object . See  Class Derives From IJavaObject .  Detect when a subclass of  Android.App.Application  is missing the peer connection constructor. See  Application Requires Peer Connection Constructor .  Activity icons should be a mip map not a drawable .    Xamarin.Forms C# Code Diagnostics  When using the  ExportRendererAttribute , validate that the first argument is a view or view cell and the second argument is a renderer. See  Incorrect Activity Creation .", 
            "title": "Professional Features"
        }, 
        {
            "location": "/release-notes/v3-1/#enhancements", 
            "text": "Added a  Feedback  menu into the  Help  -   MFractor  menu. Use this menu to file bug reports and feature requests.  The  Generate Property Into Class  now infers the type of the new property based on the attributes value and name. This behaviour can be disabled through the configuration engine.  Issues that detect redundant XAML now grey out that code section.  Issues that detect code improvements now underline that code segment.  Significantly improved analysis times for XAML documents.  Reduced memory consumption across the entire product.  The following code analysers have been removed:  Detect when an abstract class was used in XAML. This caused false errors.  Detect when the root XAML node has an x:Name declaration; it's likely the developer wants to reference the root element inside an  x:Reference  markup extension.    The bindable property generator can now generate a property with either an expression body or a return statement.  Significantly more configurable properties have been exposed throughout the product. Browse the docs site to see what you can change!", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v3-1/#bug-fixes", 
            "text": "Fixed: Often the XAML analyser would fail to remove code-issue markers.  Fixed: Custom markup extension symbols would not be detected and would cause the unused XAML namespace analyser to trigger.  Fixed: The Android resource tooltips would not render over C# resource usages. EG:  Resource.Layout.myLayout .  Fixed: Image tooltips now work in shared projects.  Fixed: Image tooltips now work when the image source is referring to a nested image under a folder. EG: \"Icons/logo.png\" inside the iOS Resources folder.  Fixed: Using the  ListView CachingStrategy  property in XAML no longer generates an unknown property warning.  Fixed: Multiple potential null access that would cause the XAML analyser to fail.  Fixed: When using  Go-To XAML symbol  on a class with a XAML view and code-behind, don't include the auto-generated designer class as an option and jump straight to the code-behind.  Fixed: When using  Go-To Code Behind Class , don't include the auto-generated designer class as an option and jump straight to the code-behind.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v3-0/", 
            "text": "Release Notes - v3.0.0\n\n\n23rd May 2017\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v3.0.0 of MFractor for Visual Studio Mac.\n\n\nThis release supports Visual Studio for Mac.\n\n\nThis release adds the ability to control MFractor through configuration files; this enables developers to change MFractor's behavior when refactoring, analyzing and generating code.\n\n\nFeatures\n\n\n\n\nVisual Studio For Mac Support!\n\n\nProfessional Onky\n The new config file system enables customization the code generated by MFractor. Create a new file with the extension \n.mfc\n or \n.mfc.xml\n in your project and influence MFractor's internals using the \nconfigure id=\"com.mfractor.XXX\"/\n and \nproperty name=\"Name\" value=\"Value\"/\n syntax. A full tutorial on configuration is [available here].\n\n\nNew Code Analysers\n\n\nDetect when a \nContentView\n has multiple child elements.\n\n\nDetect when a \nContentPage\n has multiple child elements.\n\n\nDetect when a \nMyView.Resources\n resource dictionary setter contains anything but a \nResourceDictionary\n declaration.\n\n\n\n\n\n\nNew Code Generators\n\n\nWhen on a \nGrid.RowDefinitions\n element, the new code generator \nAdd RowDefinition\n will insert a new row definition element.\n\n\nWhen on a \nGrid.ColumnDefinitions\n element, the new code generator \nAdd ColumnDefinition\n will insert a new column definition element.\n\n\n\n\n\n\nNew Code Organisation\n\n\nWhen the root xaml node has unused namespaces, activate \nRemoved Unused Namespaces\n to cleanup all unused xaml namespaces.\n\n\n\n\n\n\nNew Code Fixes\n\n\nWhen a \nMyView.Resources\n property setter contains anything but a \nResourceDictionary\n declaration allow the user to wrap the element declarations with a resource dictionary.\n\n\nWhen the result of a binding expression does not match the input type of the outer attribute and a value converter has a \nValueConversion\n that resolves it, generate a \nConverter=\n expression and import the value converter as resource.\n\n\nWhen the result of a binding expression does not match the input type of the outer attribute, generate an \nIValueConverter\n implementation that resolves the type-flow, generate a \nConverter=\n expression and import the value converter as resource.\n\n\n\n\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nAndroid Layout analysis and IntelliSense has been disabled. It interfered with the stock Xamarin IntelliSense and regressed the layout editors user experience. This will be revisited at a later date.\n\n\nOnly show code fixes in the quick fix menu when it's activated over a code issue. This reduces noise and improves usability.\n\n\nIn Xaml, color literals (EG: #AAA) are now underlined with the color value. This makes it easy to visually see the color at a glance.\n\n\nPress \nAlt+Shift+1\n to jump to the \nview model\n for a code behind or xaml view.\n\n\nPress \nAlt+Shift+2\n to jump to the \ncode behind\n for a view model or xaml view.\n\n\nPress \nAlt+Shift+3\n to jump to the \nxaml view\n for a code behind or view model.\n\n\nSignificantly improved speed/performance of the MVVM navigation shortcut suite.\n\n\nThe \nSimply Static Assignment\n organise code action has been removed as it added no tangible value.\n\n\n\n\nBug Fixes\n\n\n\n\nFixed: Passing \n.\n into a binding expression to reference the binding context would cause an analysis error. Using \n.\n will now correctly resolve to the binding context.\n\n\nFixed: MFractor now detects when the \nBindingContext\n of a Xaml element is specified using a property setter node (\nView.BindingContext\n \nvm:MyViewModel\n \n/View.BindingContext\n).\n\n\nFixed: Generate code files into shared projects when the source xaml is in a shared project.\n\n\nFixed: Don't allow view model creation from the App.xaml.\n\n\nFixed: Don't check for x:Key attributes on \nStyle/\n elements; no x:Key means the style is the implicit control style.\n\n\nFixed: Detect .NET symbol references that are within attributes whose type is \nSystem.Type\n to include them in namespace refactoring and unused namespace detection.", 
            "title": "v3.0"
        }, 
        {
            "location": "/release-notes/v3-0/#release-notes-v300", 
            "text": "23rd May 2017", 
            "title": "Release Notes - v3.0.0"
        }, 
        {
            "location": "/release-notes/v3-0/#introduction", 
            "text": "This is a summary of the changes introduced in v3.0.0 of MFractor for Visual Studio Mac.  This release supports Visual Studio for Mac.  This release adds the ability to control MFractor through configuration files; this enables developers to change MFractor's behavior when refactoring, analyzing and generating code.", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v3-0/#features", 
            "text": "Visual Studio For Mac Support!  Professional Onky  The new config file system enables customization the code generated by MFractor. Create a new file with the extension  .mfc  or  .mfc.xml  in your project and influence MFractor's internals using the  configure id=\"com.mfractor.XXX\"/  and  property name=\"Name\" value=\"Value\"/  syntax. A full tutorial on configuration is [available here].  New Code Analysers  Detect when a  ContentView  has multiple child elements.  Detect when a  ContentPage  has multiple child elements.  Detect when a  MyView.Resources  resource dictionary setter contains anything but a  ResourceDictionary  declaration.    New Code Generators  When on a  Grid.RowDefinitions  element, the new code generator  Add RowDefinition  will insert a new row definition element.  When on a  Grid.ColumnDefinitions  element, the new code generator  Add ColumnDefinition  will insert a new column definition element.    New Code Organisation  When the root xaml node has unused namespaces, activate  Removed Unused Namespaces  to cleanup all unused xaml namespaces.    New Code Fixes  When a  MyView.Resources  property setter contains anything but a  ResourceDictionary  declaration allow the user to wrap the element declarations with a resource dictionary.  When the result of a binding expression does not match the input type of the outer attribute and a value converter has a  ValueConversion  that resolves it, generate a  Converter=  expression and import the value converter as resource.  When the result of a binding expression does not match the input type of the outer attribute, generate an  IValueConverter  implementation that resolves the type-flow, generate a  Converter=  expression and import the value converter as resource.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v3-0/#enhancements", 
            "text": "Android Layout analysis and IntelliSense has been disabled. It interfered with the stock Xamarin IntelliSense and regressed the layout editors user experience. This will be revisited at a later date.  Only show code fixes in the quick fix menu when it's activated over a code issue. This reduces noise and improves usability.  In Xaml, color literals (EG: #AAA) are now underlined with the color value. This makes it easy to visually see the color at a glance.  Press  Alt+Shift+1  to jump to the  view model  for a code behind or xaml view.  Press  Alt+Shift+2  to jump to the  code behind  for a view model or xaml view.  Press  Alt+Shift+3  to jump to the  xaml view  for a code behind or view model.  Significantly improved speed/performance of the MVVM navigation shortcut suite.  The  Simply Static Assignment  organise code action has been removed as it added no tangible value.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v3-0/#bug-fixes", 
            "text": "Fixed: Passing  .  into a binding expression to reference the binding context would cause an analysis error. Using  .  will now correctly resolve to the binding context.  Fixed: MFractor now detects when the  BindingContext  of a Xaml element is specified using a property setter node ( View.BindingContext   vm:MyViewModel   /View.BindingContext ).  Fixed: Generate code files into shared projects when the source xaml is in a shared project.  Fixed: Don't allow view model creation from the App.xaml.  Fixed: Don't check for x:Key attributes on  Style/  elements; no x:Key means the style is the implicit control style.  Fixed: Detect .NET symbol references that are within attributes whose type is  System.Type  to include them in namespace refactoring and unused namespace detection.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v2/", 
            "text": "**IMPORTANT: MFractor v2 is only supported on Xamarin Studio. To use MFractor in Visual Studio Mac, please install \nMFractor v3 and above\n.\n\n\nRelease Notes - v2.10.0\n\n\n6th March 2017\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.10.2 of MFractor for Visual Studio Mac.\n\n\nThis release is all about improving MFractors usability. You can now tap Alt+Return in Xaml documents to quickly access any fixes or refactorings at that location, the xaml analyser has been tuned for speed and a new code issue tooltip gives deeper insight into the code issue beneath it:\n\n\n\n\nFeatures\n\n\n\n\nThe quick fix menu is now available to quickly access all Xaml actions. Tap Alt+Return in your Xaml document for a list of available code actions to appear!\n\n\nThe xaml analyser integration has been rebuilt and as such, xaml analysis is now much, much quicker. You might notice that fixable issues no longer underline in yellow; the check for available fixes is now.\n\n\nAn improved code issue tooltip now appears when you hover over a xaml or android resource. This tooltip tells you what kind of error it is (Compile time, runtime or code improvement), presents information on the issue and let's you know if any fixes are available.\n\n\n\n\nEnhancements\n\n\n\n\nImprove the can execute checking algorithms for all code actions (refactorings, issue fixes etc) to reduce the noise in the quick fix menu.\n\n\n\n\nBug Fixes\n\n\n\n\nFixed: When generating a view model and the view has bindings against an unknown class, previously these bindings would be missed.\n\n\n\n\nRelease Notes - v2.9.4\n\n\n22nd February 2017\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.9.4 of MFractor for Visual Studio Mac.\n\n\nImportant: If Visual Studio Mac loses IntelliSense/Code Completion when you update to cycle 9 (XS v6.2), uninstall MFractor and upgrade to the latest version\n\n\nThis release focuses on keeping your Xaml tidy... you can now rename xaml namespaces, align the naming of duplicate namespace imports and format your entire Xaml document.\n\n\nIt's also easier than ever to build out custom controls, the new \nImplement Missing Members\n code generator can bulk implement properties or bindable properties onto custom views in your Xaml. No need to hand code bindable properties!\n\n\nHold onto your socks!\n\n\n\n\nFeatures\n\n\n\n\nNew Refactorings\n\n\nRight click on an \nxmlns\n declaration on the root node and select \nRefactor\n -\n \nRename Xaml Namespace\n to rename all occurrences of that namespace in the doc!\n\n\nNew Code Organisers\n\n\nRight click on the root xaml node and select \nOrganise\n -\n \nFormat\n to organise your entire xaml document.\n\n\nNew Code Generators\n\n\nQuickly build out Grids by using the \nInsert Row Definitions\n and \nInsert Column Definitions\n actions.\n\n\nBulk implement missing properties on a class by right clicking on the xaml node with the missing members and selecting \nImplement missing members\n.\n\n\nNew Xaml Analysers\n\n\nDetect if the root xaml element uses a \nx:Name\n attribute as this is redundant.\n\n\nDetect duplicate xaml namespaces that reference the same namespace and assembly.\n\n\nDetect when the xaml views code behind class derives from a different type than what is declared by it's root element.\n\n\nNew Code Fixes\n\n\nWhen a xaml namespace references the same namespace and assembly, you can now rename all duplicate namespace declarations to a certain namespace to align the usages in your xaml.\n\n\n\n\nEnhancements\n\n\n\n\nFreshMVVM style page models (EG: LoginPageModel) are now supported for view \n-\n view model \n-\n code behind association.\n\n\nThe \nModel\n suffix (EG: LoginModel) is now supported for view \n-\n view model \n-\n code behind association.\n\n\nThis release targets Visual Studio Mac v6.2.\n\n\n\n\nBug Fixes\n\n\n\n\nUndefined StaticResource detection has been disabled in this release.\n\n\nFixed: When generating view models, if a binding expression was within an undefined control property, the refactoring would fail as it could not resolve the member type. Undefined properties will now auto-generate using \nSystem.Object\n.\n\n\nFixed: When generating a static property from an x:Static expression whose outer attribute is unresolved, now default to use \nSystem.Object\n.\n\n\nFixed: When generating members or static properties onto a code behind class, sometimes the insertion point would jump to the xaml.g.cs auto-generated class.\n\n\nFixed: When the Visual Studio Mac Xamarin Forms Previewer is open, the refactoring engine would fail to commit text replace changes.\n\n\n\n\nRelease Notes - v2.8.0\n\n\n12th February 2017\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.8.0 of MFractor for Visual Studio Mac.\n\n\nThis release focuses on adding new refactoring and code generation actions into the Xaml editor.\n\n\nYou can now sort your xaml, edit colors interactively, extract values into binding expressions and more:\n\n\n\n\nFeatures\n\n\n\n\nNew Refactorings\n\n\nRight click on a xaml attribute property that's a \nSystem.Drawing.Color\n or a \nXamarin.Forms.Color\n and edit it using the color selection dialog. This action won't be available if the attribute value is an expression.\n\n\nRight click on a xaml attribute property that has a literal value and extract it into a \nBinding\n expression. This action is not available if the attribute value is an expression or the attribute does not have a corresponding bindable property.\n\n\nOrganise Refactorings:\n\n\nThe \nCollapse Xaml Attributes\n refactoring will collapse all xaml attributes onto the same line as the parent xaml node.\n\n\nThe \nExpand Xaml Attributes\n refactoring will expand all xaml attributes onto separate lines.\n\n\nThe \nSort Xaml Attributes\n refactoring will sort the attributes for a xaml node by namespace and name.\n\n\nThe \nExpand Node\n refactoring takes a self-closing xaml node and generate a closing tag for it.\n\n\nThe \nCollapse Node\n refactoring takes a xaml node with no children and a closing tag and removes the closing tag to make the node self-closing.\n\n\n\n\n\n\n\n\n\n\nNew Code Generators\n\n\nRight click on an xaml node that inherits from \nXamarin.Forms.VisualElement\n or \nXamarin.Forms.Application\n and select \nAdd Resource Dictionary\n to generate a resource dictionary for that element.\n\n\n\n\n\n\nNew Xaml Analysers\n\n\nDetect when an \nx:Name\n code-behind field declaration is empty.\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nThis release targets Visual Studio Mac v6.1.5\n\n\nThe \nImplement View Model\n refactoring has been moved from the \nRefactor\n menu to \nGenerate\n.\n\n\nHover over a xaml attribute property that's a \nSystem.Drawing.Color\n or a \nXamarin.Forms.Color\n to see the color value inside the tooltip.\n\n\nThe Android SDK meta-data has been removed from MFractor.mpack; you can download and update the sdk meta-data through the \nHelp\n -\n \nMFractor\n -\n \nInstall Android SDK Meta-Data\n menu item.\n\n\n\n\nBug Fixes\n\n\n\n\nCorrectly validate the type provided to x:TypeArguments; there was a bug in the type checking algorithm.\n\n\nDon't allow the 'Simplify' refactoring to run against expressions.\n\n\nFix multiple type conversion checking bugs in the ValueConversion attribute validation.\n\n\n\n\nRelease Notes - v2.7.0\n\n\n8th January 2017\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.7.0 of MFractor for Visual Studio Mac.\n\n\nThis release adds the ability implement entire view models, introduces a dozen xaml analysers and fixes many bugs.\n\n\nI recommend taking a moment to read these tutorials:\n\n\n\n\nImplementing View Models\n: Learn implement entire view models using the \nImplement View Model\n refactoring.\n\n\nValue Converter Type Safety\n: Learn to annotate \nIValueConverter\ns with value conversion attributes for \nConverter\n expression type-safety.\n\n\n\n\nIntroducing View Model Generation\n\n\nYou already love being able to generate bindings but I've taken it to the next level this release \ud83d\udcaa\n\n\n\n\nGot a heap of unimplemented bindings? Right click anywhere in your Xaml document and select \nRefactor\n -\n \nImplement View Model\n.\n\n\nMFractor will collect all the missing bindings and then generate a new class with \nall\n of those properties into a namespace named \nMyDefaultNamespace.ViewModels\n.\n\n\nDoes the view model already exist? Then MFractor simply inserts the missing bindings into the existing view model.\n\n\nI think it'll save you enough time during the week that you may just get to Friday beers a few hours early \ud83c\udf7b\n\n\nFeatures\n\n\n\n\nBy right clicking anywhere in a Xaml document, implement all missing bindings as a new or into an existing view model:\n\n\nImplement view model properties with a getter and setter.\n\n\nImplement view model properties with a backing field.\n\n\nBound properties that return \nICommand\n will have an empty \nXamarin.Forms.Command\n instance generated.\n\n\nWhen MFractor encounters binding expressions that use a \nConverter\n, it inspects the converter for a \nValueConversion\n attribute to deduce the input typed required. If it can't resolve the converter or the converter does not have value conversion information, it will default to using \nSystem.Object\n.\n\n\nWhen implementing a new view model with getter and setters, MFractor will inspect for references to Fody's \nImplementPropertyChanged\n and annotate the new class with it.\n\n\n\n\n\n\nNew Xaml Analysers:\n\n\nValidate that elements declared inside a resource dictionary have an x:Key.\n\n\nValidate that elements declared inside a resource dictionary have a unique x:Key value.\n\n\nDetect when an x:TypeArguments is used on a non-generic type and warn of incorrect usage.\n\n\nDetect when a property setter node (\nMyClass.MyProperty/\n) references a non-existent member on the parent class.\n\n\nDetect when a property setter attribute is empty.\n\n\nDetect when an undefined static resource is referenced by a \nStaticResource\n expression.\n\n\nDetect when the value returned by a \nStaticResource\n expression causes a type mismatch.\n\n\nDetect when an unknown type is being provided to a \nx:TypeArguments\n attribute.\n\n\nValidate that \nOnIdiom\n elements return the correct type for the outer property setter.\n\n\nValidate that \nOnPlatform\n elements return the correct type for the outer property setter.\n\n\nDetect when a developer has misused a property setter inside another xaml element. For example, \nOnIdiom.Phone\n doesn't make any sense when wrapped by the outer element \nOnPlatform\n.\n\n\nDetect when an incorrect input type is provided to a \nConverter\n. The value converter must have a \nValueConversion\n attribute for this to trigger.\n\n\nDetect when an incorrect output type is returned by a \nConverter\n expression. The value converter must have a \nValueConversion\n attribute for this to trigger.\n\n\nDetect when multiple occurrences of the same automation ID exists within a Xaml document.\n\n\n\n\n\n\nNew Xaml Fixes:\n\n\nGenerate missing resource dictionary keys.\n\n\nAuto-correct misspelt \nStaticResource\n references.\n\n\n\n\n\n\nNew Simplify Refactorings:\n\n\nAttributes that use a static instance to initialize the property (eg \nVerticalOptions=\"LayoutOptions.CentreAndExpand\"\n) can now be simplified to just the instance name (eg \nVerticalOptions=\"CentreAndExpand\"\n).\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nThis release targets Visual Studio Mac v6.1.3\n\n\nThe \nAbout MFractor\n dialog now contains a button to copy version and IDE information into the clipboard for bug reports.\n\n\nThis release introduces the framework for an Xml and Xaml refactoring engine. Over time, I'll be adding Xml and Xaml refactoring operations to make code cleanup a breeze.\n\n\nAnnotating value converters with a \nValueConversion(typeof(InputType), typeof(OutputType))\n attribute will trigger the conversion information to render into tooltip. See \nFormsCommunityToolkit.Converters\n for examples.\n\n\n\n\nBug Fixes\n\n\n\n\nSometimes the Xaml document analyser would fail to load and bring down the Xaml editor. This has been fixed.\n\n\nThe View \n - \n Code Behind navigation shortcuts would break when an AST parse was in progress. View \n - \n Code Behind shortcuts will now always be active.\n\n\nWhen property setter nodes are used (\nMyClass.MyProperty/\n), the class component is now correctly validated.\n\n\nWhen importing a Xaml namespace, the element is inserted on a newline and formatted to align with other attributes.\n\n\nWhen resolving the binding context for nested DataTemplates, sometimes the binding context resolver would fail on generics or IEnumerables\n\n\nMore resilient Mvvm resolver to drive the 'Go To View Model', 'Go To Xaml View' and 'Go To Code Behind' shortcuts. MFractor will attempt to infer as best possible the associations between those 3 files.\n\n\nSave the project after adding a new file to it.\n\n\n\n\nRelease Notes - v2.6.0\n\n\n31st October 2016\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.6.0 of MFractor for Visual Studio Mac.\n\n\nAs a major release, this release adds several code generation capabilities to improve your Xaml workflow. Generate views, classes and value converters in only a few clicks...\n\n\nJust right click on that little yellow squiggle and use the fix to generate a whole lotta code.\n\n\nThere are also more xaml code checks to watch out for nasty Xaml issues and bug fixes galore.\n\n\nEnjoy!\n\n\nFeatures\n\n\n\n\nNew code generation actions:\n\n\nGenerate classes from \nmy_namespace:MyMissingClass\n in xaml.\n\n\nGenerate views from \nmy_namespace:MyMissingView\n in xaml.\n\n\nGenerate value converters when a missing xaml node ends with \"[cC]onverter] in xaml.\n\n\n\n\n\n\nNew Xaml analysers:\n\n\nFor generics, validate that an x:TypeArguments attribute or xml node setter exists.\n\n\nFor generics, validate that the count of parameters provided to x:TypeArguments matches the generics signature.\n\n\nValidate the root xaml node contains an x:Class directive to set the code behind class name and namespace.\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nThis release targets Visual Studio Mac v6.1.1\n\n\n\n\nBug Fixes\n\n\n\n\nFix a bug in xaml namespace resolution that prevented the \"import new xmlns\" fix from triggering.\n\n\nAllow importing of xaml namespaces from x:Static symbols.\n\n\nFor Setters, don't validate TargetType property that the provided type is a static member of System.Type.\n\n\nWhen a symbol name matches but its in the wrong namespace, don't suggest it as a fix.\n\n\nRemove the MFractor settings panel to fix the Visual Studio Mac preferences dialog from not opening when it didn't exist.\n\n\nWhen using native view declaration, the xaml symbolicator will now honor the targetPlatform flag and find the assembly for that platform. Previously this was a naive search that used the first assembly found; using the wrong symbols if a assembly of the same name existed in both an iOS and Android project.\n\n\n\n\nRelease Notes - v2.5.3\n\n\n10th of October 2016\n\n\nIntroduction\n\n\nThis is a summary of the changes introduced in v2.5.3 of MFractor for Visual Studio Mac.\n\n\nThis release adds support for native view declaration and property generation for missing view attributes.\n\n\nFeatures\n\n\n\n\nGenerate properties and bindable properties onto classes that implement Xamarin.Forms.ObservableObject.\n\n\nFull support for native view declaration. Tooltips, go-to declaration, xaml analysis and code generation enabled on native views used in Xaml.\n\n\n\n\nBug Fixes\n\n\n\n\nXaml expressions now parsed on attributes that cannot be resolved to a .NET symbol. This enables Tooltips, go-to declaration, xaml analysis and code generation.\n\n\nThe analysis engine no longer assumes that the Xamarin.Forms and Microsoft schemas are the implicit and 'x' namespaces. This means that Xamarin.Forms could be remapped to xmlns:xf etc and the xaml analyser will still function correctly.", 
            "title": "v2"
        }, 
        {
            "location": "/release-notes/v2/#release-notes-v2100", 
            "text": "6th March 2017", 
            "title": "Release Notes - v2.10.0"
        }, 
        {
            "location": "/release-notes/v2/#introduction", 
            "text": "This is a summary of the changes introduced in v2.10.2 of MFractor for Visual Studio Mac.  This release is all about improving MFractors usability. You can now tap Alt+Return in Xaml documents to quickly access any fixes or refactorings at that location, the xaml analyser has been tuned for speed and a new code issue tooltip gives deeper insight into the code issue beneath it:", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2/#features", 
            "text": "The quick fix menu is now available to quickly access all Xaml actions. Tap Alt+Return in your Xaml document for a list of available code actions to appear!  The xaml analyser integration has been rebuilt and as such, xaml analysis is now much, much quicker. You might notice that fixable issues no longer underline in yellow; the check for available fixes is now.  An improved code issue tooltip now appears when you hover over a xaml or android resource. This tooltip tells you what kind of error it is (Compile time, runtime or code improvement), presents information on the issue and let's you know if any fixes are available.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2/#enhancements", 
            "text": "Improve the can execute checking algorithms for all code actions (refactorings, issue fixes etc) to reduce the noise in the quick fix menu.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v2/#bug-fixes", 
            "text": "Fixed: When generating a view model and the view has bindings against an unknown class, previously these bindings would be missed.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v2/#release-notes-v294", 
            "text": "22nd February 2017", 
            "title": "Release Notes - v2.9.4"
        }, 
        {
            "location": "/release-notes/v2/#introduction_1", 
            "text": "This is a summary of the changes introduced in v2.9.4 of MFractor for Visual Studio Mac.  Important: If Visual Studio Mac loses IntelliSense/Code Completion when you update to cycle 9 (XS v6.2), uninstall MFractor and upgrade to the latest version  This release focuses on keeping your Xaml tidy... you can now rename xaml namespaces, align the naming of duplicate namespace imports and format your entire Xaml document.  It's also easier than ever to build out custom controls, the new  Implement Missing Members  code generator can bulk implement properties or bindable properties onto custom views in your Xaml. No need to hand code bindable properties!  Hold onto your socks!", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2/#features_1", 
            "text": "New Refactorings  Right click on an  xmlns  declaration on the root node and select  Refactor  -   Rename Xaml Namespace  to rename all occurrences of that namespace in the doc!  New Code Organisers  Right click on the root xaml node and select  Organise  -   Format  to organise your entire xaml document.  New Code Generators  Quickly build out Grids by using the  Insert Row Definitions  and  Insert Column Definitions  actions.  Bulk implement missing properties on a class by right clicking on the xaml node with the missing members and selecting  Implement missing members .  New Xaml Analysers  Detect if the root xaml element uses a  x:Name  attribute as this is redundant.  Detect duplicate xaml namespaces that reference the same namespace and assembly.  Detect when the xaml views code behind class derives from a different type than what is declared by it's root element.  New Code Fixes  When a xaml namespace references the same namespace and assembly, you can now rename all duplicate namespace declarations to a certain namespace to align the usages in your xaml.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2/#enhancements_1", 
            "text": "FreshMVVM style page models (EG: LoginPageModel) are now supported for view  -  view model  -  code behind association.  The  Model  suffix (EG: LoginModel) is now supported for view  -  view model  -  code behind association.  This release targets Visual Studio Mac v6.2.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v2/#bug-fixes_1", 
            "text": "Undefined StaticResource detection has been disabled in this release.  Fixed: When generating view models, if a binding expression was within an undefined control property, the refactoring would fail as it could not resolve the member type. Undefined properties will now auto-generate using  System.Object .  Fixed: When generating a static property from an x:Static expression whose outer attribute is unresolved, now default to use  System.Object .  Fixed: When generating members or static properties onto a code behind class, sometimes the insertion point would jump to the xaml.g.cs auto-generated class.  Fixed: When the Visual Studio Mac Xamarin Forms Previewer is open, the refactoring engine would fail to commit text replace changes.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v2/#release-notes-v280", 
            "text": "12th February 2017", 
            "title": "Release Notes - v2.8.0"
        }, 
        {
            "location": "/release-notes/v2/#introduction_2", 
            "text": "This is a summary of the changes introduced in v2.8.0 of MFractor for Visual Studio Mac.  This release focuses on adding new refactoring and code generation actions into the Xaml editor.  You can now sort your xaml, edit colors interactively, extract values into binding expressions and more:", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2/#features_2", 
            "text": "New Refactorings  Right click on a xaml attribute property that's a  System.Drawing.Color  or a  Xamarin.Forms.Color  and edit it using the color selection dialog. This action won't be available if the attribute value is an expression.  Right click on a xaml attribute property that has a literal value and extract it into a  Binding  expression. This action is not available if the attribute value is an expression or the attribute does not have a corresponding bindable property.  Organise Refactorings:  The  Collapse Xaml Attributes  refactoring will collapse all xaml attributes onto the same line as the parent xaml node.  The  Expand Xaml Attributes  refactoring will expand all xaml attributes onto separate lines.  The  Sort Xaml Attributes  refactoring will sort the attributes for a xaml node by namespace and name.  The  Expand Node  refactoring takes a self-closing xaml node and generate a closing tag for it.  The  Collapse Node  refactoring takes a xaml node with no children and a closing tag and removes the closing tag to make the node self-closing.      New Code Generators  Right click on an xaml node that inherits from  Xamarin.Forms.VisualElement  or  Xamarin.Forms.Application  and select  Add Resource Dictionary  to generate a resource dictionary for that element.    New Xaml Analysers  Detect when an  x:Name  code-behind field declaration is empty.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2/#enhancements_2", 
            "text": "This release targets Visual Studio Mac v6.1.5  The  Implement View Model  refactoring has been moved from the  Refactor  menu to  Generate .  Hover over a xaml attribute property that's a  System.Drawing.Color  or a  Xamarin.Forms.Color  to see the color value inside the tooltip.  The Android SDK meta-data has been removed from MFractor.mpack; you can download and update the sdk meta-data through the  Help  -   MFractor  -   Install Android SDK Meta-Data  menu item.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v2/#bug-fixes_2", 
            "text": "Correctly validate the type provided to x:TypeArguments; there was a bug in the type checking algorithm.  Don't allow the 'Simplify' refactoring to run against expressions.  Fix multiple type conversion checking bugs in the ValueConversion attribute validation.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v2/#release-notes-v270", 
            "text": "8th January 2017", 
            "title": "Release Notes - v2.7.0"
        }, 
        {
            "location": "/release-notes/v2/#introduction_3", 
            "text": "This is a summary of the changes introduced in v2.7.0 of MFractor for Visual Studio Mac.  This release adds the ability implement entire view models, introduces a dozen xaml analysers and fixes many bugs.  I recommend taking a moment to read these tutorials:   Implementing View Models : Learn implement entire view models using the  Implement View Model  refactoring.  Value Converter Type Safety : Learn to annotate  IValueConverter s with value conversion attributes for  Converter  expression type-safety.", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2/#introducing-view-model-generation", 
            "text": "You already love being able to generate bindings but I've taken it to the next level this release \ud83d\udcaa   Got a heap of unimplemented bindings? Right click anywhere in your Xaml document and select  Refactor  -   Implement View Model .  MFractor will collect all the missing bindings and then generate a new class with  all  of those properties into a namespace named  MyDefaultNamespace.ViewModels .  Does the view model already exist? Then MFractor simply inserts the missing bindings into the existing view model.  I think it'll save you enough time during the week that you may just get to Friday beers a few hours early \ud83c\udf7b", 
            "title": "Introducing View Model Generation"
        }, 
        {
            "location": "/release-notes/v2/#features_3", 
            "text": "By right clicking anywhere in a Xaml document, implement all missing bindings as a new or into an existing view model:  Implement view model properties with a getter and setter.  Implement view model properties with a backing field.  Bound properties that return  ICommand  will have an empty  Xamarin.Forms.Command  instance generated.  When MFractor encounters binding expressions that use a  Converter , it inspects the converter for a  ValueConversion  attribute to deduce the input typed required. If it can't resolve the converter or the converter does not have value conversion information, it will default to using  System.Object .  When implementing a new view model with getter and setters, MFractor will inspect for references to Fody's  ImplementPropertyChanged  and annotate the new class with it.    New Xaml Analysers:  Validate that elements declared inside a resource dictionary have an x:Key.  Validate that elements declared inside a resource dictionary have a unique x:Key value.  Detect when an x:TypeArguments is used on a non-generic type and warn of incorrect usage.  Detect when a property setter node ( MyClass.MyProperty/ ) references a non-existent member on the parent class.  Detect when a property setter attribute is empty.  Detect when an undefined static resource is referenced by a  StaticResource  expression.  Detect when the value returned by a  StaticResource  expression causes a type mismatch.  Detect when an unknown type is being provided to a  x:TypeArguments  attribute.  Validate that  OnIdiom  elements return the correct type for the outer property setter.  Validate that  OnPlatform  elements return the correct type for the outer property setter.  Detect when a developer has misused a property setter inside another xaml element. For example,  OnIdiom.Phone  doesn't make any sense when wrapped by the outer element  OnPlatform .  Detect when an incorrect input type is provided to a  Converter . The value converter must have a  ValueConversion  attribute for this to trigger.  Detect when an incorrect output type is returned by a  Converter  expression. The value converter must have a  ValueConversion  attribute for this to trigger.  Detect when multiple occurrences of the same automation ID exists within a Xaml document.    New Xaml Fixes:  Generate missing resource dictionary keys.  Auto-correct misspelt  StaticResource  references.    New Simplify Refactorings:  Attributes that use a static instance to initialize the property (eg  VerticalOptions=\"LayoutOptions.CentreAndExpand\" ) can now be simplified to just the instance name (eg  VerticalOptions=\"CentreAndExpand\" ).", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2/#enhancements_3", 
            "text": "This release targets Visual Studio Mac v6.1.3  The  About MFractor  dialog now contains a button to copy version and IDE information into the clipboard for bug reports.  This release introduces the framework for an Xml and Xaml refactoring engine. Over time, I'll be adding Xml and Xaml refactoring operations to make code cleanup a breeze.  Annotating value converters with a  ValueConversion(typeof(InputType), typeof(OutputType))  attribute will trigger the conversion information to render into tooltip. See  FormsCommunityToolkit.Converters  for examples.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v2/#bug-fixes_3", 
            "text": "Sometimes the Xaml document analyser would fail to load and bring down the Xaml editor. This has been fixed.  The View   -   Code Behind navigation shortcuts would break when an AST parse was in progress. View   -   Code Behind shortcuts will now always be active.  When property setter nodes are used ( MyClass.MyProperty/ ), the class component is now correctly validated.  When importing a Xaml namespace, the element is inserted on a newline and formatted to align with other attributes.  When resolving the binding context for nested DataTemplates, sometimes the binding context resolver would fail on generics or IEnumerables  More resilient Mvvm resolver to drive the 'Go To View Model', 'Go To Xaml View' and 'Go To Code Behind' shortcuts. MFractor will attempt to infer as best possible the associations between those 3 files.  Save the project after adding a new file to it.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v2/#release-notes-v260", 
            "text": "31st October 2016", 
            "title": "Release Notes - v2.6.0"
        }, 
        {
            "location": "/release-notes/v2/#introduction_4", 
            "text": "This is a summary of the changes introduced in v2.6.0 of MFractor for Visual Studio Mac.  As a major release, this release adds several code generation capabilities to improve your Xaml workflow. Generate views, classes and value converters in only a few clicks...  Just right click on that little yellow squiggle and use the fix to generate a whole lotta code.  There are also more xaml code checks to watch out for nasty Xaml issues and bug fixes galore.  Enjoy!", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2/#features_4", 
            "text": "New code generation actions:  Generate classes from  my_namespace:MyMissingClass  in xaml.  Generate views from  my_namespace:MyMissingView  in xaml.  Generate value converters when a missing xaml node ends with \"[cC]onverter] in xaml.    New Xaml analysers:  For generics, validate that an x:TypeArguments attribute or xml node setter exists.  For generics, validate that the count of parameters provided to x:TypeArguments matches the generics signature.  Validate the root xaml node contains an x:Class directive to set the code behind class name and namespace.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2/#enhancements_4", 
            "text": "This release targets Visual Studio Mac v6.1.1", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v2/#bug-fixes_4", 
            "text": "Fix a bug in xaml namespace resolution that prevented the \"import new xmlns\" fix from triggering.  Allow importing of xaml namespaces from x:Static symbols.  For Setters, don't validate TargetType property that the provided type is a static member of System.Type.  When a symbol name matches but its in the wrong namespace, don't suggest it as a fix.  Remove the MFractor settings panel to fix the Visual Studio Mac preferences dialog from not opening when it didn't exist.  When using native view declaration, the xaml symbolicator will now honor the targetPlatform flag and find the assembly for that platform. Previously this was a naive search that used the first assembly found; using the wrong symbols if a assembly of the same name existed in both an iOS and Android project.", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/release-notes/v2/#release-notes-v253", 
            "text": "10th of October 2016", 
            "title": "Release Notes - v2.5.3"
        }, 
        {
            "location": "/release-notes/v2/#introduction_5", 
            "text": "This is a summary of the changes introduced in v2.5.3 of MFractor for Visual Studio Mac.  This release adds support for native view declaration and property generation for missing view attributes.", 
            "title": "Introduction"
        }, 
        {
            "location": "/release-notes/v2/#features_5", 
            "text": "Generate properties and bindable properties onto classes that implement Xamarin.Forms.ObservableObject.  Full support for native view declaration. Tooltips, go-to declaration, xaml analysis and code generation enabled on native views used in Xaml.", 
            "title": "Features"
        }, 
        {
            "location": "/release-notes/v2/#bug-fixes_5", 
            "text": "Xaml expressions now parsed on attributes that cannot be resolved to a .NET symbol. This enables Tooltips, go-to declaration, xaml analysis and code generation.  The analysis engine no longer assumes that the Xamarin.Forms and Microsoft schemas are the implicit and 'x' namespaces. This means that Xamarin.Forms could be remapped to xmlns:xf etc and the xaml analyser will still function correctly.", 
            "title": "Bug Fixes"
        }
    ]
}