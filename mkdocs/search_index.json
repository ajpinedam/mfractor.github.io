{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome\n\n\nHey there fellow Xamarin developer!\n\n\nWelcome to the documentation for MFractor, the essential productivity tool for Xamarin Studio.\n\n\nHave you ever...\n\n\n\n\nHit runtime issues so obvious you were scratching your head over why code analysis didn't pick it up?\n\n\nBeen frustrated by continuously writing the same boilerplate code?\n\n\nFelt you're doing a LOT of text searching when a class \nshould\n just be a keystroke away?\n\n\n\n\nAs a seasoned Xamarin developer, these problems bit me many times over the years... And they irked me so much that I started building MFractor to solve these issues.\n\n\nMFractor gives you several features so you can make great apps faster:\n\n\n\n\nA comprehensive code analyser turns runtime crashes into in-editor code warnings.\n\n\nA code generation engine auto-magically creates boilerplate code in a few clicks instead of a few hundred keystrokes.\n\n\nA few dozen of navigation improvements remove the friction of navigating your apps source code.\n\n\n\n\nSlowly, I am building the ReSharper for Xamarin Studio and I'm thrilled that you have joined me on the journey.\n\n\nIf something doesn't work quite right or you'd like a sweet new feature added, be patient and contact me:\n\n\n\n\nVia Twitter: Give me a holla at \n@matthewrdev\n\n\nVia Slack: Drop in to chat anytime in the \n#mfractor Xamarin Slack sub-channel\n.\n\n\nVia Email: Shot an email to hello@mfractor.com\n\n\n\n\nFinally, thank you for installing and using MFractor. It means the world to me.\n\n\nMatthew Robbins - Creator of MFractor. \u270c\ufe0f\n\n\nIntroduction\n\n\nMFractor is a comprehensive suite of productivity tools for Xamarin Studio to enable developers to make great apps faster.\n\n\nWith MFractor for Xamarin.Forms, you can:\n\n\nNavigate from Xaml to C# faster with Xaml tooltips, go-to symbol and Mvvm shortcuts.\n\n\n\n\nWrite less Xaml bugs with a Xaml analyser detecting code issues at design time... Then fix those issue in just a few clicks.\n\n\n\n\nGenerate C# code from Xaml such as binding context properties, commands, bindable properties and much, much more.\n\n\n\n\nWith MFractor for Xamarin.Android, you can:\n\n\nNavigate app resources fluently with resource tooltips, go-to resource declaration and find all reference support.\n\n\n\n\nQuickly create xml resources with IntelliSense for \nall\n resource types (not just layouts).\n\n\n\n\nBuild bug free layouts and app resources with Android resource analysis.\n\n\n\n\nAvoid Android specific runtime issues with C# code analysis.\n\n\n\n\nIn these docs, you'll learn how to install MFractor, use MFractor for Xamarin.Forms and use MFractor for Xamarin.Android. By the end of this documentation you'll be a master at leveraging MFractors feature suite to build great apps faster.\n\n\nIf you run into an issue along the way, support for MFractor is available via the following ways:\n - Tweet to @matthewrdev at any time on Twitter.\n - The Xamarin Slack channel has an #mfractor sub-channel. Drop in and chat.\n - Email hello@mfractor.com to contact support.\n\n\nLet's get started by \nInstalling MFractor for Xamarin Studio", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome", 
            "text": "Hey there fellow Xamarin developer!  Welcome to the documentation for MFractor, the essential productivity tool for Xamarin Studio.  Have you ever...   Hit runtime issues so obvious you were scratching your head over why code analysis didn't pick it up?  Been frustrated by continuously writing the same boilerplate code?  Felt you're doing a LOT of text searching when a class  should  just be a keystroke away?   As a seasoned Xamarin developer, these problems bit me many times over the years... And they irked me so much that I started building MFractor to solve these issues.  MFractor gives you several features so you can make great apps faster:   A comprehensive code analyser turns runtime crashes into in-editor code warnings.  A code generation engine auto-magically creates boilerplate code in a few clicks instead of a few hundred keystrokes.  A few dozen of navigation improvements remove the friction of navigating your apps source code.   Slowly, I am building the ReSharper for Xamarin Studio and I'm thrilled that you have joined me on the journey.  If something doesn't work quite right or you'd like a sweet new feature added, be patient and contact me:   Via Twitter: Give me a holla at  @matthewrdev  Via Slack: Drop in to chat anytime in the  #mfractor Xamarin Slack sub-channel .  Via Email: Shot an email to hello@mfractor.com   Finally, thank you for installing and using MFractor. It means the world to me.  Matthew Robbins - Creator of MFractor. \u270c\ufe0f", 
            "title": "Welcome"
        }, 
        {
            "location": "/#introduction", 
            "text": "MFractor is a comprehensive suite of productivity tools for Xamarin Studio to enable developers to make great apps faster.  With MFractor for Xamarin.Forms, you can:  Navigate from Xaml to C# faster with Xaml tooltips, go-to symbol and Mvvm shortcuts.   Write less Xaml bugs with a Xaml analyser detecting code issues at design time... Then fix those issue in just a few clicks.   Generate C# code from Xaml such as binding context properties, commands, bindable properties and much, much more.   With MFractor for Xamarin.Android, you can:  Navigate app resources fluently with resource tooltips, go-to resource declaration and find all reference support.   Quickly create xml resources with IntelliSense for  all  resource types (not just layouts).   Build bug free layouts and app resources with Android resource analysis.   Avoid Android specific runtime issues with C# code analysis.   In these docs, you'll learn how to install MFractor, use MFractor for Xamarin.Forms and use MFractor for Xamarin.Android. By the end of this documentation you'll be a master at leveraging MFractors feature suite to build great apps faster.  If you run into an issue along the way, support for MFractor is available via the following ways:\n - Tweet to @matthewrdev at any time on Twitter.\n - The Xamarin Slack channel has an #mfractor sub-channel. Drop in and chat.\n - Email hello@mfractor.com to contact support.  Let's get started by  Installing MFractor for Xamarin Studio", 
            "title": "Introduction"
        }, 
        {
            "location": "/setup/", 
            "text": "Introduction\n\n\nIn order to start using MFractor, we'll first want to install it.\n\n\nThis section outlines how we can install and activate MFractor after installation.\n\n\nAdditionally, we'll learn how to update and uninstall MFractor.\n\n\nInstall MFractor\n\n\nThe simplest way to install MFractor into Xamarin Studio is by using the MFractor.Installer helper addin.\n\n\nThis addin lives inside the Addin Manager in Xamarin Studio, under \nGallery\n -\n \nIDE extensions\n.\n\n\nOpen up Xamarin Studio and click on the \nXamarin Studio\n then \nAddins...\n\n\n\n\nOnce the Addin Manager opens, click \nGallery\n and under \nIDE extensions\n locate \nMFractor.Installer\n. If this isn't present, hit the \nRefresh\n button to update the Gallery listings.\n\n\n\n\nOnce you've located \nMFractor.Installer\n, left click on it to select it. In the right hand detail view, click \nInstall\n. Xamarin Studio will prompt you for confirmation, click \nInstall\n\n\n\n\nYou will then see a download dialog appear and MFractor will download and install!\n\n\n\n\nNext we need to activate MFractor.\n\n\nActivation\n\n\nAfter installing MFractor, you'll need activate it using your email address.\n\n\nFirst things first, \nclose the Addin Manager\n. There is a known bug that blocks the email entry field from receiving keyboard when the Addin Manager is open. It's a pain and we are working on fixing this.\n\n\nTo activate MFractor, enter you email and then click \nActivate\n.\n\n\n\n\nTada! You are now ready to rock. Why not learn how to use MFractor for \nXamarin.Forms\n or \nXamarin.Android\n next?\n\n\nUpdating\n\n\nMFractor will receive regular updates adding sweet new features and bug fixes so it's important to keep up to date!\n\n\nWhen MFractor installs into Xamarin Studio, it'll register itself into Xamarin Studios addin updater.\n\n\nThis means that Xamarin Studio \nshould\n automatically prompt you that an update is available.\n\n\nHowever, you can check for udpate at any time by opening the \nXamarin Studio\n main menu and selecting \nCheck for Updates...\n\n\n\n\nXamarin Studio will check the MFractor addin server for updates and prompt you to update if there is a new version!\n\n\nUninstalling MFractor\n\n\nYou can uninstall MFractor through the addin manager at any time. We'll be sad to see you go!\n\n\nSelect the \nXamarin Studio\n main menu and then \nAddins\n\n\nUnder \nGallery\n then \nIDE extensions\n select the MFractor addin list item and then click \nUninstall\n\n\nYou will be prompted to uninstall the addin, confirm uninstallation by clicking \nUninstall", 
            "title": "Setup"
        }, 
        {
            "location": "/setup/#introduction", 
            "text": "In order to start using MFractor, we'll first want to install it.  This section outlines how we can install and activate MFractor after installation.  Additionally, we'll learn how to update and uninstall MFractor.", 
            "title": "Introduction"
        }, 
        {
            "location": "/setup/#install-mfractor", 
            "text": "The simplest way to install MFractor into Xamarin Studio is by using the MFractor.Installer helper addin.  This addin lives inside the Addin Manager in Xamarin Studio, under  Gallery  -   IDE extensions .  Open up Xamarin Studio and click on the  Xamarin Studio  then  Addins...   Once the Addin Manager opens, click  Gallery  and under  IDE extensions  locate  MFractor.Installer . If this isn't present, hit the  Refresh  button to update the Gallery listings.   Once you've located  MFractor.Installer , left click on it to select it. In the right hand detail view, click  Install . Xamarin Studio will prompt you for confirmation, click  Install   You will then see a download dialog appear and MFractor will download and install!   Next we need to activate MFractor.", 
            "title": "Install MFractor"
        }, 
        {
            "location": "/setup/#activation", 
            "text": "After installing MFractor, you'll need activate it using your email address.  First things first,  close the Addin Manager . There is a known bug that blocks the email entry field from receiving keyboard when the Addin Manager is open. It's a pain and we are working on fixing this.  To activate MFractor, enter you email and then click  Activate .   Tada! You are now ready to rock. Why not learn how to use MFractor for  Xamarin.Forms  or  Xamarin.Android  next?", 
            "title": "Activation"
        }, 
        {
            "location": "/setup/#updating", 
            "text": "MFractor will receive regular updates adding sweet new features and bug fixes so it's important to keep up to date!  When MFractor installs into Xamarin Studio, it'll register itself into Xamarin Studios addin updater.  This means that Xamarin Studio  should  automatically prompt you that an update is available.  However, you can check for udpate at any time by opening the  Xamarin Studio  main menu and selecting  Check for Updates...   Xamarin Studio will check the MFractor addin server for updates and prompt you to update if there is a new version!", 
            "title": "Updating"
        }, 
        {
            "location": "/setup/#uninstalling-mfractor", 
            "text": "You can uninstall MFractor through the addin manager at any time. We'll be sad to see you go!  Select the  Xamarin Studio  main menu and then  Addins  Under  Gallery  then  IDE extensions  select the MFractor addin list item and then click  Uninstall  You will be prompted to uninstall the addin, confirm uninstallation by clicking  Uninstall", 
            "title": "Uninstalling MFractor"
        }, 
        {
            "location": "/xamarin-forms/quickstart/", 
            "text": "WORK IN PROGRESS\n\n\nOverview\n\n\nMFractor adds 3 distinct features to improve your productivity when building apps using Xamarin.Forms. These are:\n\n\n\n\nXaml Analysis: MFractor inspects Xaml code files for compilation and runtime errors.\n\n\nCode Generation: Generate C# from your Xaml in just a few clicks.\n\n\nStreamlined Xamarin.Forms Navigation: Move between your Xaml and C# code more efficiently.\n\n\n\n\nBefore we jump into how to use these features, let's learn to provide a binding context to MFractor to power it's xaml analysis and navigation shortcuts.\n\n\nCode Generation\n\n\nGenerating Properties\n\n\nGenerating Classes\n\n\nx:Static Code Generation\n\n\nGenerating Views", 
            "title": "Quickstart"
        }, 
        {
            "location": "/xamarin-forms/quickstart/#overview", 
            "text": "MFractor adds 3 distinct features to improve your productivity when building apps using Xamarin.Forms. These are:   Xaml Analysis: MFractor inspects Xaml code files for compilation and runtime errors.  Code Generation: Generate C# from your Xaml in just a few clicks.  Streamlined Xamarin.Forms Navigation: Move between your Xaml and C# code more efficiently.   Before we jump into how to use these features, let's learn to provide a binding context to MFractor to power it's xaml analysis and navigation shortcuts.", 
            "title": "Overview"
        }, 
        {
            "location": "/xamarin-forms/quickstart/#code-generation", 
            "text": "", 
            "title": "Code Generation"
        }, 
        {
            "location": "/xamarin-forms/quickstart/#generating-properties", 
            "text": "", 
            "title": "Generating Properties"
        }, 
        {
            "location": "/xamarin-forms/quickstart/#generating-classes", 
            "text": "", 
            "title": "Generating Classes"
        }, 
        {
            "location": "/xamarin-forms/quickstart/#xstatic-code-generation", 
            "text": "", 
            "title": "x:Static Code Generation"
        }, 
        {
            "location": "/xamarin-forms/quickstart/#generating-views", 
            "text": "", 
            "title": "Generating Views"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/", 
            "text": "Configuring A Binding Context\n\n\nIn Mvvm architected applications, views use a \nBinding Context\n to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through \ndata binding\n; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts \nThe Mvvm Pattern\n article.\n\n\nWhen using MFractor for Xamarin.Forms, we can specify a binding context to get the most out of MFractors xaml analyser. If MFractor can resolve a binding context for a Xaml view, it will consume binding expressions and analyse them. This is tremendously beneficial as MFractor will pickup runtime errors and high-light them directly within the Xaml editor.\n\n\nWe can specify a binding context \nexplicitly\n via in inline Xaml expression or \nimplicitly\n through the use of common MVVM naming conventions.\n\n\nExplicit Binding Context Resolution\n\n\nLet's start with explicitly providing a binding context to MFractor.\n\n\nIn Xamarin.Forms, all views have the property \nBindingContext\n; this specifies the object that a view should data-bind with. When coding with Xaml, we can use the \nx:Static\n markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context:\n\n\n \nEntry BindingContext=\n{x:Static local:MyStaticClass.MyStaticProperty}\n/\n\n\n\n\n\nThis is known as the \nView Model Locator Pattern\n. We implement a static class named \nViewModelLocator\n and use a static, readonly property to return an instance of the object we want our Xaml view to data-bind with. Historically the \nView Model Locator Pattern\n has been used to provide design time data to the Xamarin.Forms Xaml previewer. For a deeper insight into this pattern, read James Montemagnos excellent \nView Model Locator\n article.\n\n\nFor example, given a Xaml page named \nLoginPage\n, we could explicitly provide an instance of \nLoginViewModel\n as the binding context like so:\n\n\nView Model Locator\n\n\npublic namespace MyApp\n{\n  public static class ViewModelLocator\n  {\n      public static readonly LoginViewModel LoginViewModel = new LoginViewModel();\n  }\n}\n\n\n\n\nLoginPage.xaml\n\n\nContentPage\n  xmlns:local=\nclr-namespace:MyApp;assembly=MyApp\n\n  BindingContext=\n{x:Static local:ViewModelLocator.LoginViewModel}\n/\n\n\n\n\n\nWhen MFractor begins analysis on LoginPage.xaml it will check if any \nBindingContext\n properties have been assigned to. As the root \nContentPage\n assigns a binding context, it will inspect the value component of the \nBindingContext\n attribute, check if it is a Xaml expression and then evaluate it for the return type.\n\n\nFor the \n{x:Static local:ViewModelLocator.LoginViewModel}\n expression, MFractor will resolve the \nViewModelLocator\n class in the \nlocal\n namespace and then grab the C# type of the \nLoginViewModel\n property. This informs MFractor that the page will be bound to a \nLoginViewModel\n instance and therefore to analyse all \nBinding\n expressions against the \nLoginViewModel\n type.\n\n\nExplicit binding context resolution will also work when referencing another element using \nx:Reference\n expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so:\n\n\n  \nSwitch x:Name=\nmySwitch\n /\n\n  \nLabel BindingContext=\n{x:Reference mySwitch}\n IsVisible=\n{Binding IsToggled}\n/\n\n\n\n\n\nWhen MFractor analyses the \n{Binding IsToggled}\n expression, it will evaluate the \n{x:Reference mySwitch}\n expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch).\n\n\nImplicit Binding Context Resolution\n\n\nIn addition to explicit binding context resolution, MFractor will attempt to infer the relationship between your view models and xaml views via \nimplicit binding context resolution\n. This is done by looking for classes and Xaml views that share a common naming convention.\n\n\nLet's consider the following files:\n\n\n\n\nLoginPage.xaml\n - The xaml view.\n\n\nLoginPage.xaml.cs\n - The code behind for the xaml view.\n\n\nLoginViewModel\n - The a C# class that is the view model for the LoginPage view.\n\n\n\n\n\n\nBecause these pages share the prefix \nLogin\n and each has a distinct file extension or suffix, we can infer the following relationships:\n\n\n\n\nThe \n.xaml\n extension denotes that \nLoginPage.xaml\n is a xaml view.\n\n\nThe \n.xaml.cs\n extension and the \nLoginPage\n component denotes that \nLoginPage.xaml.cs\n is the code behind implementation \nLoginPage\n view.\n\n\nThe \nViewModel\n suffix implies that \nLoginViewModel\n is a view model. When \nViewModel\n is removed from \nLoginViewModel\n and \nPage\n is removed from \nLoginPage\n, the \nLogin\n component implies that the \nLoginViewModel\n is related to the \nLoginPage\n xaml view and it's code behind file.\n\n\n\n\nMFractor uses these common naming conventions of Page.xaml, Page.xaml.cs and ViewModel to decide that \nLoginViewModel\n will probably be the BindingContext for \nLoginPage\n. It will then\n\n\nThe following suffixes are supported for Xaml views:\n\n\n\n\nPage\n: EG LoginPage.xaml \n-\n LoginViewModel\n\n\nView\n: EG LoginView.xaml \n-\n LoginViewModel\n\n\n\n\nExplicit binding context resolution will \nalways\n override implicit binding context resolution. If your xaml views are named using the conventions listed above but your page or a view explicitly assigns the \nBindingContext\n property then MFractor will use the \nBindingContext\n return type instead of the implicit Mvvm relationship.\n\n\nData Template Binding Context Resolution\n\n\nData templates are used to provide a nested Xaml view to a view that displays many occurances of that view. For example, a ListView uses a \nDataTemplate\n to specify the view appearance of each instance provided through the \nItemsSource\n property.\n\n\nMFractor will attempt to infer the BindingContext for a data templates view by resolving the \nItemsSource\n property on the wrapping view.\n\n\nConsider the following code:\n\n\n  \nListView ItemsSource=\n{Binding Contacts}\n\n    \nListView.ItemTemplate\n\n      \nListView.ItemTemplate\n\n        \nDataTemplate\n\n          \nTextCell Text=\n{Binding DisplayName}\n /\n\n        \n/DataTemplate\n\n      \n/ListView.ItemTemplate\n\n  \n/ListView\n\n\n\n\n\nThe inner \nDataTemplate\n has a \nTextCell\n where the \nText\n property is provided by the binding expression \n{Binding DisplayName}\n. To analyse this expression, MFractor requires a binding context; MFractor will walk out the wrapping view (ListView), locate the \nItemsSource\n property and evaluate the expression. When the return type is a IEnumerable or array, MFractor unwraps the generic or array and grabs the inner type. This provides the C# type of the binding context for all binding expressions used within the data template.\n\n\nSummary\n\n\nIn summary, we've learnt that MFractor will use the binding context to power the Xaml analyser and navigation improvements.\n\n\n\n\nBinding expressions require a binding context to be analysed.\n\n\nWe can explicitly specify a binding context by assigning the \nBindingContext\n property of any Xaml element.\n\n\nWhen we name our code files using the Page.xaml, Page.xaml.cs and ViewModel convention, MFractor will assume an implicit MVVM relationship.\n\n\nData templates use the return type of the wrapping views \nItemSource\n property.", 
            "title": "Configure Binding Context"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#configuring-a-binding-context", 
            "text": "In Mvvm architected applications, views use a  Binding Context  to display and transfer data between the application logic layer and the view layer with minimal dependencies. This is accomplished through  data binding ; properties on a view are bound to properties on a backing object through binding mechanisms allowing two-way data transfer between the UI and application logic. For a full tutorial on Mvvm architecture, please Microsofts  The Mvvm Pattern  article.  When using MFractor for Xamarin.Forms, we can specify a binding context to get the most out of MFractors xaml analyser. If MFractor can resolve a binding context for a Xaml view, it will consume binding expressions and analyse them. This is tremendously beneficial as MFractor will pickup runtime errors and high-light them directly within the Xaml editor.  We can specify a binding context  explicitly  via in inline Xaml expression or  implicitly  through the use of common MVVM naming conventions.", 
            "title": "Configuring A Binding Context"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#explicit-binding-context-resolution", 
            "text": "Let's start with explicitly providing a binding context to MFractor.  In Xamarin.Forms, all views have the property  BindingContext ; this specifies the object that a view should data-bind with. When coding with Xaml, we can use the  x:Static  markup extension to reference a static C# property and explicitly provide an instance of a C# class as the binding context:    Entry BindingContext= {x:Static local:MyStaticClass.MyStaticProperty} /   This is known as the  View Model Locator Pattern . We implement a static class named  ViewModelLocator  and use a static, readonly property to return an instance of the object we want our Xaml view to data-bind with. Historically the  View Model Locator Pattern  has been used to provide design time data to the Xamarin.Forms Xaml previewer. For a deeper insight into this pattern, read James Montemagnos excellent  View Model Locator  article.  For example, given a Xaml page named  LoginPage , we could explicitly provide an instance of  LoginViewModel  as the binding context like so:  View Model Locator  public namespace MyApp\n{\n  public static class ViewModelLocator\n  {\n      public static readonly LoginViewModel LoginViewModel = new LoginViewModel();\n  }\n}  LoginPage.xaml  ContentPage\n  xmlns:local= clr-namespace:MyApp;assembly=MyApp \n  BindingContext= {x:Static local:ViewModelLocator.LoginViewModel} /   When MFractor begins analysis on LoginPage.xaml it will check if any  BindingContext  properties have been assigned to. As the root  ContentPage  assigns a binding context, it will inspect the value component of the  BindingContext  attribute, check if it is a Xaml expression and then evaluate it for the return type.  For the  {x:Static local:ViewModelLocator.LoginViewModel}  expression, MFractor will resolve the  ViewModelLocator  class in the  local  namespace and then grab the C# type of the  LoginViewModel  property. This informs MFractor that the page will be bound to a  LoginViewModel  instance and therefore to analyse all  Binding  expressions against the  LoginViewModel  type.  Explicit binding context resolution will also work when referencing another element using  x:Reference  expressions. For example, we can bind the on/off state of a switch to the visibility of a text label like so:     Switch x:Name= mySwitch  / \n   Label BindingContext= {x:Reference mySwitch}  IsVisible= {Binding IsToggled} /   When MFractor analyses the  {Binding IsToggled}  expression, it will evaluate the  {x:Reference mySwitch}  expression and use the type of mySwitch as the BindingContext (Xamarin.Forms.Switch).", 
            "title": "Explicit Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#implicit-binding-context-resolution", 
            "text": "In addition to explicit binding context resolution, MFractor will attempt to infer the relationship between your view models and xaml views via  implicit binding context resolution . This is done by looking for classes and Xaml views that share a common naming convention.  Let's consider the following files:   LoginPage.xaml  - The xaml view.  LoginPage.xaml.cs  - The code behind for the xaml view.  LoginViewModel  - The a C# class that is the view model for the LoginPage view.    Because these pages share the prefix  Login  and each has a distinct file extension or suffix, we can infer the following relationships:   The  .xaml  extension denotes that  LoginPage.xaml  is a xaml view.  The  .xaml.cs  extension and the  LoginPage  component denotes that  LoginPage.xaml.cs  is the code behind implementation  LoginPage  view.  The  ViewModel  suffix implies that  LoginViewModel  is a view model. When  ViewModel  is removed from  LoginViewModel  and  Page  is removed from  LoginPage , the  Login  component implies that the  LoginViewModel  is related to the  LoginPage  xaml view and it's code behind file.   MFractor uses these common naming conventions of Page.xaml, Page.xaml.cs and ViewModel to decide that  LoginViewModel  will probably be the BindingContext for  LoginPage . It will then  The following suffixes are supported for Xaml views:   Page : EG LoginPage.xaml  -  LoginViewModel  View : EG LoginView.xaml  -  LoginViewModel   Explicit binding context resolution will  always  override implicit binding context resolution. If your xaml views are named using the conventions listed above but your page or a view explicitly assigns the  BindingContext  property then MFractor will use the  BindingContext  return type instead of the implicit Mvvm relationship.", 
            "title": "Implicit Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#data-template-binding-context-resolution", 
            "text": "Data templates are used to provide a nested Xaml view to a view that displays many occurances of that view. For example, a ListView uses a  DataTemplate  to specify the view appearance of each instance provided through the  ItemsSource  property.  MFractor will attempt to infer the BindingContext for a data templates view by resolving the  ItemsSource  property on the wrapping view.  Consider the following code:     ListView ItemsSource= {Binding Contacts} \n     ListView.ItemTemplate \n       ListView.ItemTemplate \n         DataTemplate \n           TextCell Text= {Binding DisplayName}  / \n         /DataTemplate \n       /ListView.ItemTemplate \n   /ListView   The inner  DataTemplate  has a  TextCell  where the  Text  property is provided by the binding expression  {Binding DisplayName} . To analyse this expression, MFractor requires a binding context; MFractor will walk out the wrapping view (ListView), locate the  ItemsSource  property and evaluate the expression. When the return type is a IEnumerable or array, MFractor unwraps the generic or array and grabs the inner type. This provides the C# type of the binding context for all binding expressions used within the data template.", 
            "title": "Data Template Binding Context Resolution"
        }, 
        {
            "location": "/xamarin-forms/configure-binding-context/#summary", 
            "text": "In summary, we've learnt that MFractor will use the binding context to power the Xaml analyser and navigation improvements.   Binding expressions require a binding context to be analysed.  We can explicitly specify a binding context by assigning the  BindingContext  property of any Xaml element.  When we name our code files using the Page.xaml, Page.xaml.cs and ViewModel convention, MFractor will assume an implicit MVVM relationship.  Data templates use the return type of the wrapping views  ItemSource  property.", 
            "title": "Summary"
        }, 
        {
            "location": "/xamarin-forms/navigation/", 
            "text": "Xaml Navigation\n\n\nMFractor enriches the navigation between C# and Xaml code by adding a few handy shortcuts. We can:\n\n\n\n\nQuickly cycle between views, code behind classes and view models with the Mvvm shortcuts.\n\n\nJump to .NET symbols from Xaml with Go-To Symbol support.\n\n\nHover over any xaml element to see a .NET tooltip along with its included documentation\n\n\nPreview images through image tooltips when we hover over an image source value.\n\n\n\n\nMvvm Navigation\n\n\nA common\n\n\nGo-To Symbol\n\n\n.NET Tooltips\n\n\nImage Tooltips", 
            "title": "Navigation"
        }, 
        {
            "location": "/xamarin-forms/navigation/#xaml-navigation", 
            "text": "MFractor enriches the navigation between C# and Xaml code by adding a few handy shortcuts. We can:   Quickly cycle between views, code behind classes and view models with the Mvvm shortcuts.  Jump to .NET symbols from Xaml with Go-To Symbol support.  Hover over any xaml element to see a .NET tooltip along with its included documentation  Preview images through image tooltips when we hover over an image source value.", 
            "title": "Xaml Navigation"
        }, 
        {
            "location": "/xamarin-forms/navigation/#mvvm-navigation", 
            "text": "A common", 
            "title": "Mvvm Navigation"
        }, 
        {
            "location": "/xamarin-forms/navigation/#go-to-symbol", 
            "text": "", 
            "title": "Go-To Symbol"
        }, 
        {
            "location": "/xamarin-forms/navigation/#net-tooltips", 
            "text": "", 
            "title": ".NET Tooltips"
        }, 
        {
            "location": "/xamarin-forms/navigation/#image-tooltips", 
            "text": "", 
            "title": "Image Tooltips"
        }, 
        {
            "location": "/xamarin-forms/analysis/", 
            "text": "Xaml Analysis\n\n\nIt's common that xaml issues in Xamarin.Forms applications are undetected until runtime or worse, when sent out to a client. Mractor solves this by detecting Xaml issues \nimmediately\n and then marking them inside the xaml editor with a concise error message.\n\n\nBye bye Xaml bugs! \ud83d\udc4b\n\n\nLet's take a look at the\n\n\n\n\nWhen you open a Xaml file that's part of a .NET project, Xamarin Studio will notify MFractor that a new Xaml document has been opened for editing. MFractor will then inject it's Xaml analyser into the xaml editor and consume the xaml document.\n\n\nOnce MFractor has a copy of the Xaml DOM, it \nsymbolicates\n the xaml document. In this step all Xaml nodes are resolved to their corresponding .NET class, all attributes are resolved to properties, fields or methods and all markup extension expressions are parsed.\n\n\nIt may take a little while for MFractor to parse and symbolicate the Xaml DOM the first time a solution opens, you might see a tooltip informing you that MFractor is not quite ready to analyse the document:\n\n\n\n\nWhen the Xaml document has been parsed and symbolicated, MFractor will analyse the document for a range of code issues. Any issues that are found are marked as either\n\n\nA full list of available Xaml analysers can be found at:\n\n\n\n\nXamarin.Forms Analysers\n\n\n\n\nWhenever you edit a Xaml code file, MFractor will cancel any running analysis, re-parse and symbolicate the document and then re-run the xaml analyser against your xaml.\n\n\nCode Fixes\n\n\nWhen MFractor detects a code issue, it is usually able to suggest a fix as well. When MFractor can fix an issue, the squiggle beneath that issue will be yellow like so:\n\n\nYou can action this fix by right clicking on the text area marked by the yellow squiggle\n\n\nSee \nRefactoring Code Generation\n for further documentation on using Xaml to C# code generation.\n\n\nExpression Analysis\n\n\nBinding Expression Analysis", 
            "title": "Analysis"
        }, 
        {
            "location": "/xamarin-forms/analysis/#xaml-analysis", 
            "text": "It's common that xaml issues in Xamarin.Forms applications are undetected until runtime or worse, when sent out to a client. Mractor solves this by detecting Xaml issues  immediately  and then marking them inside the xaml editor with a concise error message.  Bye bye Xaml bugs! \ud83d\udc4b  Let's take a look at the   When you open a Xaml file that's part of a .NET project, Xamarin Studio will notify MFractor that a new Xaml document has been opened for editing. MFractor will then inject it's Xaml analyser into the xaml editor and consume the xaml document.  Once MFractor has a copy of the Xaml DOM, it  symbolicates  the xaml document. In this step all Xaml nodes are resolved to their corresponding .NET class, all attributes are resolved to properties, fields or methods and all markup extension expressions are parsed.  It may take a little while for MFractor to parse and symbolicate the Xaml DOM the first time a solution opens, you might see a tooltip informing you that MFractor is not quite ready to analyse the document:   When the Xaml document has been parsed and symbolicated, MFractor will analyse the document for a range of code issues. Any issues that are found are marked as either  A full list of available Xaml analysers can be found at:   Xamarin.Forms Analysers   Whenever you edit a Xaml code file, MFractor will cancel any running analysis, re-parse and symbolicate the document and then re-run the xaml analyser against your xaml.", 
            "title": "Xaml Analysis"
        }, 
        {
            "location": "/xamarin-forms/analysis/#code-fixes", 
            "text": "When MFractor detects a code issue, it is usually able to suggest a fix as well. When MFractor can fix an issue, the squiggle beneath that issue will be yellow like so:  You can action this fix by right clicking on the text area marked by the yellow squiggle  See  Refactoring Code Generation  for further documentation on using Xaml to C# code generation.", 
            "title": "Code Fixes"
        }, 
        {
            "location": "/xamarin-forms/analysis/#expression-analysis", 
            "text": "", 
            "title": "Expression Analysis"
        }, 
        {
            "location": "/xamarin-forms/analysis/#binding-expression-analysis", 
            "text": "", 
            "title": "Binding Expression Analysis"
        }, 
        {
            "location": "/xamarin-forms/refactoring-and-code-generation/", 
            "text": "", 
            "title": "Refactoring And Code Generation"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/analysers/", 
            "text": "", 
            "title": "Analysers"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/refactorings/", 
            "text": "", 
            "title": "Refactorings"
        }, 
        {
            "location": "/xamarin-forms/tools-in-depth/fixes/", 
            "text": "", 
            "title": "Fixes"
        }, 
        {
            "location": "/xamarin-android/quickstart/", 
            "text": "WORK IN PROGRESS\n\n\nMFractor for Xamarin.Android", 
            "title": "Quickstart"
        }, 
        {
            "location": "/xamarin-android/quickstart/#mfractor-for-xamarinandroid", 
            "text": "", 
            "title": "MFractor for Xamarin.Android"
        }, 
        {
            "location": "/xamarin-android/navigation/", 
            "text": "", 
            "title": "Navigation"
        }, 
        {
            "location": "/xamarin-android/analysis/", 
            "text": "", 
            "title": "Analysis"
        }, 
        {
            "location": "/xamarin-android/refactoring-and-code-generation/", 
            "text": "", 
            "title": "Refactoring And Code Generation"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/analysers/", 
            "text": "", 
            "title": "Analysers"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/refactorings/", 
            "text": "", 
            "title": "Refactorings"
        }, 
        {
            "location": "/xamarin-android/tools-in-depth/fixes/", 
            "text": "", 
            "title": "Fixes"
        }, 
        {
            "location": "/tutorials/xamarin-android/resource-expressions-and-code-navigation/", 
            "text": "If you\u2019re a Xamarin.Android developer building apps using the native APIs then chances are you spend a lot of time navigating resource code.\n\n\nThis becomes tedious when you are constantly doing manual searches for your target, browsing through the find results and then clicking the search result to jump to it. What\u2019s more, using go-to declaration on a C# resource symbol takes you to its integer id! It\u2019s tremendously frustrating and a massive time-waster.\n\n\nAnd this problem gets worse the bigger your project is; large Android applications can have dozens to hundreds of xml resources that need to be scanned each time a search takes place.\n\n\nMFractor addresses these navigation issues by overriding the default \u201cgo to declaration\u201d keyboard shortcuts when you are in the context of a resource expression.\n\n\nThese expressions come in 2 flavours:\n\n\n\n\nC#: Code expressions within C# that access the generated Resources class contained in the Resources.Designer.cs file. For instance; Resource.Layout.myLayout.\n\n\nXML: Code expressions within Android xml resources that point to another resource. For instance; @layout/myLayout.\n\n\n\n\nWhen MFractor detects the cursor is within one of these expressions, resource tooltips and go-to-declaration become active. This enables fast and efficient code navigation.\n\n\nIt looks a little like this when in action:\n\n\nThat is much faster than manual searching! Now lets go over each of these expression types.\n\n\nC# Resource Expressions\n\n\nFor C#, resource expressions are always resolved against the Resource.Designer.cs file that is generated alongside a project. This section assumes a basic familiarity of the Resource.Designer.cs file; if this is a new concept I suggested reading the \nAndroid Resource Basics\n page in Xamarins documentation.\n\n\nThe components of a supported resource expression are formatted like so:\n\n\n[Project Namespace].[Resource].[ResourceType].[ResourceName]\n\n\n\n\nWhere:\n\n\n\n\n[Project Namespace] is the project namespace that the Resources designer class resides. This component is either:\n\n\nImplicit: The encapsulating namespace is the same as the resource designers namespace or a using statement provides the resource designer class.\n\n\nExplicit: The expression explicitly uses the namespace that owns the resource class.\n\n\nResource is the constant Resource class that wraps the declarations of the ResourceType sub-classes.\n\n\nResourceType is the nested resource type class.\n\n\nResourceName is the name of the resource being referenced. MFractor will only trigger its behaviour when your caret or mouse cursor is over this component of the c# resource expression.\n\n\n\n\nAn example of a valid expression would be:\n\n\nResources.String.my_string;\n\n\n\n\nWhen your cursor is over the my_string component of this expression, MFractor will attempt to resolve a string resource named my_string.\n\n\nXml Resource Expressions\n\n\nXml resource expressions come in 3 different categories:\n\n\n\n\nReference expressions point directly to a resource. They begin with the \u2018@\u2019 character.\n\n\nDeclarative expressions declare a new resource. These are only used with ids. They begin with a \u2018@+\u2019 character sequence.\n\n\nTheme expression point to a component of the currently scoped theme. They begin with a \u2018?\u2019 character.\n\n\n\n\nReference and declarative expression are structured with the following syntax:\n\n\n@[+][PackageName:]resourceType/resourceName\n\n\n\n\nWhere:\n\n\n\n\n@[+] is the resource reference symbol.\n\n\nPackageName is an optional component that points to the package the resource is within.\n\n\nresourceType is the resource type.\n\n\nresourceName is the name of the resource.\n\n\n\n\nAn example of this would be:\n\n\n@string/my_string\n\n\n\n\nWhen your cursor is any component of this expression, MFractor will attempt to resolve a pre-existing string resource named my_string.\n\n\nLastly, theme resource expressions point to a component of the current theme. These are structured with the following syntax:\n\n\n?[PackageName:][ResourceType/]themeItemName\n\n\n\n\nWhere:\n\n\n\n\nPackageName is the optional package name the theme component resides within.\n\n\nResourceType is the optional resource type of the theme component. This is typically inferred.\n\n\nthemeItemName the name of the theme item.", 
            "title": "Resource Expressions And Code Navigation"
        }, 
        {
            "location": "/tutorials/xamarin-android/resource-expressions-and-code-navigation/#c-resource-expressions", 
            "text": "For C#, resource expressions are always resolved against the Resource.Designer.cs file that is generated alongside a project. This section assumes a basic familiarity of the Resource.Designer.cs file; if this is a new concept I suggested reading the  Android Resource Basics  page in Xamarins documentation.  The components of a supported resource expression are formatted like so:  [Project Namespace].[Resource].[ResourceType].[ResourceName]  Where:   [Project Namespace] is the project namespace that the Resources designer class resides. This component is either:  Implicit: The encapsulating namespace is the same as the resource designers namespace or a using statement provides the resource designer class.  Explicit: The expression explicitly uses the namespace that owns the resource class.  Resource is the constant Resource class that wraps the declarations of the ResourceType sub-classes.  ResourceType is the nested resource type class.  ResourceName is the name of the resource being referenced. MFractor will only trigger its behaviour when your caret or mouse cursor is over this component of the c# resource expression.   An example of a valid expression would be:  Resources.String.my_string;  When your cursor is over the my_string component of this expression, MFractor will attempt to resolve a string resource named my_string.", 
            "title": "C# Resource Expressions"
        }, 
        {
            "location": "/tutorials/xamarin-android/resource-expressions-and-code-navigation/#xml-resource-expressions", 
            "text": "Xml resource expressions come in 3 different categories:   Reference expressions point directly to a resource. They begin with the \u2018@\u2019 character.  Declarative expressions declare a new resource. These are only used with ids. They begin with a \u2018@+\u2019 character sequence.  Theme expression point to a component of the currently scoped theme. They begin with a \u2018?\u2019 character.   Reference and declarative expression are structured with the following syntax:  @[+][PackageName:]resourceType/resourceName  Where:   @[+] is the resource reference symbol.  PackageName is an optional component that points to the package the resource is within.  resourceType is the resource type.  resourceName is the name of the resource.   An example of this would be:  @string/my_string  When your cursor is any component of this expression, MFractor will attempt to resolve a pre-existing string resource named my_string.  Lastly, theme resource expressions point to a component of the current theme. These are structured with the following syntax:  ?[PackageName:][ResourceType/]themeItemName  Where:   PackageName is the optional package name the theme component resides within.  ResourceType is the optional resource type of the theme component. This is typically inferred.  themeItemName the name of the theme item.", 
            "title": "Xml Resource Expressions"
        }, 
        {
            "location": "/release-notes/v2-7/", 
            "text": "\ufeff# Release Notes - v2.7.0\n\n\n-- TODO: Date Here --\n\n\nDownload MFractor 2.7.0\n\n\n\n\nThis is a summary of the changes introduced in v2.7.0 of MFractor for Xamarin Studio.\n\n\nYou already love being able to generate bindings but I've taken it to the next level this release...\n\n\nIntroducing View Model generation:\n\n\nTODO: View model generation gif here\n\n\n\nGot a heap of unimplemented bindings? Right click anywhere in your Xaml document and select \nRefactor\n -\n \nImplement View Model\n.\n\n\nMFractor will collect all the missing bindings and then generate a new class with \nall\n of those properties into the \"MyDefaultNamespace.ViewModels\".\n\n\nDoes the view model already exist? Then MFractor simply inserts the new bindings into the existing view model.\n\n\nI think it'll save you enough time during the week that you may just get to Friday beers a few hours early ;)\n\n\nFeatures:\n\n\n\n\nBy right clicking anywhere in a Xaml document, implement all missing bindings as a new or into an existing view model:\n\n\nImplement view model as\n\n\n\n\n\n\nNew Xaml Analysers:\n\n\nValidate that elements declared inside a resource dictionary have an x:Key.\n\n\nValidate that elements declared inside a resource dictionary have a unique x:Key value.\n\n\nDetect when an x:TypeArguments is used on a non-generic type and warn of incorrect usage.\n\n\nDetect when a property setter node (\n) references a non-existant member on the parent class.\n\n\nDetect when a property setter attribute is empty.\n\n\nDetect when an undefined static resource is referenced by a StaticResource expression.\n\n\nDetect when the value returned by a StaticResource expression causes a type mismatch.\n\n\nDetect when an unknown type is being provided to a x:TypeArguments attribute.\n\n\nValidate that OnIdiom elements return the correct type for the outer property setter.\n\n\nValidate that OnPlatform elements return the correct type for the outer property setter.\n\n\nDetect when a developer has misused a property setter inside another xaml element. For example, OnIdiom.Phone doesn't make any sense when wrapped by the outer element OnPlatform.\n\n\n\n\n\n\nNew Xaml Fixes:\n\n\nGenerate missing resource dictionary keys.\n\n\nAuto-correct mispelt StaticResource references.\n\n\n\n\n\n\nNew Simplify Refactorings:\n\n\nAttributes that use a static instance to initialise the property (eg VerticalOptions=\"LayoutOptions.CentreAndExpand\") can now be simplified to just the instance name (eg VerticalOptions=\"CentreAndExpand\").\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nThe \"About MFractor\" dialog now contains a button to copy version and IDE information into the clipboard for bug reports.\n\n\nThis release introduces the framework for an Xml refactoring engine. Over time, I'll be adding Xml and Xaml refactoring operations to make code cleanup a breeze.\n\n\nAnnotating value converters with a ValueConversion(input, output) attribute will trigger the conversion information to render into tooltip.\n\n\n\n\nBug Fixes:\n\n\n\n\nSometimes the Xaml document analyser would fail to load and bring down the Xaml editor. This has been fixed.\n\n\nFixed a bug that caused View \n - \n Code Behind navigation shortcuts to break when an AST parse was in progress. View \n - \n Code Behind shortcuts should now always be active.\n\n\nWhen property setter nodes are used (\n), the class component is now correctly validated.\n\n\nWhen importing a Xaml namespace, the element is inserted on a newline and formatted to align with other attributes.\n\n\nWhen resolving the binding context for nested DataTemplates, sometimes the binding context resolver would fail on generics or IEnumerables\n\n\nMore resilient Mvvm resolver to drive the 'Go To View Model', 'Go To Xaml View' and 'Go To Code Behind' shortcuts. MFractor will attempt to infer as best possible the associations between those 3 files.\n\n\nSave the project after adding a new file to it.", 
            "title": 2.7
        }, 
        {
            "location": "/release-notes/v2-7/#features", 
            "text": "By right clicking anywhere in a Xaml document, implement all missing bindings as a new or into an existing view model:  Implement view model as    New Xaml Analysers:  Validate that elements declared inside a resource dictionary have an x:Key.  Validate that elements declared inside a resource dictionary have a unique x:Key value.  Detect when an x:TypeArguments is used on a non-generic type and warn of incorrect usage.  Detect when a property setter node ( ) references a non-existant member on the parent class.  Detect when a property setter attribute is empty.  Detect when an undefined static resource is referenced by a StaticResource expression.  Detect when the value returned by a StaticResource expression causes a type mismatch.  Detect when an unknown type is being provided to a x:TypeArguments attribute.  Validate that OnIdiom elements return the correct type for the outer property setter.  Validate that OnPlatform elements return the correct type for the outer property setter.  Detect when a developer has misused a property setter inside another xaml element. For example, OnIdiom.Phone doesn't make any sense when wrapped by the outer element OnPlatform.    New Xaml Fixes:  Generate missing resource dictionary keys.  Auto-correct mispelt StaticResource references.    New Simplify Refactorings:  Attributes that use a static instance to initialise the property (eg VerticalOptions=\"LayoutOptions.CentreAndExpand\") can now be simplified to just the instance name (eg VerticalOptions=\"CentreAndExpand\").", 
            "title": "Features:"
        }, 
        {
            "location": "/release-notes/v2-7/#enhancements", 
            "text": "The \"About MFractor\" dialog now contains a button to copy version and IDE information into the clipboard for bug reports.  This release introduces the framework for an Xml refactoring engine. Over time, I'll be adding Xml and Xaml refactoring operations to make code cleanup a breeze.  Annotating value converters with a ValueConversion(input, output) attribute will trigger the conversion information to render into tooltip.", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v2-7/#bug-fixes", 
            "text": "Sometimes the Xaml document analyser would fail to load and bring down the Xaml editor. This has been fixed.  Fixed a bug that caused View   -   Code Behind navigation shortcuts to break when an AST parse was in progress. View   -   Code Behind shortcuts should now always be active.  When property setter nodes are used ( ), the class component is now correctly validated.  When importing a Xaml namespace, the element is inserted on a newline and formatted to align with other attributes.  When resolving the binding context for nested DataTemplates, sometimes the binding context resolver would fail on generics or IEnumerables  More resilient Mvvm resolver to drive the 'Go To View Model', 'Go To Xaml View' and 'Go To Code Behind' shortcuts. MFractor will attempt to infer as best possible the associations between those 3 files.  Save the project after adding a new file to it.", 
            "title": "Bug Fixes:"
        }, 
        {
            "location": "/release-notes/v2-6/", 
            "text": "\ufeff# Release Notes - v2.6.0\n\n\n31st October 2016\n\n\nDownload MFractor 2.6.0\n\n\n\n\nThis is a summary of the changes introduced in v2.6.0 of MFractor for Xamarin Studio.\n\n\nAs a major release, this release adds several code generation capabilities to improve your Xaml workflow. Generate views, classes and value converters in only a few clicks...\n\n\nJust right click on that little yellow squiggle and use the fix to generate a whole lotta code:\n\n\nThere are also more xaml code checks to watch out for nasty Xaml issues and bug fixes galore.\n\n\nEnjoy!\n\n\nFeatures:\n\n\n\n\nNew code generation capabilities:\n\n\nGenerate classes from \n in xaml.\n\n\nGenerate views from \n in xaml.\n\n\nGenerate value converters when a missing xaml node ends with \"[cC]onverter] in xaml.\n\n\n\n\n\n\nNew Xaml analysers:\n\n\nFor generics, validate that an x:TypeArguments attribute or xml node setter exists.\n\n\nFor generics, validate that the count of parameters provided to x:TypeArguments matches the generics signature.\n\n\nValidate the root xaml node contains an x:Class directive to set the code behind class name and namespace.\n\n\n\n\n\n\n\n\nEnhancements\n\n\n\n\nThis release targets Xamarin Studio v6.1.1 \n\n\n\n\nBug Fixes:\n\n\n\n\nFix a bug in xaml namespace resolution that prevented the \"import new xmlns\" fix from triggering.\n\n\nAllow importing of xaml namespaces from x:Static symbols.\n\n\nFor Setters, don't validate TargetType property that the provided type is a static member of System.Type.\n\n\nWhen a symbol name matches but its in the wrong namespace, don't suggest it as a fix.\n\n\nRemove the MFractor settings panel to fix the Xamarin Studio preferences dialog from not opening when it didn't exist.\n\n\nWhen using native view declaration, the xaml symbolicator will now honor the targetPlatform flag and find the assembly for that platform. Previously this was a naive search that used the first assembly found; using the wrong symbols if a assembly of the same name existed in both an iOS and Android project.", 
            "title": 2.6
        }, 
        {
            "location": "/release-notes/v2-6/#features", 
            "text": "New code generation capabilities:  Generate classes from   in xaml.  Generate views from   in xaml.  Generate value converters when a missing xaml node ends with \"[cC]onverter] in xaml.    New Xaml analysers:  For generics, validate that an x:TypeArguments attribute or xml node setter exists.  For generics, validate that the count of parameters provided to x:TypeArguments matches the generics signature.  Validate the root xaml node contains an x:Class directive to set the code behind class name and namespace.", 
            "title": "Features:"
        }, 
        {
            "location": "/release-notes/v2-6/#enhancements", 
            "text": "This release targets Xamarin Studio v6.1.1", 
            "title": "Enhancements"
        }, 
        {
            "location": "/release-notes/v2-6/#bug-fixes", 
            "text": "Fix a bug in xaml namespace resolution that prevented the \"import new xmlns\" fix from triggering.  Allow importing of xaml namespaces from x:Static symbols.  For Setters, don't validate TargetType property that the provided type is a static member of System.Type.  When a symbol name matches but its in the wrong namespace, don't suggest it as a fix.  Remove the MFractor settings panel to fix the Xamarin Studio preferences dialog from not opening when it didn't exist.  When using native view declaration, the xaml symbolicator will now honor the targetPlatform flag and find the assembly for that platform. Previously this was a naive search that used the first assembly found; using the wrong symbols if a assembly of the same name existed in both an iOS and Android project.", 
            "title": "Bug Fixes:"
        }, 
        {
            "location": "/release-notes/v2-5/", 
            "text": "\ufeff# Release Notes 2.5.3\n\n\n10th of October 2016\n\n\nThis is a summary of the changes introduction in Version 2.5.3 of MFractor for Xamarin Studio.\n\n\nThis release adds support for native view declaration and property generation for missing view attributes.\n\n\nFeatures:\n - Generate properties and bindable properties onto classes that implement Xamarin.Forms.ObservableObject.\n - Full support for native view declaration. Tooltips, go-to declaration, xaml analysis and code generation enabled on native views used in Xaml.\n\n\nBug Fixes:\n - Xaml expressions now parsed on attributes that are unresolveable to a .NEt symbol. This enables Tooltips, go-to declaration, xaml analysis and code generation.\n - The analysis engine no longer assumes that the Xamarin.Forms and Microsoft schemas are the implicit and 'x' namespaces. This means that Xamarin.Forms could be remapped to xmlns:xf etc and the analyser would still function correctly.", 
            "title": 2.5
        }
    ]
}