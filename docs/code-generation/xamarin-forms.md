*Autogenerated by MFractor v3.2.14*
## Generate Bindable Property

**Configuration Id: com.mfractor.code_gen.forms.csharp.bindable_property**

Generates a Xamarin.Forms bindable property implementation and a proxy property that calls the `BindableProperty` implementation.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **Snippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`name`: The name of the new bindable property.</li><li>`type`: The type of the new bindable property.</li><li>`control_type`: The control type that the new bindable property has been created inside.</li></ul> | <code>public static readonly Xamarin.Forms.BindableProperty $name$Property = Xamarin.Forms.BindableProperty.Create(nameof($name$), typeof($type$), typeof($control_type$), default($type$));<br/>public bool $name$<br/>{<br/>    get<br/>    {<br/>        return ($type$)GetValue($name$Property);<br/>    }<br/><br/>    set<br/>    {<br/>        SetValue($name$Property, value);<br/>    }<br/>}</code> | When creating the new bindable property, what is the default code snippet MFractor should use? |

## Generate ICommand Implementation

**Configuration Id: com.mfractor.code_gen.forms.csharp.command_implementation**

Generates a boilerplate implementation of ICommand using an inline Xamarin.Forms.Command.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **Snippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`name`: The name of the new command.</li><li>`type`: The fully qualified type of the new command</li></ul> | <code>public System.Windows.Input.ICommand $name<br/>{<br/>    get<br/>    {<br/>        return new $type$(() =><br/>        {<br/>            throw new System.NotImplementedException();<br/>        });<br/>    }<br/>}</code> | What is the code snippet to use when creating the command stub? If not set, this code generator will default to generating a stub `Xamarin.Forms.Command` implementation |
| **CommandType** | `System.String` | `"Xamarin.Forms.Command"` | The fully qualified type to use as the command implementation. For example, using `Xamarin.Forms.Command` would cause the new expression to be `new Xamarin.Forms.Command` |

## Generate IValueConverter Implementation

**Configuration Id: com.mfractor.code_gen.forms.csharp.value_converter**

Generates an implementation of a value converter.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **IncludeValueConversionAttribute** | `System.Boolean` | `True` | If the generated value converter should automatically have a ValueConversionAttribute added to it to denote it's input and output types. |
| **CreateMissingValueConversionAttribute** | `System.Boolean` | `True` | If an implementation of the ValueConversionAttribute class cannot be resolved within the project compilation, should MFractor automatically create the implementation? |
| **Namespace** | `System.String` | `null` | The namespace to place new value converters inside. When empty, new value converters will be placed under the projects default namespace. Place a single '.' before the namespace name to make it relative to the projects default namespace. |
| **Folder** | `System.String` | `null` | The folder to place new value converters inside. When empty, new value converters will be placed inside the proejcts root folder. |
| **ImplementConversionForConvert** | `System.Boolean` | `False` | When creating the body of the `Convert` method, should a `var input = (InputType)value;* and `return default(OutputType)` be inserted instead of a not implemented exception? |
| **ImplementConversionForConvertBack** | `System.Boolean` | `False` | When creating the body of the `ConvertBack` method, should a `var input = (OutputType)value;* and `return default(InputType)` be inserted instead of a not implemented exception? |

### Uses:

 * [Generate Value Conversion Attribute](/code-generation/xamarin-forms.md#generate-value-conversion-attribute)
 * [Using Directive Generator](/code-generation/csharp.md#using-directive-generator)
 * [Namespace Declaration](/code-generation/csharp.md#namespace-declaration)


## Generate Value Conversion Attribute

**Configuration Id: com.mfractor.code_gen.forms.csharp.value_conversion_attribute**

Generates an implementation of the `ValueConversionAttribute`; the attribute used to hint type-flow in a value converter for design time tools like MFractor.


### Uses:

 * [Using Directive Generator](/code-generation/csharp.md#using-directive-generator)
 * [Namespace Declaration](/code-generation/csharp.md#namespace-declaration)


## Generate View With XAML and Code-Behind Class

**Configuration Id: com.mfractor.code_gen.forms.xaml_view_with_code_behind**

Creates a new view/control using a XAML to define the UI and a code-behind class to encapsulate backing logic.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **ViewsFolder** | `System.String` | `null` | What is the folder that new XAML views be placed into? |
| **CodeBehindSnippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`name`: The name of the new class.</li><li>`namespace`: The namespace that the new class resides inside.</li><li>`type`: The base type of the new class.</li></ul> | <code>using System;<br/><br/>namespace $namespace$<br/>{<br/>    public partial class $name$ : $type$<br/>    {<br/>        public $name$()<br/>        {<br/>            InitializeComponent();<br/>        }<br/>    }<br/>}</code> | What is the default implementation of the new XAML control's code behind class? |

### Uses:

 * [Using Directive Generator](/code-generation/csharp.md#using-directive-generator)
 * [Namespace Declaration](/code-generation/csharp.md#namespace-declaration)


## String Localisation Generator

**Configuration Id: com.mfractor.code_gen.forms.replace_with_localisation_lookup**

The string localisation generator converts literal string value inside a XAML document to a localised value lookup. This replaces the text with a localistaion lookup extension and generates a resx entry for the old value.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **TranslateExtensionSymbol** | `System.String` | `".TranslateExtension"` | What is the full sybol name (namespace + class name) of the translate markup extension? Prepend the symbol name with a dot to make it relative to the projects default namespace. For example, using `.Localisation.TranslateExtension` when the default namespace is `MyApp` would cause the full symbol name to become `MyApp.Localisation.TranslateExtension`. |
| **TranslationXamlNamespace** | `System.String` | `"i18n"` | When importing a XAML namespace reference to the translation extension, what is the default namespace name that should be used? |

### Uses:

 * [Generate ResX Entry](/code-generation/resx.md#generate-resx-entry)
 * [Default Resource File](/resx/configuration.md#default-resource-file)


## View Model Property Generator

**Configuration Id: com.mfractor.code_gen.forms.csharp.view_model_property**

Generates a property declaration for a Xamarin.Forms ViewModel. By default, this code generator routes to the standard PropertyGenerator. However, specifying a code snippet will cause the code generator to use that instead.


### Configurable Properties

| Name | Type | Defaults To | Description |
|------|------|-------------|-------------|
| **Snippet** | `Code Snippet`<br/><br/>**Arguments**:<ul><li>`type`: The fully qualified type of the new property.</li><li>`name`: The name of the new propety.</li><li>`value`: The value to assign to the new property.</li></ul> | `null` | What is the code snippet to use when creating the property declaration? If not set, this code generator will default to the standard property generator. |

### Uses:

 * [Generate Instance Property](/code-generation/csharp.md#generate-instance-property)


